<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.44">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a41919}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #36701f}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #001ab2}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a81a1a}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
span.s1 {color: #0000ff}
span.s2 {color: #001ab2}
span.s3 {color: #000000}
span.s4 {color: #36701f}
span.s5 {color: #0020b7}
span.s6 {color: #366f1f}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>PR(\macroRh)</b></p>
<p class="p2"><br></p>
<p class="p3">The primary chord arpeggiation process in chucklib.</p>
<p class="p2"><br></p>
<p class="p3">'macroRh' is a peculiar name, but stems from the fact that there are two concepts of rhythm in arpeggiation: the rhythm of chord changes, which is at a higher level and is correspondingly called "macrorhythm," and the rhythm of the output notes, which is faster (lower level), thereby "microrhythm." In PR(\macroRh), the macrorhythm is generated by a pattern; its companion process, <a href="chTop.html"><span class="s1">chTop</span></a>, derives macrorhythm from a melody.</p>
<p class="p2"><br></p>
<p class="p3"><b>Note:</b> Code in this help file is intended for illustration only. Proper execution depends on resources that will not be created in this file. For a working example, see <a href="ChuckExamples.html"><span class="s1">ChuckExamples</span></a>.</p>
<p class="p2"><br></p>
<p class="p4"><b>Initialization</b></p>
<p class="p2"><br></p>
<p class="p3">Because the chord arpeggiator is a nested process, initialization takes several steps. You can simplify performance initialization using a factory, or use a special-purpose Func that sets all the basic parameters in one operation. First I will describe manual initialization; the constructor Func follows at the end.</p>
<p class="p2"><br></p>
<p class="p3">The nested process has two layers. The inner layer manages the chord notes and streams them out according to values received from the outer layer, which evaluates parameters per chord (not per note). When creating a nested process, always chuck the inner layer into the BP first, then wrap the outer layer around it.</p>
<p class="p2"><br></p>
<p class="p5">// Inner layer: note generator</p>
<p class="p6"><span class="s2">PR</span><span class="s3">(</span>\arpeg1<span class="s3">) =&gt; </span><span class="s2">BP</span><span class="s3">(</span>\chord<span class="s3">);</span></p>
<p class="p5">// Outer layer: chord parameters</p>
<p class="p6"><span class="s2">PR</span><span class="s3">(</span>\macroRh<span class="s3">) =&gt; </span><span class="s2">BP</span><span class="s3">(</span>\chord<span class="s3">);</span></p>
<p class="p2"><br></p>
<p class="p3">After this, BP(\chord) contains the environment variables and methods for PR(\macroRh), and PR(\arpeg1)'s objects have been moved into BP(\chord).child.</p>
<p class="p2"><br></p>
<p class="p3"><b>Initialization: chord forms</b></p>
<p class="p2"><br></p>
<p class="p3">Chord data come from a MIDIRecBuf. The MIDI data are split into separate chords by calculating the average note duration and splitting where the note duration is greater than the average. Playing block chords on a MIDI keyboard works for this; if you program the data in code, I suggest the following:</p>
<p class="p2"><br></p>
<p class="p7">MIDIRecBuf<span class="s3">(</span><span class="s4">\triads</span><span class="s3">, [</span></p>
<p class="p8"><span class="Apple-tab-span">	</span>[60, 64, 67,<span class="Apple-converted-space">Â  </span>62, 67, 71],</p>
<p class="p5"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// average is 8/6 = 1.333; chords split at 2's for groups of 3 notes</p>
<p class="p8"><span class="Apple-tab-span">	</span>[1, 1, 2, 1, 1, 2],</p>
<p class="p8"><span class="Apple-tab-span">	</span>1, 0.5</p>
<p class="p8">].asNotes, (type: <span class="s4">\ch</span>, mode: <span class="s4">\cmaj</span>)) =&gt; <span class="s2">MBM</span>(0);</p>
<p class="p2"><br></p>
<p class="p3">As explained below, these notes may be adjusted if desired to produce a better fit over the current root note and below a top note. So, you might want to think of them as "chord forms" rather than specific chords -- because they establish certain pitch or interval relationships that inform the final note choice.</p>
<p class="p2"><br></p>
<p class="p3">Chuck the chord data using the "ch" adverb or by setting type: \ch in the MIDI buffer properties.</p>
<p class="p2"><br></p>
<p class="p9">// .ch may be omitted because the buffer states type: \ch</p>
<p class="p8"><span class="s5">MBM</span>(0)[<span class="s6">\triads</span>] =&gt;.ch <span class="s5">BP</span>(<span class="s6">\chords</span>);</p>
<p class="p2"><br></p>
<p class="p3"><b>Initialization: required parameters of chord changes</b></p>
<p class="p2"><br></p>
<p class="p3"><i>These parameters are not optional!</i> Each parameter is identified here by the name you will actually use in code.</p>
<p class="p2"><br></p>
<p class="p3"><b>macro:</b> A pattern returning either a simple number indicating how many beats should elapse before the next chord, or a two element array. If an array, the first element is the number of beats until the next chord, and the second element is the number of beats that the chord pattern should play. (One chord may stop before the next begins, or even overlap.)</p>
<p class="p3"><b>arpeg:</b> A pattern returning the symbolic names of ArpegPat objects, which stream the notes out in arpeggiation order.</p>
<p class="p3"><b>micro:</b> A pattern returning the symbolic names of MicRh objects, which provide the note-level rhythm (microrhythm).</p>
<p class="p2"><br></p>
<p class="p3">The microrhythm is always chosen after the arpeggiation pattern, so you can intelligently choose a microrhythm that fits the arpeggiation pattern, supporting variety while allowing you to avoid inappropriate choices.</p>
<p class="p2"><br></p>
<p class="p5">// whole-bar chord changes</p>
<p class="p8"><span class="s2">Pwhite</span>(1, 4, <span class="s2">inf</span>) * 4.0 =&gt;.macro <span class="s2">BP</span>(<span class="s4">\chords</span>);</p>
<p class="p10"><br></p>
<p class="p5">// chords may be block chords or upward arpeggiations with no repetitions</p>
<p class="p8"><span class="s2">Prand</span>([<span class="s4">\block</span>, <span class="s4">\up1</span>], <span class="s2">inf</span>) =&gt;.arpeg <span class="s2">BP</span>(<span class="s4">\chords</span>);</p>
<p class="p10"><br></p>
<p class="p5">// block chords need a different microrhythm than note-streamers</p>
<p class="p5">// so we check which arpegType has already been put into the result event</p>
<p class="p8"><span class="s2">Pfunc</span>({ <span class="s2">|inEvent|</span> (inEvent[<span class="s4">\arpegType</span>] == <span class="s4">\block</span>).if({ <span class="s4">\blockFollow</span> },</p>
<p class="p8"><span class="Apple-tab-span">	</span>{ [<span class="s4">'16th'</span>, <span class="s4">'sine'</span>].choose })</p>
<p class="p8">}) =&gt;.micro <span class="s2">BP</span>(<span class="s4">\chords</span>);</p>
<p class="p2"><br></p>
<p class="p3">Since arpeg and micro selection patterns may be complex, you can define them as Pdefn's in your setup code, then reference the pattern by name during performance, e.g.,</p>
<p class="p2"><br></p>
<p class="p5">// in setup code</p>
<p class="p6"><span class="s2">Pdefn</span><span class="s3">(</span>\micRhBlockCheck<span class="s3">, </span><span class="s2">Pfunc</span><span class="s3">({ </span><span class="s2">|inEvent|</span><span class="s3"> (inEvent[</span>\arpegType<span class="s3">] == </span>\block<span class="s3">).if({ </span>\blockFollow<span class="s3"> },</span></p>
<p class="p8"><span class="Apple-tab-span">	</span>{ [<span class="s4">'16th'</span>, <span class="s4">'sine'</span>].choose })</p>
<p class="p8">}));</p>
<p class="p10"><br></p>
<p class="p5">// in performance -- this actually chucks in the Pfunc</p>
<p class="p6">\micRhBlockCheck<span class="s3"> =&gt;.micro </span><span class="s2">BP</span><span class="s3">(</span>\chords<span class="s3">);</span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>FitFunc: adapting chord notes to harmonic context</b></p>
<p class="p2"><br></p>
<p class="p3">A chord process can be sensitive to the harmonic context established by other processes. To do this, it has to modify the source notes for maximal consonance over a root note (see <a href="aiBass.html"><span class="s1">aiBass</span></a> for one way to set the root). Func objects define the algorithms that perform this adaptation. Specify which Func to use in the child's fitFunc variable. Its value may be a symbol, or a function that returns a symbol.</p>
<p class="p2"><br></p>
<p class="p5">// Fit the notes by rearranging the intervals between the input notes</p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).child.fitFunc = <span class="s4">\chordFitInt</span>;</p>
<p class="p2"><br></p>
<p class="p3">The following Funcs are available out of the box:</p>
<p class="p2"><br></p>
<p class="p3"><b>\asis:</b> No adjustment -- use the input notes as they are.</p>
<p class="p3"><b>\chordFitInt:</b> Check all possible arrangements of the intervals between input notes, and return the best fit.</p>
<p class="p3"><b>\chordFitNotes:</b> Check all transpositions of the input notes against the top note (see next section), and return the best fit.</p>
<p class="p3"><b>\chordRandInt:</b> Rearrange the intervals randomly; do not check for consonance.</p>
<p class="p3"><b>\fitToBass:</b> Transpose the notes so that the lowest chord note matches the root. No consonance check.</p>
<p class="p3"><b>\fitToTop:</b> Transpose the notes so that the highest chord note matches the top note. No consonance check.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Fitting to bass</b></p>
<p class="p2"><br></p>
<p class="p3">A chord process needs to know the bass ID in the global library (see <a href="aiBass.html"><span class="s1">aiBass</span></a>).</p>
<p class="p2"><br></p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).bassID = <span class="s4">\roots</span>;</p>
<p class="p2"><br></p>
<p class="p3">You can also control how the chord process should respond if the root note changes in the middle of an arpeggiation. If <b>~bassUpdate</b> is true, the chord notes will be reevaluated against every new bass note. If false, the same notes will be kept until the next chord event, even if they are not the optimal fit for the new bass note.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Top note melody: continuity</b></p>
<p class="p2"><br></p>
<p class="p3">A chord process may hold a melodic process. If present, one melody note is extracted from it per chord, where might be used by the chord fit Func.</p>
<p class="p2"><br></p>
<p class="p3">The simplest way to create the top note melody is to chuck a MIDI buffer containing melody data into the chord process:</p>
<p class="p2"><br></p>
<p class="p8">aMIDIRecBuf =&gt;.mel <span class="s2">BP</span>(<span class="s4">\chords</span>);</p>
<p class="p8">adaptationNoteMIDIRecBuf =&gt;.adapt <span class="s2">BP</span>(<span class="s4">\chords</span>);</p>
<p class="p2"><br></p>
<p class="p3">From there, you can set all the properties of the <a href="aiMel.html"><span class="s1">aiMel</span></a> process by referring to BP(\chords).topNote.</p>
<p class="p2"><br></p>
<p class="p8"><span class="s4">\absSplice</span> =&gt;.adapt <span class="s2">BP</span>(<span class="s4">\chords</span>).topNote;</p>
<p class="p6"><span class="s2">BP</span><span class="s3">(</span>\chords<span class="s3">).topNote.eugTest = </span>\eugRangeOnlyTest<span class="s3">;</span></p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).topNote.range = <span class="s2">NumericRange</span>(28, 45);</p>
<p class="p2"><br></p>
<p class="p3">If you want to generate the top notes algorithmically, you can manually assign an instance of PR(\patternTop).</p>
<p class="p2"><br></p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).topNote = <span class="s2">PR</span>(<span class="s4">\patternTop</span>).copy.make({</p>
<p class="p5"><span class="s3"><span class="Apple-tab-span">	</span>~deg = </span>/* pattern returning modally-mapped note numbers */<span class="s3">;</span></p>
<p class="p5"><span class="s3"><span class="Apple-tab-span">	</span>~mode = </span>/* symbolic name of Mode() object to use */</p>
<p class="p8">});</p>
<p class="p2"><br></p>
<p class="p3">In PR(\patternTop), you can also specify patterns for ~delta and ~length, but they are ignored by PR(\macroRh). They are meant for use with PR(\chTop) -- see the <a href="chTop.html"><span class="s1">chTop</span></a> help file.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>ArpegPat and MicRh</b></p>
<p class="p2"><br></p>
<p class="p3">The ArpegPat and MicRh storage objects hold functions, which take arguments from the chord process and output patterns with specific return values. See examples in Prototypes/startup20-basicChordBits.txt. Both types of function receive the entire parent event, and may use the data in it to influence the end result.</p>
<p class="p2"><br></p>
<p class="p5">// ArpegPat pattern should yield the note objects in the 'notes' array</p>
<p class="p7"><span class="s3">{ </span>|notes, parentEvent|<span class="s3"> </span>Pxrand<span class="s3">(notes, </span>inf<span class="s3">) } =&gt; </span>ArpegPat<span class="s3">(</span><span class="s4">\myArpeg</span><span class="s3">);</span></p>
<p class="p10"><br></p>
<p class="p5">// MicRh pattern should yield three-element arrays:</p>
<p class="p5">// [delta, sustain (in beats), gate value (velocity)]</p>
<p class="p5">// arpegPatResult is the note-stream pattern</p>
<p class="p5">// call estimateLength to make a rough guess how many events it will return</p>
<p class="p7"><span class="s3">{ </span>|arpegPatResult, parentEvent|</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s2">Prand</span>(#[0.25, 0.5, 0.75], <span class="s2">inf</span>).collect({ <span class="s2">|delta|</span></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>[delta, delta * rrand(0.8, 1.2), rrand(0.2, 0.8)]</p>
<p class="p8"><span class="Apple-tab-span">	</span>})</p>
<p class="p6"><span class="s3">} =&gt; </span><span class="s2">MicRh</span><span class="s3">(</span>\multiple16th<span class="s3">);</span></p>
<p class="p10"><br></p>
<p class="p5">// example output</p>
<p class="p8">p = <span class="s2">ArpegPat</span>(<span class="s4">\myArpeg</span>).asPattern([60, 64, 67]).asStream;</p>
<p class="p8">p.nextN(10);</p>
<p class="p10"><br></p>
<p class="p8">p = <span class="s2">MicRh</span>(<span class="s4">\multiple16th</span>).asPattern.asStream;</p>
<p class="p5"><span class="s3">p.nextN(10).do(</span><span class="s2">_</span><span class="s3">.postln)<span class="Apple-tab-span">	</span></span>// each row is delta, note-sustain, gate</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Mode handling</b></p>
<p class="p2"><br></p>
<p class="p3">Normally, all of the chord forms will be based on the same Mode (or ModalSpec), and the root and top note processes use that mode also. That's the simplest case.</p>
<p class="p2"><br></p>
<p class="p3">For better handling of chromaticism, you might want each chord to use a different mode. The quickest way to do this is with a composite mode (see the <a href="Mode.html"><span class="s1">Mode</span></a> help file). For each chord, the best mode in the composite set will be chosen.</p>
<p class="p2"><br></p>
<p class="p3">You should also set the useOwnMode property to true; otherwise, the mode assigned to the chord process as a whole will take effect.</p>
<p class="p2"><br></p>
<p class="p5">// (You have to define the cmaj, gmaj and emaj modes before doing this.)</p>
<p class="p6"><span class="s3">[</span>\cmaj<span class="s3">, </span>\gmaj<span class="s3">, </span>\emaj<span class="s3">] =&gt; </span><span class="s2">Mode</span><span class="s3">(</span>\composite<span class="s3">);</span></p>
<p class="p8">aMIDIRecBuf.chuck(<span class="s2">BP</span>(<span class="s4">\chords</span>), <span class="s4">\ch</span>, parms: (mode: <span class="s4">\composite</span>, useOwnMode: <span class="s2">true</span>));</p>
<p class="p2"><br></p>
<p class="p3">You can also manually override the mode for a particular chord object:</p>
<p class="p2"><br></p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).child.chords[0].modeOverride = <span class="s4">\abmaj</span>;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Arbitrary synth parameters</b></p>
<p class="p2"><br></p>
<p class="p3">You can assign a list of arbitrary parameters to the ~argPairs variable in the child. Those parameters will be passed on to each note.</p>
<p class="p2"><br></p>
<p class="p5">// Pan each note individually.</p>
<p class="p8"><span class="s2">BP</span>(<span class="s4">\chords</span>).child.argPairs = [pan: <span class="s2">Pwhite</span>(-1.0, 1.0, <span class="s2">inf</span>)];</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>One-step initialization</b></p>
<p class="p2"><br></p>
<p class="p3">A couple of Func objects are provided to set the most important parameters in one step. The difference is that newCh frees the target BP before creating the new one -- very useful in development because you always start from a clean slate.</p>
<p class="p2"><br></p>
<p class="p3">The arguments are the same for both functions, and they both return the resulting BP.</p>
<p class="p2"><br></p>
<p class="p8"><span class="s2">Func</span>(<span class="s4">\makeCh</span>).value(newBPname, childName, parentName, chordMIDIBuf, topMelodyMIDIBuf, macrorhythm, microrhythmSelector, arpegPatSelector, adaptKeysForTopMelody, mode, parms);</p>
<p class="p10"><br></p>
<p class="p8"><span class="s2">Func</span>(<span class="s4">\newCh</span>).value(newBPname, childName, parentName, chordMIDIBuf, topMelodyMIDIBuf, macrorhythm, microrhythmSelector, arpegPatSelector, adaptKeysForTopMelody, mode, parms);</p>
<p class="p2"><br></p>
<p class="p3"><b>newBPname:</b> A symbol, naming the result BP.</p>
<p class="p3"><b>childName:</b> The name (symbol) of the child PR; usually \arpeg1.</p>
<p class="p3"><b>parentName:</b> The name of the parent PR, e.g. \macroRh or \chTop.</p>
<p class="p3"><b>chordMIDIBuf:</b> The MIDIRecBuf containing chord data.</p>
<p class="p3"><b>topMelodyMIDIBuf:</b> The MIDIRecBuf containing melody data for the top note process.</p>
<p class="p3"><b>macrorhythm:</b> A pattern that produces macrorhythm values (delta, length).</p>
<p class="p3"><b>microrhythmSelector:</b> A pattern returning symbolic names to choose the microrhythm (MicRh) per chord.</p>
<p class="p3"><b>arpegPatSelector:</b> A pattern returning symbolic names to choose the arpeggiation pattern (ArpegPat) per chord.</p>
<p class="p3"><b>adaptKeysForTopMelody:</b> A pattern returning the names of Funcs to generate new top note melody variations.</p>
<p class="p3"><b>mode:</b> The overall mode for this process. Can be the symbolic name of a Mode object.</p>
<p class="p3"><b>parms:</b> Any additional parameters, especially those associated with MIDI data.</p>
<p class="p2"><br></p>
<p class="p3">It is usually not possible to set up a chord process completely using this method, but it gets you fairly close and reduces the number of individual statements you have to make.</p>
</body>
</html>
