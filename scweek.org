# Planning for SC week-long workshop

* Technical
** TODO Distributing extensions [0/4]
   - [ ] JIT extensions
   - [ ] ddwlib
   - [ ] crucial
   - [ ] Write slides about this
** Patterns + ProxySpace
*** Notes for documentation
**** NodeProxy play/stop semantics
     - If the NP exists, its source is processing, always.
     - 'play' only allows it to be heard.
     - 'stop' only suppresses the output.
     - A \psSet pattern source behaves the same:
       - It always produces events with its normal timing.
       - 'stop' turns all the events into rests.
*** Syntax to address nodeproxy controls
    - 'key.argname'?
    - I think maybe even better to share control names across proxies
      Dictionary: argname -> Set of NodeProxies with that argname
*** TODO Move psSet support into a proper file
*** TODO Support multiple NP objects in psSet
*** TODO Move ProxySpace:setEvent into a proper file
** Numbers in ProxySpace: DC or control?
*** DONE Changing number doesn't update proxy's source
*** INPROG Switching back to numberproxy uses old value in set of args
** Org/LaTeX
*** TODO Reference to frame ID "undefined"
*** POSTPONED Filter to remove non-frame text
*** TODO Listings numbering problem with onlyenv
*** DONE Extract code examples
#+begin_src emacs-lisp :exports none
(defun hjh-get-string-from-nested-thing (thing)
  "Peel off 'car's from a nested list until the car is a string."
  (while (and thing (not (stringp thing)))
    (setq thing (car thing)))
  thing
)

(defun hjh-src-blocks-to-string (counter)
  "Iterate src blocks from org-element and add them to a string."
  (interactive "nStarting listing number: ")
  (when (not counter) (setq counter 1))
  (let ((tree (org-element-parse-buffer))
	(string ""))
    (org-element-map tree 'src-block
      (lambda (element)
	(setq element (car (cdr element)))
	(let ((caption (hjh-get-string-from-nested-thing (plist-get element :caption)))
	      (source (hjh-get-string-from-nested-thing (plist-get element :value))))
	  (when caption
	    (setq string (concat string (format "/**************
 Listing %d. %s
 **************/

%s\n\n"
					  counter
					  (substring-no-properties caption)
					  (substring-no-properties source))))
	    (setq counter (1+ counter))))))
    string))

(defun hjh-src-blocks-to-buffer (counter)
  "Put all the captioned source blocks from a buffer into another buffer."
  (interactive "nStarting listing number: ")
  (let* ((contents (hjh-src-blocks-to-string counter))
	 (bufpath (buffer-file-name))
	 (newname (concat (file-name-sans-extension bufpath) ".scd"))
	 (bufname (file-name-nondirectory newname))
	 (newbuf (get-buffer-create bufname)))
    (with-current-buffer newbuf
      (erase-buffer)
      (insert contents)
      (set-visited-file-name newname))
    (switch-to-buffer-other-window newbuf)))
#+end_src

#+RESULTS:
: hjh-src-blocks-to-buffer

*** DONE Index entries
*** DONE Glossary
*** DONE Why do subsections become frames in beamerarticle?
*** TODO Detecting beamer vs. article document class
Actually, I was wrong. `:latex-class' will contain the name given by the
user to its Beamer configuration. It may be totally unrelated to
"beamer".

You need to use a regexp to find out what class is used:

  (let ((beamer-class-p
         (and (stringp header)
              (org-string-match-p
               "^[ \t]*\\\\documentclass\\(?:\\[.*\\]\\)?{beamer}[ \t]*$"
               (nth 1 (assoc (plist-get info :latex-class) org-latex-classes)))))))

> +       (if (string= (plist-get info :latex-class) "beamer")
> +        (format "\\begin{frame}%s\\end{frame}" titlecmd)
> +      titlecmd))

You need to check if TITLECMD is nil before wrapping it within a frame.
Ideally before defining BEAMER-CLASS-P.

* Content
** TODO Exercises
***
* High-level outline
** *Notes* (not a topic)
   - Sequencing... where?
   - Give some exercises (time when I don't have to talk so much!)
** History
   - Music n
   - Common LISP music
   - SuperCollider
** SC architecture, environment
   - 3 apps
   - Navigating the IDE
     - Docklets
     - Server control
     - Code window
       - Auto-indent
       - Auto-completion
       - Code blocks in ()
** Beginning synthesis
   - Writing UGens into functions
     - Look under the hood
   - UGen: in --> black box --> out
     - Input and output rates
     - Input and output ranges
     - Predicting results of operations
       - Amplitude modulation, e.g.
   - ProxySpace
     - What's a proxy?
     - /Expose/ inputs -- if exposed, you can manipulate them
     - Amp envelope
       - Set source to trigger
       - Trigger inputs
     - Freq envelope, sharing trigger
     - Can model any synthesis technique
       Components: Oscillators, filters, modulators, envelopes
** Additive synthesis?
** Subtractive synthesis
   - Simplest
     - Oscillator rich in harmonics
	 - Typical waveforms
     - Filter(s)
	 - Typical filter types
	 - Resonance
   - Refine
     - Detuned oscillators
     - Modulation of filter parameters
	 - Envelope for attack; separate triggers for legato
     - LFO modulators
   - Note on efficiency?
** Modal synthesis
   - High resonance, short input sound: ringing
   - Filter's /impulse response/
   - Klank, DynKlank
     Also note /parallel/ vs /serial/ processing
   - Parameters:
     - Ringing frequencies (harmonic or inharmonic relationships)
     - Ring times (inverse correlation with bandwidth)
     - Amplitudes of each filter
     - Input spectrum and envelope
   - Related
     - Formant synthesis (Formlet)
     - Banded waveguides (feedback delays)
* Glossary decisions [0/14]
  - [ ] range
  - [ ] Nyquist
  - [ ] interpolation [0/3]
    - [ ] linear
    - [ ] cubic
    - [ ] quadratic
  - [ ] absdif
  - [ ] trunc
  - [ ] roundUp
  - [ ] abs
  - [ ] sign
  - [ ] squared
  - [ ] sqrt
  - [ ] exp
  - [ ] log
  - [ ] sin
  - [ ] cos
* Overview (MD export)
  :PROPERTIES:
  :EXPORT_TITLE: Synthesis and Performance with SuperCollider
  :EXPORT_AUTHOR: H. James Harkins
  :EXPORT_FILE_NAME: scweek_overview.md
  :EXPORT_OPTIONS: toc:nil ^:nil ':nil
  :END:

** About the course
This intensive five-day workshop teaches you the fundamentals of sound
synthesis in the SuperCollider programming language, with an emphasis
on modular design, real-time patching and control devices for live
performance.

** About the instructor
H. James Harkins (Ph.D., Duke University) has 11 years experience
composing and performing with SuperCollider, and actively contributes
code and documentation to the SuperCollider project. He is the
developer of dewdrop_lib, an extension library including components
for mixing, MIDI control and high-level organization for larger
projects. He is currently an Associate Professor in the Modern Music
Department of Xinghai Conservatory of Music in Guangzhou, PRC,
teaching electronic music production and film music.

** What is SuperCollider?
SuperCollider is a programming language for audio synthesis and
algorithmic composition, designed by James McCartney. The current
incarnation, SuperCollider Server, is the third major version and was
released as an open-source project in 2002. It is currently maintained
by an international group of musicians and programmers. It is an
object-oriented language based loosely on SmallTalk, providing Unit
Generator objects for synthesis, powerful data structures, and Pattern
objects for sequences of musical information.

** What will be taught?
The workshop will culminate with a performance of a group
composition. Each student will be responsible for one or two textural
layers, to be controlled using mobile devices. The primary focus of
each session is practical information to complete the musical work.

Early sessions will build synthesizers from simple pieces of code,
where each code snippet represents typical synthesizer components
(oscillators, envelope generators, control signals). We will approach
basic synthesis techniques by experimentation. We will learn to
control these synthesizers using sequencing (patterns) and external
devices. The discussion of external devices will cover simple
graphical interfaces, and good programming habits to manage incoming
control information. Concluding sessions will touch on best practices
to build larger projects.

Sessions will be taught in both English and Chinese.

** Are there any prerequisites?
This workshop assumes no prior knowledge of SuperCollider. Familiarity
with electronic music technology will be helpful, but not required.

** What do I need to bring?
*** Laptop
Participants will need to bring their own laptop (Mac OSX, Linux or
Windows 7/8), and a headset for listening.

*** SuperCollider installation
Please install SuperCollider before attending the workshop:
http://supercollider.sourceforge.net/downloads/.

   - Mac: Please use SC 3.6.6. OSX 10.6 or higher is recommended.
   - Windows: Please use SC 3.6.6.
   - Linux: Pre-compiled packages for SC 3.6.3 exist for Debian/Ubuntu
     and Red Hat. Hoping for this to be updated before the workshop.

*** External control (smartphone/tablet, MIDI)
A mobile device with an OSC control app is recommended for the
performance sessions.

   - Android: /TouchOSC/ https://play.google.com/store/apps/details?id=net.hexler.touchosc&hl=en
   - iOS
     - *$4.99* - /TouchOSC/ https://itunes.apple.com/us/app/touchosc/id288120394?mt=8
     - Free - /mrmr/ https://itunes.apple.com/us/app/mrmr-osc-controller/id294296343

If you don't have a smartphone or tablet, a simple MIDI controller
such as a NanoKontrol would suffice.

** Day-by-Day Schedule:

10:00 - 12:00 Morning Session
12:00 - 13:00 Lunch
13:00 - 16:00 Afternoon Session (with 15 minute break)
16:30 - 18:00 Private Lesson

