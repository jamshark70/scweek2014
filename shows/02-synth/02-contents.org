#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Events and Sequencing						   :noexport:
** Events and synthesis control
*** What are Events?
**** \clsspl{Event} represent a pre-defined action.
     Two main features:
     - Storage :: Events hold information under names that you choose.
     - Play-ability :: \mth{play} an \clss{Event} to fire the action.
**** They make the musical /information/ more important.
     - Yesterday's \clsspl{Task} combined /data/ and /action/ into one
       code block.\\
       If the \clss{Task} is written to play notes by \ci{set}-ting
       controls, /it can do nothing else/ without rewriting.  Only one
       way to play notes: \cd{something.set(...)}.
     - With \clsspl{Event}, you can use the same event data for different things.
#        - \Gls{event type} \ci{\textbackslash note} plays it in SC's audio server.
#        - \ci{\textbackslash midi} sends MIDI to hardware or other software.
#        - Two actions, same sequencing code.

*** Playing events
**** An "empty" event can \mth{play}.
#+name: event1
#+caption: The simplest possible event.
#+begin_src {} -i
().play;
#+end_src

**** But look what it prints out:
# Note, this must be a block, to clear the previous name/caption

#+begin_src {} -i
( 'instrument': default, 'msgFunc': a Function, 'amp': 0.1,
  'sustain': 0.8, 'server': localhost, 'isPlaying': true,
  'freq': 261.6255653006, 'hasGate': true, 'id': [ 1000 ] )
#+end_src

**** Where did all that come from?

*** The default event
**** Playing the \clss{Event} uses a large set of \eglspl{default}.
     - \Gls{event type} :: \ci{\textbackslash note}
     - SynthDef :: \ci{\textbackslash instrument} = \ci{\textbackslash default}.\\<all>
		   The default \clss{SynthDef} is defined for you.
     - Pitch :: \ci{\textbackslash freq} = 440 Hz (calculated from other defaults).
     - Length :: \ci{\textbackslash sustain} = 0.8 seconds (calculated).
     - Volume :: \ci{\textbackslash amp} = 0.1 (calculated from -20 dB).
     - Pan :: \ci{\textbackslash pan} = 0 (center).
#+name: eventDefaults
#+caption: Print a list of events of default values.
#+begin_src {} -i
Event.default.parent.postSorted; ""
#+end_src
A little trick: Add an empty string after printing a collection, for cleaner output.

*** Writing your own events
**** \clsspl{Event} are written as /key/value/ pairs.
     - This comes from the parent class, \clss{Dictionary}.
     - \clss{Event} has a short syntax: \cd{(key: value, ...)}.
       - (Written differently in \clss{Dictionary}.)
#+name: event2
#+caption: Put your own values into events, and play them.
#+begin_src {} -i
(freq: 330, amp: 0.5, sustain: 2, pan: 0.5).play;
#+end_src

*** Automatic calculations in events: Time
**** Time information lives at two levels:
     - Basic level
       - \mth{delta} :: Same as wait-time in a \clss{Task}.
       - \ci{sustain} :: How long to hold an envelope's \gls{gate} open.
     - Higher level
       - \ci{dur} :: Wait time. \ci{dur = delta * stretch}.
       - \ci{legato} :: Proportion of dur to hold the gate open. < 1 leaves space between notes (staccato); > 1 makes notes overlap.
       - \ci{stretch} :: Multiplies all time values. Can make a sequence play faster or slower.
#+name: event2
#+caption: Sustain is calculated automatically from "dur" and "legato."
#+begin_src {} -i
(freq: 330, amp: 0.5, dur: 3, legato: 0.5).play;
#+end_src

*** Automatic calculations in events: Pitch
**** Pitch information lives at /several/ levels:
#      The most important are:
     - \ci{freq} :: Note frequency, in Hz.
     - \ci{midinote} :: MIDI note number. 60 = middle C, about 261 Hz.
     - \ci{degree} :: A diatonic scale degree. Depends on:
       - \ci{scale}: The whole/half-step pattern for the scale. See the \clss{Scale} class.
       - \ci{root}: The \egls{pitch class} of the tonic note. 0 = C.
       - \ci{octave}: An octave number. 5 is the octave from middle C to the B above.
#+name: event3
#+caption: Different ways of writing pitch.
#+begin_src {} -i
(freq: [220, 275, 330]).play;
(midinote: [57, 61, 64], sustain: 1.5).play;
(degree: [0, 2, 4], root: 9, octave: 4, sustain: 1.5).play;

(degree: [0, 2, 4], root: 9, octave: 4,
   scale: Scale.minor, sustain: 1.5).play;
#+end_src

*** Details on Event parameters and calculations
    See the following help files for documentation on \clss{Event} parameters.
    - /Pattern Guide 07: Value Conversions/\\<all>
      [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_07_Value_Conversions.html][Web link]]
    - /Pattern Guide 08: Event Types and Parameters/\\<all>
      [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters.html][Web link]]

*** What are the example events actually doing?
**** The default \ci{\textbackslash note} \gls{event type} plays and releases a synth.
     1. Calculate time and pitch values.
     2. Send messages to the server to create new synth nodes.
     3. /If/ the \clss{SynthDef} has a \mth{gate} argument, schedule
        release messages to be sent \ci{\textasciitilde sustain} beats
        later.
**** This event type is designed for "canonical" style.
     - We are using \clss{ProxySpace} in a specific way, for modular synthesis.
     - So we need another way.

*** Event types
**** Common \glspl{event type}:
     - \ci{\textbackslash note} :: Play a new \clss{Synth}.
     - \ci{\textbackslash set} :: Set controls in an existing \clss{Synth}.
     - \ci{\textbackslash off} :: Release an existing \clss{Synth}.
     - \ci{\textbackslash midi} :: Send note or control data to a hardware MIDI device.
**** Event types let you change the action without changing the data.
     - You can write a \ci{\textbackslash note} pattern, and hear the notes in scsynth.
     - Or, change to the \ci{\textbackslash midi} type and hear the notes from a hardware synth.

*** ProxySpace "setEvent" method
    - Calling \mth{setEvent} on a \clss{ProxySpace} prepares an \clss{Event} to set controls within that ProxySpace.
    - Provide an event as an argument, with the values you want to set.
    - \ci{gt} arguments will be closed automatically after \ci{sustain} beats.
#+name: gateEvent
#+caption: Hold a gate open for a given amount of time using an Event.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~out = { |freq = 440, width = 0.5, gt|
   var eg = EnvGen.kr(Env.adsr, gt);
   (VarSaw.ar(freq, 0, width) * eg * 0.1).dup
};
~out.play;

p.setEvent((freq: exprand(200, 400), sustain: 0.5)).play;
p.setEvent((freq: exprand(200, 400), sustain: 3)).play;
#+end_src

*** Event summary
**** With \clsspl{Event}, we can:
     - Write musical information without worrying about server details.
     - Write pitches three ways:
       - Frequency (Hz);
       - MIDI note numbers (chromatic);
       - Scale degrees (diatonic---major, minor etc.).
     - Control gated envelopes with one command.
**** What do we need for sequencing?
     - An easy way to fill events from streams.
     - Rhythm control directly from the events.

** Patterns and Events
*** Patterns make Events very easily
**** An \clss{Event} is a set of named values.
     - Each value's name says how the value will be used for synthesis.
**** A pattern called \clss{Pbind} is a list of /named patterns/.
     - Every \mth{next} value collects one value from each child pattern.
     - \mth{next} needs an empty \clss{Event} as a container for the new values.
#+name: pbind1
#+caption: Pbind collects child patterns' return values under given names.
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;

p.next(Event.new);
#+end_src

*** What does Pbind actually do?
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;
#+end_src
    1. Associate names with patterns:
       - \ci{\textbackslash freq} will be random between 100 and 400.
       - \ci{\textbackslash dur} will be a random multiple of 0.125.
    2. Automatically make streams from those patterns.
    3. Go through the pairs /in order/:
       - Get a value from that name's stream.
       - Add the value into the input \clss{Event}.

*** DebugPbind: Watch the event get filled
**** In Listing [[pbind1]], change \clss{Pbind} to \clss{DebugPbind}.
     Now you can read exactly what's going on.
     1. Start with an empty event.
     2. \ci{\textbackslash freq} gets the random value, e.g. 133.25.
     3. The empty event becomes \cd{(freq: 133.25)}.
     4. \ci{\textbackslash dur} gets 0.125.
     5. The final event has both values, with the right names.
#+begin_src {} -i
Source event: (  )
stream ID: freq
Event going in: (  )
streamout: 133.24577125341
stream ID: dur
Event going in: ( 'freq': 133.24577125341 )
streamout: 0.125
Result event: ( 'dur': 0.125, 'freq': 133.24577125341 )
#+end_src

*** Events and timing
**** In a \clss{Routine}/\clss{Task}, we \mth{wait} until the next event.
     This happens automatically in an Event Pattern.
     - Events can calculate a \gls{delta} time.
     - Then, we just need something that will play the event and wait
       the right amount of time.
**** This is \clss{EventStreamPlayer}.
     - If you call \mth{play} on a pattern, it makes an \clss{EventStreamPlayer}.
     - Each event has a \egls{delta} time, given directly or
       calculated from \cd{dur}.
       - \cd{delta = dur * stretch}
     - Each event is \mth{play}ed. Then the \clss{EventStreamPlayer}
       waits, for the event's \egls{delta} time.

*** "Canonical" Pbind example
**** Using \clss{Pbind} to play default synths, the "canonical" way.
     Note what happens with \ci{legato}.
     - Some notes are short.
     - Other notes hold over, into the next note.
#+name: pbind2
#+caption: A "canonical" Pbind, playing notes in the default SynthDef.
#+begin_src {} -i
a = Pbind(
   \degree, Pwhite(-7, 7, inf),
   \dur, Pwhite(1, 4, inf) * 0.125,
   \legato, Prand([0.5, 2], inf)
).play;

a.stop;
#+end_src

*** Notes on previous example				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
This has a somewhat complex flow, wrapped up in a simple expression. It divides into these parts:

- *\clss{EventStreamPlayer} control of rhythm and event-playing.*\\<all>
  In a loop:
  1. Get an \clss{Event} from the \clss{Pbind}'s stream.
  2. Play the event.
  3. Ask the event for its \mth{delta} time, and \mth{wait} for that duration.

- *\clss{Pbind} evaluation of events.*\\<all>
  Every time the \clss{EventStreamPlayer} asks for an event, loop through the key/pattern pairs:
  1. Get a value from the child pattern's stream.
  2. Put the value into the event, using the pattern's key.
  At the end of this, the event will have a value for every key.

- *The event's action, triggered by \mth{play}.*\\<all>
  Takes action, according to the \egls{event type}.

*** Patterns: "Declarative" programming
**** \eGlspl{Routine} and \glspl{Task} are \egls{imperative}-style programming.
     - They say: "Do this, then that."
       - Set the trigger and the frequency.
       - Wait 0.5 beats.
**** \eGlspl{pattern} are more like \egls{declarative} programming.
     - Listing [[pbind2]] says:
       - I want \ci{\textbackslash degree} to be like this.
       - I want \ci{\textbackslash dur} to be like that.
       - Go do it.
# **** The two examples /do/ the same thing, but write it differently.

*** Pbind in ProxySpace
**** We need something like \cd{p.setEvent} for patterns.
     Some \clss{ProxySpace} tricks:
     - You can use a \clss{Pbind} in \clss{ProxySpace}, just like a synthesis function.
     - The pattern's synths will belong to the resulting \clss{NodeProxy}.
     - You can change the way the \clss{NodeProxy} behaves with a modifier:\\
       \cd{\textasciitilde name = \textbackslash modifier -> thing;}, where \cd{thing} is the function or pattern.
     - The \cd{\textbackslash psSet} modifier makes every event from
       the pattern act like \cd{p.setEvent}.

*** \textbackslash psSet pattern example
# **** Main point: This is easy.
#      - There are a lot of concepts behind this example.
#      - But using it---playing notes automatically---is convenient.
#+name: rVsPbind
#+caption: A Pbind, controlling NodeProxies in a ProxySpace.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pexprand(110, 440, inf),
   \dur, 0.5
);

~player.clear;
#+end_src
**** *Note:* \ci{\textasciitilde player} is now a \clss{NodeProxy}.
     - Just like \ci{\textasciitilde out} in Listing [[gateEvent]].
     - You can change the synthesis function any time.
     - Likewise, you can change \ci{\textasciitilde player}'s pattern anytime!\\
       Just assign a new pattern (with \ci{\textbackslash psSet}).

*** Pbind summary
**** \clss{Pbind} unifies everything you need for sequencing.
     - Note data come from value \glspl{pattern}.
     - The data go into an \clss{Event}.
     - The event turns the data into action.
     - The event also tells the \clss{EventStreamPlayer} how long to wait.
**** To control modular synthesis by Pbind, use the \cd{\textbackslash psSet} modifier.
     - Within a \clss{ProxySpace}:\\<all>
       \cd{\textasciitilde name = \textbackslash psSet -> Pbind(...);}.
**** Now we can run lots of notes while playing with synthesis techniques.

*** Exercises: Different pitch and rhythm patterns
**** Change the pattern from Listing [[rVsPbind]]:
     *Note:* You may use \clss{Pdefn}.
     1. Choose notes from the C major scale.
     2. Choose C major notes, but favor C, E and G.\\
	Hint: Use \clss{Pwrand}. Check its help file for details.
     3. Make it E major (change the \ci{\textbackslash root}).
     4. Try \clss{Pwhite} for rhythm (with fractional low/high).\\
	Then try \clss{Pexprand}. How would you describe the difference?
     5. With \ci{\textbackslash psSet}, what's the difference between
        \ci{\textbackslash legato} < 1 and > 1?

* Subtractive synthesis						   :noexport:
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens							   :noexport:
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** addSpec and argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an \egls{exponential} curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: \eGls{exponential}.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[../02-synth/img/three-waves2.png]]
   #+end_center
\\ *Note:* Band-limited triangle oscillators may be found in the
sc3-plugins package.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%).\\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     - Human players are never exactly in tune.
     - We can do the same in a synth.
#+name: detune
#+caption: Detuning: Make several oscillators and mix (add) them.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   0.1 * (
      Saw.ar(freq) + Saw.ar(freq * detun) + Saw.ar(freq / detun)
   ).dup
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Detuning, explained
#+begin_src {} -i
      Saw.ar(freq)
      + Saw.ar(freq * detun)
      + Saw.ar(freq / detun)
#+end_src
**** Detuning involves several oscillators, out of tune.
     We have three:
     - Original frequency;
     - /Up/ by a small interval (assuming \cd{detun > 1});
     - /Down/ by the same small interval.
**** Add the oscillators to make a combined signal.
     The almost-exact frequencies create changes in the spectrum.

*** An easier way
**** What if you want more oscillators?
     - Inconvenient to write \ci{+} for every one.
**** Solution: \ugen{Mix} with an array.
     - Write the oscillators into an array.
     - \ugen{Mix} will find the most efficient way to add them.
#+name: detune2
#+caption: Mix an array of oscillators, instead of explicitly adding them.
#+begin_src {} -i
~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix([
      Saw.ar(freq),
      Saw.ar(freq * detun),
      Saw.ar(freq / detun)
   ])).dup
};
#+end_src

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}.\\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** That's not easy enough
**** \eGls{multichannel expansion} can make it easier.
     - Most UGens are monophonic: one channel in, one out.
     - Here, we provide an array of three frequencies.
**** How can a monophonic UGen do that?
     - It performs \egls{multichannel expansion}, and makes three \ugen{Saw}s.
     - The \ugen{Saw}s are in an array, which we can give to \ugen{Mix}.
#+name: mc-exp1
#+caption: Multichannel expansion: An array of frequencies turns into an array of oscillators.
#+begin_src {} -i
Saw.ar([1, 2, 3]);  // prints: [ a Saw, a Saw, a Saw ]

~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix(
      Saw.ar([freq, freq * detun, freq / detun])
   )).dup
};
#+end_src

*** One further step
    - It isn't even necessary to write \ci{freq} every time.
    - You can multiply \ci{freq} by an array of factors.
    - Small problem: If the operator is \ci{*}, how to do \ci{/}?\\<all>
      Get the \mth{reciprocal} of \ci{detun}.
#+name: detune4
#+caption: Mix an array of oscillators, instead of explicitly adding them.
#+begin_src {} -i
~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix(
      Saw.ar(freq * [1, detun, detun.reciprocal])
   )).dup
};
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_src {} -i
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_src

*** Notes on MC expansion				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Multichannel expansion is super cool.
Parallel processing of multiple channels is very common. For example,
if you're playing a one-channel sound file, you would need
\ugen{PlayBuf} $\to$ amplifier \ci{*} $\to$ output. For a stereo file,
you need /two/ channels from \ugen{PlayBuf} and two amplifiers.

In Max/MSP, you would have to create each of the 
\cd{[*\textasciitilde ]} amplifiers by hand. Adding or removing a channel can force you to
make cascading changes through large sections of the patch.

In SuperCollider, the difference is merely:

- One channel: \cd{PlayBuf.ar(1, ...) * amp}.
- Two channels: \cd{PlayBuf.ar(2, ...) * amp}.

In the second case, \cd{PlayBuf.ar} gives you an array of two
signals. This automatically expands the \ci{*} operator: @@latex:\cd{[left,
right] * amp} = \cd{[left * amp, right * amp]}@@. You could even go up
to large multichannel diffusion systems, and amplify all the channels
at once in exactly the same way.

Even for ordinary synthesis: Because multichannel processing is more
convenient in SC, you'll do more of it and get more interesting sounds
for less work.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[../02-synth/img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}:\\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses \ci{rq} = $\frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.

*** Next step: Modulation
**** That's pretty much it for subtractive synthesis.
     - Multiple oscillators, slightly detuned and with different octave relationships.
     - Different types of filters.
**** The power comes from \egls{modulation}.
     - Modulation means that the parameters are not constant.
     - We'll talk about that next.

* Modulation: Low-Frequency Oscillators				   :noexport:
** Modulation: Low-Frequency Oscillators
*** Modulation
**** Little secret: Synthesis techniques are sometimes /really simple/.
     We just beef them up with /layering/ and \egls{modulation}.
**** Modulate a parameter by another signal.
     - We can use envelopes for this.
     - Another modulation source: \eglspl{LFO} (Low-Frequency Oscillators)
     - SC has a /lot/ of them.
**** For this section:
     - Introduce LFO shapes and mechanism
     - Talk about signal ranges

*** LFO + filter
**** Start with an earlier synth, slightly modified.
#+name: scifi1
#+caption: Basic detuned synth.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 120|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 2000, rq = 0.08|
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
~filter.play;

~filter.addSpec(\ffreq, \freq);
~filter.addSpec(\rq, [1, 0.02, \exp]);
p.gui;
#+end_src

*** Add an LFO: sci-fi heaven
**** Same pattern as before:
     - Add a new module (\ci{\textasciitilde filtlfo}). This is a slowly-changing signal.
     - Use it in the filter (@@latex:\cd{ffreq + \textasciitilde
       filtlfo}@@). Adding it to the basic filter frequency means that
       the actual filter cutoff goes slowly above and below the set
       frequency.
#+name: scifi2
#+caption: Add an LFO to the filter.
#+begin_src {} -i
~lfreq = 1; ~lfreq.addSpec(\value0, [0.5, 18, \exp]);
~depth = 100; ~depth.addSpec(\value0, [0, 1000]);
~filtlfo = { SinOsc.kr(~lfreq) * ~depth };

~filter = { |ffreq = 2000, rq = 0.08|
   ffreq = (ffreq + ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
#+end_src

*** LFO shape
**** Many common LFO shapes exist.
     This one is a simple sinewave (\clss{SinOsc}).\\
     Audio UGens may often be used for control signals.
**** Try some other shapes.
     What do they sound like?
#+latex: \glsadd{LFPulse}\glsadd{LFTri}\glsadd{LFSaw}
#+name: lfoshapes
#+caption: Play with some other common LFO shapes.
#+begin_src {} -i
~filtlfo = { LFPulse.kr(~lfreq) * ~depth };
~filtlfo = { LFTri.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth.neg };
~filtlfo = { LFNoise0.kr(~lfreq) * ~depth };
#+end_src
     - \ugen{LFNoise0} is like a standard synthesizer LFO called \egls{sample-and-hold}.

*** Uncommon LFO shapes
# **** SC goes further than the standard shapes.
    - Single-shot lines (\ugen{Line}, \ugen{XLine}).
    - Ramps (\ugen{LFNoise1}) and curves (\ugen{LFNoise2}) between random numbers.
    - Various functions from mathematics:
      - Gaussian (bell-curve) wave
      - Many, many \egls{chaotic} generators. 
#+latex: \glsadd{LFGauss}\glsadd{LinCongL}\glsadd{QuadL}
#+name: lfoshapes2
#+caption: LFO shapes not commonly found in other software.
#+begin_src {} -i
~filtlfo = { LFNoise1.kr(~lfreq) * ~depth };
~filtlfo = { LFNoise2.kr(~lfreq) * ~depth };
~filtlfo = { LFGauss.ar(~lfreq) * ~depth };

// chaotic
~filtlfo = { LinCongL.ar(~lfreq, 1.2, 0.08) * ~depth };
~filtlfo = { QuadL.ar(~lfreq) * ~depth };
#+end_src

** Range mapping for modulation
*** Modulation: All about signal ranges
**** Remember the key questions from before:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Modulation range for frequency
**** Frequency needs a wider range of variation.
     - Suppose the base frequency is 440.
     - If the modulator's range is $-1$ to $1$, the frequency will vary between 439 and 441.
     - That's $\frac{1}{440}=$ 0.23\%. The ear can't tell that it's changing!
**** You need to expand the range.
     That's the purpose of the \ci{\textasciitilde depth} module.

*** mul, add
**** Almost all UGens have \ci{mul} and \ci{add} arguments.
     - @@latex:\cd{SinOsc.ar(440, 0, 100, 440)} $\to$\\
       \cd{SinOsc.ar(440, 0) * 100 + 440}.@@
     - Converts the normal output range $-1$ to $1$ into 340 to 540.
     - If \ci{add} is 0, \ci{mul} acts like an amplifier.
**** In the previous LFO example:
#+attr_latex: :align |c|c|
|------------------------------------+----------------------|
| *Operation*                        | *Range*              |
|------------------------------------+----------------------|
| \ugen{SinOsc}                      | Bipolar: $-1$ to $1$ |
|------------------------------------+----------------------|
| \cd{* \textasciitilde depth} ($d$) | $-d$ to $d$          |
|------------------------------------+----------------------|
| \cd{+ ffreq} ($f$)                 | $f-d$ to $f+d$       |
|------------------------------------+----------------------|

*** Range mapping methods
**** All UGens have two methods to make it easier:
     - \cd{UGen.ar(...).range(low, high)}: \eGls{linear} mapping.
     - \cd{UGen.ar(...).exprange(low, high)}: \eGls{exponential} mapping.
#+latex: \glsadd{range}\glsadd{exprange}
**** Also, methods that are good for numbers as well as UGens:
Arguments: inMin, inMax, outMin, outMax, clip.
     - \mth{linlin} :: \eGls{linear} input, \egls{linear} output.
     - \mth{linexp} :: \eGls{linear} input, \egls{exponential} output.
     - \mth{explin} :: \eGls{exponential} input, \egls{linear} output.
     - \mth{lincurve} :: \eGls{linear} input, \te{curved} output. (Extra argument for the curve factor.)
     - \mth{curvelin} :: \te{Curved} input, \egls{linear} output.

*** What is "exponential"?
**** \eGls{exponential} means using multiplication in place of addition.
     - Every octave up means multiplying by 2.
     - Start at 55 Hz, octaves are 55, 110, 220, 440, 880.
     - \cd{0.5.linlin(0, 1, 55, 880)} is 467.5.\\
       Halfway between 55 and 880, but it isn't the /octave/.
     - \cd{0.5.linexp(0, 1, 55, 880)} is 220.
#+name: linExpPlot
#+caption: Plot a line covering four octaves of frequency, first linearly, second exponentially.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);  // out: 0.0-1.0
   [
      // in range: 0-1; out range: 55-880
      line.linlin(0, 1, 55, 880),
      line.linexp(0, 1, 55, 880)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** What is "curved"?
**** \te{Curved} mappings let you control the amount of curve.
     - If \ci{curve} is 0, you get a straight line.
     - A negative curve "pulls" the line to the left.
     - A positive curve pulls it to the right.
     - The larger the number, the more extreme the curve.
#+name: linCurvePlot
#+caption: Plot a line covering four octaves of frequency with different curve factors.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);
   [
      line.lincurve(0, 1, 55, 880, -6),
      line.lincurve(0, 1, 55, 880, -2),
      line.lincurve(0, 1, 55, 880, 4)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** Exponential modulation for frequency
**** Earlier, we used \ci{+} to modulate frequency.
     Using the \mth{cpsmidi} method, we can get MIDI note numbers, and
     see how many semitones between given frequencies.
     - Assuming the base frequency is 2000 and the depth is 1000:
#+latex: \glsadd{round}\glsadd{differentiate}
#+name: expscale
#+caption: Convert modulation ranges for frequency into intervals.
#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.round(0.01);
// prints: [ 83.21, 95.21, 102.23 ]

[1000, 2000, 3000].cpsmidi.differentiate.round(0.01);
// prints: [ 83.21, 12, 7.02 ]

[2000 / 1.5, 2000, 2000 * 1.5].cpsmidi.differentiate.round(0.01);
// prints: [ 88.19, 7.02, 7.02 ]
#+end_src

*** Note: Differentiate					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Listing [[expscale]] illustrates how we can use arrays to do the same
operation repeatedly. To get the interval (number of semitones)
between two frequencies, we subtract the higher frequency's MIDI note
number from the same for the lower frequency. Here, we have three
frequencies---let's call them $f_0$, $f_1$ and $f_2$---and we want the
results $f_1 - f_0$ and $f_2 - f_1$. That's what \mth{differentiate}
does: it makes a new array where each item is the difference between
two of the original items that are right next to each other.

It also copies the first item. This is so that you can reconstruct the
original array using \mth{integrate}. We aren't interested in the
first item, so we can ignore it. If you need to get rid of the first
item, use \mth{drop}:

#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.differentiate.drop(1).round(0.01);
// prints: [ 12, 7.02 ]
#+end_src

*** How to make the intervals match?
    - The linear way uses inverse math operators: $+$ and $-$.\\
      But $-$ by the same amount produces a larger interval than $+$.
    - The exponential way also uses inverses: $\times$ and $\div$.\\
      Multiplying and dividing by the same amount produces the same interval.
#+attr_latex: :align |c|c|c|c|c|
|-------------+--------------------------+----------------------------|
| *Mapping*   | *Low*                    | *High*                     |
|-------------+--------------------------+----------------------------|
| Linear      | $2000-1000=1000$: P8     | $2000+1000=3000$: P5       |
|-------------+--------------------------+----------------------------|
| Exponential | $2000 \div 1.5=1500$: P5 | $2000 \times 1.5=3000$: P5 |
|-------------+--------------------------+----------------------------|
**** So:
     For frequency, the depth should be a multiplier.

*** Thought process
**** /Thinking/ about the UGen ranges.
     - The range I've got: $-1$ to $1$. \pause
     - The range I need is \egls{exponential}: Use \mth{exprange}. \pause
     - A balanced \egls{linear} range is $-d$ to $d$.\\
       - Lower bound = negative (\mth{neg}) of upper bound.
       - Center = 0. \pause
     - A balanced \egls{exponential} range is $\frac{1}{d}$ to $d$.
       - Lower bound = \mth{reciprocal} of upper bound.
       - Center = 1. \pause
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.

*** Converting the LFO to multiplication			   :noexport:
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.
**** Convert the LFO's \egls{linear} signal into an \egls{exponential} range.
     - The \mth{exprange} method does this automatically.
     - The lower bound should be $\frac{1}{depth}$; upper, $depth$.

*** Exponentially-scaled modulator: Code
**** *Note:* You will probably have to close the GUI window and re-create it using \cd{p.gui}.
#+latex: \glsadd{reciprocal}
#+name: explfo
#+caption: Replace the linear-scale LFO with an exponential-scale LFO.
#+begin_src {} -i
~filtlfo = {
   var depth = ~depth + 1;  // Add 1
   // Use reciprocal and exprange
   SinOsc.kr(~lfreq).exprange(depth.reciprocal, depth)
};

~filter = { |ffreq = 2000, rq = 0.08|
   // Multiply by the LFO, not add
   ffreq = (ffreq * ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};

~lfreq.addSpec(\lfreq, [0.5, 18, \exp]);
~depth.addSpec(\depth, [0, 4]);
#+end_src

*** Note on efficiency					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** A note on efficiency:
The above example calculates \cd{\textasciitilde depth + 1}, saves it
in a variable, and then uses the variable in \mth{exprange}. Why?

If it were written @@latex:\cd{.exprange((\textasciitilde depth +
1).reciprocal, \textasciitilde depth + 1)}@@, the server would
calculate \cd{\textasciitilde depth + 1} /twice/. There are two
\cd{+ 1} operations, and it's too difficult for the \gls{SynthDef} builder
to identify that both will have the same result.

As written above, there is one addition, and the result is used twice.

The equivalent in Pure Data shows the difference graphically.

#+begin_center
#+attr_latex: :height 1.1in
[[../02-synth/img/pd-save-an-add.png]]
#+end_center

*Tip:* Whenever you need to use a signal in more than one place in a
synthesis function, assign it to a variable.
- "Calculate once, use many times" is more efficient.
- The variable name can remind you of the signal's purpose.

*** Modulation summary
**** For effective modulation:
     The key is to think about:
     - The expected range of the /modulated/ input;
     - How to convert a UGen's range to match.
**** This applies to all kinds of LFOs.
     - Oscillators
     - Sample players (at slow playback rates).
     - Envelopes (next...).

** Another envelope use: Articulation
*** Envelopes for articulation
**** Envelopes can control any parameter.
     /Very/ common: control the filter frequency, for articulation.
     - Create a new \ugen{EnvGen}, as a multiplier for \ci{ffreq}.
     - Use it in the \ci{\textasciitilde filter} module.
#+latex: \glsadd{clip}
#+name: filterEg
#+caption: Apply an envelope to the filter frequency.
#+begin_src {} -i
~feg = { |gt = 0|
   EnvGen.kr(Env([1, 4, 1], [0.01, 0.15], -4), gt)
};

~filter = { |ffreq = 2000, rq = 0.2|
   RLPF.ar(~oscil.ar,
      clip(ffreq * ~feg, 20, 20000),
      rq
   )
};

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src

*** Notes on that example
**** Filter envelope as a multiplier.
     - The envelope /modulates/ the set filter frequency. You get
       articulation /and/ independent timbre control.
     - \cd{ffreq * \textasciitilde feg} may go outside the valid
       frequency range. \mth{clip} it for safety.
       - \mth{clip} moves out-of-range values to the nearest boundary.
       - Filters tend to blow up if the frequency goes out of range.
**** \cd{p.setEvent} treats the control inputs globally.
     - \cd{gt: 1} in the event sets \ci{gt} in both envelope modules
       simultaneously.

*** Articulation: Noise oscillator with envelope
**** With envelopes, we can use a noise generator.
     - A classic analog synthesizer trick for a "chff" in the attack.
     - Add a short, percussive (\cd{Env.perc}) burst of noise.
     - Usually use a \clss{BPF} to color the noise.
**** Typical noise generators
     - \ugen{WhiteNoise} :: Very bright, harsh noise.
     - \ugen{PinkNoise} :: Still bright, but more pleasant than white noise.
     - \ugen{BrownNoise} :: Darker sound. Named after \egls{Brownian motion}, not the color.

*** Add a noise attack to the previous example
    Based on Listing [[filterEg]].
#+name: noiseAtk
#+caption: Create a noise generator, and an envelope and filter for it.
#+begin_src {} -i
~noiseEg = { |gt, noiseDur = 0.08|
   EnvGen.kr(Env.perc(0.01, noiseDur), gt)
};
~noise = { |noiseAmp = 0.8|
   PinkNoise.ar(noiseAmp * ~noiseEg)
};
~noiseFilt = { |ffreq = 11000, rq = 0.34|
   BPF.ar(~noise.ar, ffreq, rq).dup
};
~noiseFilt.play;

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
**** You can also add an envelope to the \ugen{BPF} frequency.
     Exercise for you.
**** Settings for a BPF frequency envelope			   :noexport:
ffreq = 2300
~noiseFeg = { |gt|
   EnvGen.kr(Env.perc(0.01, 0.2), gt)
   .linexp(0, 1, 1, 4)
};

*** Exercise: Fingered portamento
    1. Clear the ProxySpace. Then write a modular synth:
       - \ci{\textasciitilde oscil} :: Detuned oscillator.
       - \ci{\textasciitilde ampEg} :: Amplitude envelope.
       - \ci{\textasciitilde filtEg} :: Filter frequency envelope.
       - \ci{\textasciitilde filter} :: Resonant lowpass filter and main output.
    2. Write a \ci{\textbackslash psSet} pattern to play notes.
       - Use \ci{\textbackslash legato} so that some notes slur, but not all.
    3. The pitches don't slide. Look up \ugen{Lag}'s help file, and
       apply it to the oscillator's frequency.

* Modal synthesis
** Ringing filters
*** What's a \egls{ringing filter}?
    Let's compare a bandpass filter (\ugen{BPF}) against a ringing filter (\ugen{Ringz}).
    - \cd{10.dbamp} in the filter: \ugen{BPF} is a quiet UGen, needs to be boosted.
#+name: ringz1a
#+caption: Noise into a bandpass filter: sounds like filtered noise.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~exciter = { |freq = 440, amp = 1|
   PinkNoise.ar(amp)
   * EnvGen.kr(Env.perc(0.01, 0.3), Impulse.kr(2))
};
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~exciter.ar, ffreq, rq, 10.dbamp).dup
};
~filter.play;
~filter.addSpec(\ffreq, \freq).addSpec(\rq, [1, 0.05, \exp]);
p.gui;
)
#+end_src

*** Substitute the ringing filter
    - *Note:* \ugen{Ringz} can be /very/ loud!\\
      0.01 = --40 dB.
    - Also, we control the \gls{ring time}, not \ci{rq}.
**** Switch back and forth between \ugen{BPF} and \ugen{Ringz}.
#+name: ringz1b
#+caption: Noise into a ringing filter: pitch is much stronger.
#+begin_src {} -i
~filter.addSpec(\ringtime, [0.01, 2, \exp]);
~filter = { |ffreq = 2000, ringtime = 0.5|
   Ringz.ar(~exciter.ar, ffreq, ringtime, 0.01).dup
};
#+end_src

*** Impulse response
**** What if we use impulses?
#+name: ringz1c
#+caption: Impulse into a ringing filter.
#+begin_src {} -i
~exciter = { Impulse.ar(2) };
#+end_src
     - Suddenly much quieter. (Change 0.01 to 0.1 in the filter.)
     - Now you're hearing the filter's \egls{impulse response}.
     - What does it sound like?\\
       Use the oscilloscope (/Language/ menu) for more detail.

*** Ringz impulse response, plotted
**** Plot code							   :noexport:
{ Ringz.ar(Impulse.ar(0.025.reciprocal), 440, 0.05) }.plot(0.05, minval: -1.2, maxval: 1.2);
**** This is a \ugen{Ringz}'s response to two impulses.
     - Note especially the spike when the second impulse comes in.
     - This will make a slight click in the output---not clean.
#+begin_center
#+attr_latex: :height 1.5in
[[../02-synth/img/ringz-impulse-responses.png]]
#+end_center

*** Modal synthesis, in a nutshell
**** Simplest explanation of \egls{modal synthesis}:
     - \Gls{exciter} :: A short burst of noise, like a hammer striking a bell.
     - Filter :: A ringing filter simulates one vibrational \egls{mode}.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.6
     :END:
***** Vibrational modes
      - When you hit an object---``excite'' it---it starts to vibrate.
      - It vibrates in many different ways at the same time.
      - Each one of these consistent patterns is a \egls{mode}.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.35
     :END:
#+begin_center
#+name: modejpg
#+caption: Vibrational modes in a cup of coffee. Image credit: Natural Philo, http://en.wikipedia.org/wiki/File:A_cup_of_black_coffee_vibrating_in_normal_modes.jpeg.
#+attr_latex: :height 1in
[[../02-synth/img/A_cup_of_black_coffee_vibrating_in_normal_modes.jpeg]]
#+end_center

** Banks of ringing filters
*** More modes: Klank
**** \ugen{Klank} is an easy way to get lots of ringing filters.
     The example shows how to write it.
     - Wrap the filter parameters inside @@latex:\textcolor{codecolor}{$^{\backprime}$}\cd{[...]}@@.\\
       The backtick @@latex:\textcolor{codecolor}{$^{\backprime}$}@@ is important!
     - This should contain three arrays:
       - Filter frequencies;
       - Amplitudes;
       - Ring times.
#+name: klank1
#+caption: Klank gives you several vibrating modes. Integer multiples sound like a synthetic oscillator. Randomized frequencies produce various percussive sounds.
#+begin_src {} -i
~filter = {
   Klank.ar(`[
      [220, 440, 660, 880, 1100],
      [0.1, 0.1, 0.1, 0.1, 0.1],
      Array.fill(5, { rrand(0.25, 0.75) })
   ], ~exciter.ar).dup
};
#+end_src

*** Array.fill
**** Note \cd{Array.fill(size, item)}.\glsadd{fill}\glsadd{Array}
     - In the example, it makes five random ring times.
     - For random numbers, the expression should be in a function (curly braces).
**** Exercise for you:
     - Write \cd{Array.fill} expressions for frequency and amplitude.
     - Experiment with different random boundaries.
     - (Remember, frequency is exponential: \mth{exprand}.)

*** Exciters
**** The \gls{exciter} is usually a noise generator, with a short envelope.
     - Remember three noise types: \ugen{WhiteNoise}, \ugen{PinkNoise}, \ugen{BrownNoise}.
     - \cd{Env.perc}\glsadd{perc} is a good envelope choice.
**** Exercises for you:
    - Rewrite \cd{\textasciitilde exciter} to use a noise generator.
    - Multiply by a percussive envelope.
    - Also add a trigger \ci{t \textunderscore trig} argument.
    - Drive the trigger argument with a \ci{\textbackslash psSet} pattern.
**** These exercises prepare for the next topic.

*** Klank, Ringz, DynKlank
**** \ugen{Klank}'s filter parameters are the same as in \ugen{Ringz}.
     - \ugen{Klank} sounds like one \ugen{Ringz} per array item, mixed.
     - *Good:* \ugen{Klank} is more efficient.
     - *Bad:* You can't change the filters after starting the Synth.\\
       This is a big problem for this style of modular synthesis.
**** \ugen{DynKlank} takes the same kind of input.
     - But it makes lots of \ugen{Ringz} filters.
     - So you /can/ change the filter parameters (but, higher CPU cost).

*** DynKlank to play pitches
**** Both \ugen{Klank} and \ugen{DynKlank} have /scaling/ inputs.
     - The actual filter frequencies are \cd{freqArray * freqscale}.
     - So, to play a specific pitch:
       - Write the frequency array so that 1.0 is the fundamental pitch.
       - Plug the desired frequency into \ci{freqscale}.
     - (Read the help file for details on \ci{freqoffset} and \ci{decayscale}.)
**** In modular style, you have to use \ugen{DynKlank} for this.
     Otherwise, the pitch can't change.

*** Pitched DynKlank example
#+name: dkpitch1
#+caption: Using DynKlank in modular style to play pitches by modal synthesis.
#+begin_src {} -i
~filter = { |freq = 440|
   DynKlank.ar(`[
      Array.fill(5, { |i| (i+1) * rrand(0.97, 1.03) }),
      Array.fill(5, 0.1),
      Array.fill(5, { rrand(0.25, 0.75) })
   ], ~oscil.ar, freqscale: freq).dup
};
#+end_src
**** Exercise for you:
     - Change the pattern to play other pitches.\\
       You can use \ci{degree}, \ci{midinote} or \ci{freq}.

*** Graphical editor for ringing filters
**** SC includes a graphical way to play with \ugen{Ringz} filters.
     - It's "hidden" in the code examples directory.
     - When finished, it will print an Array to use directly in \ugen{Klank}.
     - This code snippet will access the editor, in any OS.
       - \clss{Platform} contains many file paths that are different depending on the OS.
       - \mth{resourceDir} points to examples and sounds, among other things.
#+name: klankEditor
#+caption: Open, or run, the GUI example of editing up to 10 Ringz filters.
#+begin_src {} -i :var extract='t
(Platform.resourceDir +/+
   "examples/GUI examples/analog-drum-tuner.scd").openDocument;

(Platform.resourceDir +/+
   "examples/GUI examples/analog-drum-tuner.scd").load;
#+end_src

** Formant synthesis
*** What are formants?
**** \eGlspl{formant} are the way sounds resonate in the vocal cavity.
     - The formants change for different vowels and voice types.
**** FOF (/fonctions d'ondes formantiques/) (X. Rodet, 1979/1984).
     - One FOF is a decaying sine wave, triggered by impulses at the desired pitch.
     - Decaying sine wave... isn't that the \ugen{Ringz} impulse response?
**** We can use ringing filters to do this!
     But, the impulse response also had a nasty click in it.

*** Controlling the "click"
**** What if we subtract a shorter \ugen{Ringz} from a longer one?
#+begin_center
#+attr_latex: :height 1.8in
[[../02-synth/img/ringz-minus-ringz.png]]
#+end_center
**** This changes the impulse response's envelope.
     - Smoother at the beginning.

*** Formant synthesis
**** \ugen{Formlet} does this for you.
     - It's the same as @@latex:\cd{Ringz.ar(in, freq, decay) - Ringz.ar(in, freq, attack)}@@.
**** This is one way to do \egls{formant} synthesis.
     - The \gls{exciter} gives the main pitch.
     - The \ugen{Formlet} resonates at another frequency.
     - In the GUI, move \ci{ringtime} down to 0.02 or 0.03.
     - Then move \ci{ffreq} around in the midrange.
#+name: fmlet1
#+caption: Create one formant around a train of impulses, using Formlet.
#+begin_src {} -i
~filter = { |ffreq = 2000, ringtime = 0.5|
   Formlet.ar(~exciter.ar, ffreq, ringtime * 0.1, ringtime, 0.1).dup
};

~exciter = { |freq = 220| Impulse.ar(freq) };
#+end_src

*** Producing vowels
**** Real vowels have two or three main formants.
     Plus a couple of others that are weaker.
**** So, we need a bank of \ugen{Formlet}s.
     - \ugen{Formlet} = \cd{Ringz(decay) - Ringz(attack)}.
     - \ugen{Klank} or \ugen{DynKlank} = bank of \ugen{Ringz}.
     - So, a bank of \ugen{Formlet}s = \cd{Klank(decay) - Klank(attack)}!

*** Example: FormantTable and Klank
    - The result of \mth{atKlank} is used directly where the filter array should appear.
    - One \ugen{Klank} minus another (like \ugen{Formlet}).
      - The second one uses \ci{decayscale} to make the attack shorter than the real ring time.
**** Turn down the volume before running this!
     It may be very loud.
#+name: formants1
#+caption: Formant synthesis with FormantTable and Klank
#+begin_src {} -i
~filter = {
   var in = ~exciter.ar,
   formant = FormantTable.atKlank(\tenorU);
   (Klank.ar(`formant, in)
      - Klank.ar(`formant, in, decayscale: 0.1)).dup
};
#+end_src

*** Exercises for you
**** On your own:
     - With \ugen{Impulse} as the exciter, it could be too buzzy.
       - Add a lowpass filter to the \ci{\textasciitilde filter} module.
       - Also add a \ci{ffreq} argument, with spec, so that you can find a good cutoff frequency in the GUI.
     - Try other voice types and vowels.
     - Try detuning the exciter.

*** Changing vowels by arguments: Filter
**** Up to now, we can't slide from one vowel to another.
     - \ugen{Klank} can't change parameters!
     - Change to another filter.\\
       \ugen{DynKlank} works, but each one makes five \ugen{Ringz}.\\
       10 filters for five formants!
     - We could get the same with just five \ugen{Formlet}s.
#+begin_src {} -i
sig = DynKlank.ar(`formant, in) -
   DynKlank.ar(`formant, in, decayscale: 0.1);

// or
Mix(Formlet.ar(in, formant[0],
   formant[2] * 0.1, formant[2], formant[1]));
#+end_src

*** Notes (filter)					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's \cd{formant[0]}?
It happens that \mth{atKlank} returns exactly the array that
\ugen{Klank} expects: @@latex:\cd{[[frequencies], [amplitudes], [ring
times]]}@@. \cd{formant[0]} accesses the first item: the array of
frequencies. When we put this into the frequency input of
\ugen{Formlet}, we have multichannel expansion. The five frequencies,
five amplitudes and five ring times cause \ugen{Formlet} to expand
into an array of five \ugen{Formlet}s. Then, all we have to do is
\ugen{Mix} them together.

*** Changing vowels by arguments 2: Arrayed controls
**** We also need a way to send arrays to an argument.
     - Regular arguments have some limitations for this.
     - Remember that arguments turn into \egls{control inputs}.
     - We can make control inputs explicitly, using \ugen{NamedControl}.
     - An array for the default value makes an \egls{arrayed control}.
#+begin_src {} -i
formant = NamedControl.kr(\formant,
   FormantTable.atKlank(\tenorE).flat);
#+end_src
**** This is often used to send envelope definitions.

*** Arrayed control example
    Not related to formant synthesis; just to show \glspl{arrayed control}.
    - Also note the \ci{\textbackslash dur} pattern.\\
      Can you figure out why it makes the rhythm you hear?
#+name: arrayctl1
#+caption: An arrayed control, to make three pitches from one oscillator module. Assumes you are already in a ProxySpace.
#+begin_src {} -i :var extract='t
~arrayarg = { |amp = 0.1|
   var freq = NamedControl.kr(\freq, 55 * [4, 5, 6]);
   (Mix(SinOsc.ar(freq)) * amp).dup
};
~arrayarg.play;

~arrayarg.set(\freq, 82.5 * [4, 5, 6]);

~player = \psSet -> Pbind(
   \degree, Pwhite(-7, 7, inf) + [0, 2, 4],
   \dur, Pseq([
      Pn(0.15, { rrand(3, 8) }),
      0.15 * Pwhite(3, 6, 1)
   ], inf)
);

~player.clear; ~arrayarg.clear;
#+end_src

*** Changing vowels by arguments 3: Array geometry
**** Small complication: Array dimensions
     - \clss{FormantTable} gives a two-dimensional array (5x3).
     - The filters expect the two-dimensional array (5x3).
     - The \ugen{NamedControl} must be one-dimensional!
**** Solution:
     - One-dimensional array for messaging: use \mth{flat}.
     - Two dimensions in the synth function: use \mth{clump}.
       - \mth{clump}'s argument is a number, saying how big each row should be.
       - \clss{FormantTable} gives five filters, so \cd{clump(5)}.
#+name: flat1
#+caption: Try these to see the effect of flat and clump.
#+begin_src {} -i
a = FormantTable.atKlank(\tenorE).flat;

a.clump(5);
#+end_src

*** Changing vowels: Put it all together
**** Also note the \ugen{Lag}.
     - We want the vowels to slide, not jump.
#+name: formant2
#+caption: All the pieces of the "changing vowels" puzzle: Formlet rather than DynKlank, the arrayed control (NamedControl), fixing the array geometry (flat, clump).
#+begin_src {} -i
~filter = { |ffreq = 6000|
   var sig, in = ~exciter.ar,
   formant = NamedControl.kr(\formant,
      FormantTable.atKlank(\tenorE).flat);
   formant = Lag.kr(formant, 1).clump(5);
   sig = Mix(Formlet.ar(in, formant[0],
      formant[2] * 0.1, formant[2], formant[1]));
   LPF.ar(sig, ffreq).dup;
};

~filter.set(\formant, FormantTable.atKlank(\tenorO).flat);

~filter.set(\formant, FormantTable.atKlank(\tenorU).flat);
#+end_src

*** Exercise for you
    Write a \ci{\textbackslash psSet} pattern to play different
    pitches, and send a different vowel for each note.
    - Look back at the list patterns. Which ones let you choose
      randomly from a list?
    - If this random pattern returns the names from
      \clss{FormantTable}, how to get the filter specs?
      - \mth{collect} can run a function on every one of the names.
      - @@latex:\cd{.collect \{ |name| FormantTable.atKlank(name).flat \}}@@.

*** Notes (arrays in SynthDef)				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Array geometry in synthesis functions
One of the hardest things to understand in SuperCollider is:

- What is the server's responsibility?
- What is the language's responsibility?

The server runs the UGens, and passes signals between them based on
the kinds of connections we have already discussed. That's all it
does. It doesn't know anything about language structures. Functions,
patterns, loops, arrays---all are completely unknown to the server.

\mth{clump}, therefore, is the language's job. But what is it actually
doing in this case?

1. We're initializing the \ugen{NamedControl} with an array of 15
   items. The language needs to have 15 objects, so that it can keep
   track of UGen connections. These 15 objects are
   \clsspl{OutputProxy}. Using "op" as an abbreviation for
   \clss{OutputProxy}:

   #+latex: \cd{[op$_0$, op$_1$, op$_2$, ... op$_14$]}

2. \mth{clump} separates the \clsspl{OutputProxy} into groups of five.

   - \cd{[op$_0$, op$_1$, ... op$_4$]},
   - \cd{[op$_5$, op$_6$, ... op$_9$]},
   - @@latex:\cd{[op$_{10}$, op$_{11}$, ... op$_{14}$]}@@.

3. Then, \cd{formant[0]} allows any other UGen (here, \ugen{Formlet})
   to connect back to the first five items from the
   \ugen{NamedControl}. \cd{formant[1]} connects to the second five,
   and so on.

The language can do whatever you need to these array structures while
building a \clss{SynthDef}. But this is only working on the
arrangement of the /signal placeholders/. The language produces the
arrangement while creating the \clss{SynthDef} only once. Then, the
server works only with the UGens, placeholders and their connections,
without worrying about /how/ the connections were arranged in the
first place.

** Karplus-Strong, banded waveguides
*** Karplus-Strong, banded waveguides
**** Related to modal synthesis:
     - An \egls{exciter} feeds into a filter.
     - The exciter is noisy.
     - The filter shapes it into pitch.
**** Different type of filter.
     - Modal synthesis uses ringing filters.
     - Waveguides use feedback-delay filters.

*** Feedback-delay filters
**** \eGlspl{feedback-delay filter} include:
     - \eGlspl{comb filter} :: Uses a simple delay line. The spectrum looks like teeth of a comb.
     - \eGlspl{allpass filter} :: Passes all input frequencies at the original volume (hence "allpass"), but changes the phases.
#+name: fbdelay1
#+caption: Compare the effects of the two types of feedback-delay filters.
#+begin_src {} -i
(
~noise = { WhiteNoise.ar(0.1) };
~filter = {
   CombL.ar(~noise.ar, 0.1, 1/220, 1).dup
};
~filter.play;
)

~filter = {
   AllpassL.ar(~noise.ar, 0.1, 1/220, 1).dup
};
#+end_src

*** Allpass filters and phases
**** The \gls{allpass filter} didn't sound like it was doing much.
     - It doesn't change the frequencies' strengths.\\
       So, the output sounds like the original.
     - It does affect the frequencies' phases.\\
       You don't hear the phase shifts until you the original and filtered signals.
     - The result is like a \gls{comb filter}, but with a softer edge.
#+name: fbdelay2
#+caption: Mix the original with the allpass-filtered signal.
#+begin_src {} -i
~filter = {
   var sig = ~noise.ar;
   sig + AllpassL.ar(sig, 0.1, 1/220, 1).dup
};
#+end_src

*** Short exciter
**** We can excite feedback filters with short noise bursts.
     Just like \gls{modal synthesis}.
**** Exercise for you
     - Add a percussive envelope to the \ci{\textasciitilde noise} module.
     - What does it sound like?
**** Code :noexport:
~noise = {
   WhiteNoise.ar(0.1)
   * EnvGen.ar(Env.perc(0.01, 0.08), Impulse.ar(2))
};

*** Karplus-Strong plucked string synthesis
**** This sounds a lot like a plucked string! Except...
     - In a real string, energy leaks away from the high frequencies first.
     - To model this: Put a lowpass filter in the middle of the feedback loop.
     - The \ugen{Pluck} UGen does this automatically.

*** Pluck.ar example
#+name: pluck1
#+caption: The Pluck UGen. Experiment with the parameters in p.gui.
#+begin_src {} -i
~pluck = { |freq = 220, decay = 1, coef = 0.5|
   Pluck.ar(
      in: WhiteNoise.ar(0.3),
      trig: Impulse.ar(2),
      maxdelaytime: 0.2,
      delaytime: freq.reciprocal,
      decaytime: decay,
      coef: coef
   ).dup
};
~pluck.addSpec(\decay, [0.1, 2, \exp]);
~pluck.addSpec(\coef, [0, 1]);
~pluck.play;

~pluck.clear;
#+end_src



* Effects common in subtractive synthesis 			   :noexport:
** Chorus
** Distortion

#+begin_comment
* Removed							   :noexport:
*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array.\\
      \cd{freq * [1, detun, detun.reciprocal]}\\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
# #+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** More convenience for gates: Events
**** Sequencing: Inconvenient to close gates by hand.
     Introducing \clss{Event}.
     - We saw an \clss{Event} briefly, in the "canonical" example (Listing [[canonical]]).
     - It both played and released a Synth.
     - We will learn more about events as we go.
**** Events have lots of properties, including timing.
     - \ci{dur} :: Number of beats until the next event.
     - \ci{sustain} :: Number of beats to keep a gate open. (May
		       also be calculated from \cd{dur * legato}.)

*** Event patterns: One-stop shopping
    Let's be clear about the implications:
**** Event patterns handle everything for sequencing
     - Parameter setting
       - New parameter values are saved in the event
     - Timing
       - Every event has a \egls{delta}

*** What is \textbackslash psSet?
**** \ci{\textbackslash psSet} says how the pattern's events should be used.
     - \clss{Pbind} doesn't say /what to do/.\\
       It only says what information to use.
     - The \clss{Event} interprets the data and takes action, based on the \egls{event type}.
**** \ci{\textbackslash psSet} is an event type.
     - It tells the pattern's events to operate on existing \clsspl{NodeProxy} within the \clss{ProxySpace}.
     - Actually a bit more: It connects the events to the current \clss{ProxySpace}.

*** Why not use \textbackslash note?
**** If \ci{\textbackslash note} is the normal \gls{event type}, why not use it?
     - We will, later.
     - We are beginning with a \egls{modular} approach, for reasons noted earlier.
     - This approach needs a different event type.

*** Note control summary: Envelopes
**** \eGls{breakpoint} \eglspl{envelope}
     - Idea: Start level, list of segments
     - Written in \clss{Env} using three arrays: \ci{levels}, \ci{times}, \ci{curve}
**** \eGls{envelope generator}
     - Renders the segments into a signal.
     - Responds to \eglspl{trigger} and \eglspl{gate}.
**** Triggers and gates: signal > 0
     - A \te{trigger} is instantaneous, when the signal becomes > 0.
     - A \te{gate} is open when > 0, closed otherwise.

*** Note control summary: Gates and Events
**** \eGlspl{gate} must be opened and closed.
     - By hand, using \cd{\textasciitilde something.set(\textbackslash gt, 1)} or \cd{0}.
     - An \clss{Event} can close the gate for you, after a given \ci{sustain} time.
       - \ci{sustain} can be given directly, or you can provide \ci{dur} and \ci{legato}.
**** Events can set many parameters at once.
     Very useful for sequencing: The start of a note can change pitch,
     amplitude, timbre controls all at once.

** Special event keys: Pitch and Time
*** Pitch and time in events
**** Many levels to write pitch and time.
     You can organize pitch and time in different ways, appropriate to different musical ideas.
**** "Physical" level
     Ultimately, SC uses specific event keys for the final result. These can be calculated from higher levels.
     - Time :: \ci{delta} and \ci{sustain}
     - Pitch :: \ci{freq}

*** Time model
**** Physical level: \ci{delta} and \ci{sustain}.
     - \ci{delta} :: How many beats until the next event.
     - \ci{sustain} :: How many beats before releasing the envelope.
**** Higher level: \ci{dur}, \ci{legato}, \ci{stretch}
     - Larger \ci{stretch} makes things go slower.
     - Smaller \ci{legato} makes the notes shorter.
     - \cd{delta = dur * stretch}
     - \cd{sustain = dur * stretch * legato}

*** Example: Articulation using \textbackslash legato
    First a synth. Further explanation later today.
#+name: legato1
# #+caption: A modular synth, with amplitude and filter frequency envelopes for articulation.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;
~oscil = { |freq = 440|
   Mix(Pulse.ar(
      Lag.kr(freq, 0.08) * { exprand(1/1.005, 1.005) }.dup(5),
      { rrand(0.4, 0.5) }.dup(5)
   ))
};
~ampEg = { |gt|
   EnvGen.kr(Env.adsr(0.01, 0.1, 0.6, 0.15), gt)
};
~feg = { |gt, width = 3|
   EnvGen.kr(Env.perc(0.01, 0.14, width), gt) + 1
};
~filter = { |ffreq = 1800, rq = 0.2, amp = 0.05|
   (RLPF.ar(~oscil.ar, clip(ffreq * ~feg, 20, 20000), rq)
      * amp * ~ampEg).dup
};
~filter.play;
#+end_src

*** The \textbackslash legato pattern
    Play it with a \mth{psSet} pattern.
    - Two possible \ci{\textbackslash legato} values:
      - 0.5: Half the note's duration---staccato
      - 1.05: Longer than the note's duration---legato\\
        This makes a sliding pitch, like a classic mono synth.
    - \ci{\textbackslash legato} is easier than calculating
      \ci{sustain} by hand.
#+name: legato2
# #+caption: A pattern, to play the previous synth like a mono synth with fingered glides.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pwhite(36, 48, inf),
   \dur, Pwhite(1, 3, inf) * 0.125,
   \legato, Prand(#[0.5, 1.05], inf),
   \gt, 1
);

~player.clear;
#+end_src

#+end_comment
