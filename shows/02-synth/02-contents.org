#+startup: beamer

#+TITLE: SuperCollider Week, Day 2 \\ Synthesis Techniques
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL: 

# #+INCLUDE: "../slidehead.org"
#+INCLUDE: "../printhead.org"

#+include: "../glossary.org"

* Subtractive synthesis
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** Syntax alert! Arguments
**** Function \gls{arguments} using vertical pipe characters
     \cd{|ffreq = 2000|} means the same as \cd{arg ffreq = 2000;}.
     - ffreq :: The argument name.
     - 2000 :: The argument's default value.
**** Arguments are magical in synthesis functions.
     - They automatically become \gls{control inputs}.
     - You can set the value from outside, and it changes the sound inside.
     - One synthesis function can make many frequencies, amplitudes, filtering behaviors etc.

*** Syntax alert: Argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an \egls{exponential} curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: \eGls{exponential}.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[./img/three-waves2.png]]
   #+end_center
\\ *Note:* Band-limited triangle oscillators may be found in the
sc3-plugins package.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%).\\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     We like small imperfections: Human players are never exactly in tune.
**** Do the same in a synth.
#+name: detune
#+caption: Detuning the oscillator.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}.\\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array.\\
      \cd{freq * [1, detun, detun.reciprocal]}\\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
#+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_src {} -i
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_src

*** Multichannel expansion is super cool
**** Parallel processing of multiple channels is very common.
     Multichannel expansion makes it easy (in the basic cases): Just
     write the processing as if for one channel, and SC automatically
     duplicates it for all channels.

     Max/MSP is effectively limited to only the third, most redundant,
     form. You have to copy the whole signal-processing chain for each
     channel /by hand/.

     Since multichannel processing is more convenient in SC, you'll do
     more of it and get more interesting sounds.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[./img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}:\\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses \ci{rq} = $\frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.

* Modulation: Low-Frequency Oscillators
** Modulation: Low-Frequency Oscillators
*** Modulation
**** Little secret: Synthesis techniques are sometimes /really simple/.
     We just beef them up with /layering/ and \egls{modulation}.
**** Modulate a parameter by another signal.
     - We already did this, with the filter frequency envelope.
     - Another modulation source: \eglspl{LFO} (Low-Frequency Oscillators)
     - SC has a /lot/ of them.
**** For this section:
     - Introduce LFO shapes and mechanism
     - Talk about signal ranges

*** LFO + filter
**** Start with an earlier synth, slightly modified.
#+name: scifi1
#+caption: Basic detuned synth.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 120|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 2000, rq = 0.08|
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
~filter.play;

~filter.addSpec(\ffreq, \freq);
~filter.addSpec(\rq, [1, 0.02, \exp]);
p.gui;
#+end_src

*** Add an LFO: sci-fi heaven
**** Same pattern as before:
     - Add a new module (\ci{\textasciitilde filtlfo}). This is a slowly-changing signal.
     - Use it in the filter (@@latex:\cd{ffreq + \textasciitilde
       filtlfo}@@). Adding it to the basic filter frequency means that
       the actual filter cutoff goes slowly above and below the set
       frequency.
#+name: scifi2
#+caption: Add an LFO to the filter.
#+begin_src {} -i
~lfreq = 1; ~lfreq.addSpec(\value0, [0.5, 18, \exp]);
~depth = 100; ~depth.addSpec(\value0, [0, 1000]);
~filtlfo = { SinOsc.kr(~lfreq) * ~depth };

~filter = { |ffreq = 2000, rq = 0.08|
   ffreq = (ffreq + ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
#+end_src

*** LFO shape
**** Many common LFO shapes exist.
     This one is a simple sinewave (\clss{SinOsc}).\\
     Audio UGens may often be used for control signals.
**** Try some other shapes.
     What do they sound like?
#+latex: \glsadd{LFPulse}\glsadd{LFTri}\glsadd{LFSaw}
#+name: lfoshapes
#+caption: Play with some other common LFO shapes.
#+begin_src {} -i
~filtlfo = { LFPulse.kr(~lfreq) * ~depth };
~filtlfo = { LFTri.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth.neg };
~filtlfo = { LFNoise0.kr(~lfreq) * ~depth };
#+end_src
     - \ugen{LFNoise0} is like a standard synthesizer LFO called \egls{sample-and-hold}.

*** Uncommon LFO shapes
# **** SC goes further than the standard shapes.
    - Single-shot lines (\ugen{Line}, \ugen{XLine}).
    - Ramps (\ugen{LFNoise1}) and curves (\ugen{LFNoise2}) between random numbers.
    - Various functions from mathematics:
      - Gaussian (bell-curve) wave
      - Many, many \egls{chaotic} generators. 
#+latex: \glsadd{LFGauss}\glsadd{LinCongL}\glsadd{QuadL}
#+name: lfoshapes2
#+caption: LFO shapes not commonly found in other software.
#+begin_src {} -i
~filtlfo = { LFNoise1.kr(~lfreq) * ~depth };
~filtlfo = { LFNoise2.kr(~lfreq) * ~depth };
~filtlfo = { LFGauss.ar(~lfreq) * ~depth };

// chaotic
~filtlfo = { LinCongL.ar(~lfreq, 1.2, 0.08) * ~depth };
~filtlfo = { QuadL.ar(~lfreq) * ~depth };
#+end_src

** Range mapping for modulation
*** Modulation: All about signal ranges
**** Remember the key questions from before:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Modulation range for frequency
**** Frequency needs a wider range of variation.
     - Suppose the base frequency is 440.
     - If the modulator's range is $-1$ to $1$, the frequency will vary between 439 and 441.
     - That's $\frac{1}{440}=$ 0.23\%. The ear can't tell that it's changing!
**** You need to expand the range.
     That's the purpose of the \ci{\textasciitilde depth} module.

*** mul, add
**** Almost all UGens have \ci{mul} and \ci{add} arguments.
     - @@latex:\cd{SinOsc.ar(440, 0, 100, 440)} $\to$\\
       \cd{SinOsc.ar(440, 0) * 100 + 440}.@@
     - Converts the normal output range $-1$ to $1$ into 340 to 540.
     - If \ci{add} is 0, \ci{mul} acts like an amplifier.
**** In the previous LFO example:
#+attr_latex: :align |c|c|
|------------------------------------+----------------------|
| *Operation*                        | *Range*              |
|------------------------------------+----------------------|
| \ugen{SinOsc}                      | Bipolar: $-1$ to $1$ |
|------------------------------------+----------------------|
| \cd{* \textasciitilde depth} ($d$) | $-d$ to $d$          |
|------------------------------------+----------------------|
| \cd{+ ffreq} ($f$)                 | $f-d$ to $f+d$       |
|------------------------------------+----------------------|

*** Range mapping methods
**** All UGens have two methods to make it easier:
     - \cd{UGen.ar(...).range(low, high)}: \eGls{linear} mapping.
     - \cd{UGen.ar(...).exprange(low, high)}: \eGls{exponential} mapping.
#+latex: \glsadd{range}\glsadd{exprange}
**** Also, methods that are good for numbers as well as UGens:
Arguments: inMin, inMax, outMin, outMax, clip.
     - \mth{linlin} :: \eGls{linear} input, \egls{linear} output.
     - \mth{linexp} :: \eGls{linear} input, \egls{exponential} output.
     - \mth{explin} :: \eGls{exponential} input, \egls{linear} output.
     - \mth{lincurve} :: \eGls{linear} input, \te{curved} output. (Extra argument for the curve factor.)
     - \mth{curvelin} :: \te{Curved} input, \egls{linear} output.

*** What is "exponential"?
**** \eGls{exponential} means using multiplication in place of addition.
     - Every octave up means multiplying by 2.
     - Start at 55 Hz, octaves are 55, 110, 220, 440, 880.
     - \cd{0.5.linlin(0, 1, 55, 880)} is 467.5.\\
       Halfway between 55 and 880, but it isn't the /octave/.
     - \cd{0.5.linexp(0, 1, 55, 880)} is 220.
#+name: linExpPlot
#+caption: Plot a line covering four octaves of frequency, first linearly, second exponentially.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);  // out: 0.0-1.0
   [
      // in range: 0-1; out range: 55-880
      line.linlin(0, 1, 55, 880),
      line.linexp(0, 1, 55, 880)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** What is "curved"?
**** \te{Curved} mappings let you control the amount of curve.
     - If \ci{curve} is 0, you get a straight line.
     - A negative curve "pulls" the line to the left.
     - A positive curve pulls it to the right.
     - The larger the number, the more extreme the curve.
#+name: linCurvePlot
#+caption: Plot a line covering four octaves of frequency with different curve factors.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);
   [
      line.lincurve(0, 1, 55, 880, -6),
      line.lincurve(0, 1, 55, 880, -2),
      line.lincurve(0, 1, 55, 880, 4)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** Exponential modulation for frequency
**** Earlier, we used \ci{+} to modulate frequency.
     Using the \mth{cpsmidi} method, we can get MIDI note numbers, and
     see how many semitones between given frequencies.
     - Assuming the base frequency is 2000 and the depth is 1000:
#+latex: \glsadd{round}\glsadd{differentiate}
#+name: expscale
#+caption: Convert modulation ranges for frequency into intervals.
#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.round(0.01);
// prints: [ 83.21, 95.21, 102.23 ]

[1000, 2000, 3000].cpsmidi.differentiate.round(0.01);
// prints: [ 83.21, 12, 7.02 ]

[2000 / 1.5, 2000, 2000 * 1.5].cpsmidi.differentiate.round(0.01);
// prints: [ 88.19, 7.02, 7.02 ]
#+end_src

*** Note: Differentiate					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Listing [[expscale]] illustrates how we can use arrays to do the same
operation repeatedly. To get the interval (number of semitones)
between two frequencies, we subtract the higher frequency's MIDI note
number from the same for the lower frequency. Here, we have three
frequencies---let's call them $f_0$, $f_1$ and $f_2$---and we want the
results $f_1 - f_0$ and $f_2 - f_1$. That's what \mth{differentiate}
does: it makes a new array where each item is the difference between
two of the original items that are right next to each other.

It also copies the first item. This is so that you can reconstruct the
original array using \mth{integrate}. We aren't interested in the
first item, so we can ignore it. If you need to get rid of the first
item, use \mth{drop}:

#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.differentiate.drop(1).round(0.01);
// prints: [ 12, 7.02 ]
#+end_src

*** How to make the intervals match?
    - The linear way uses inverse math operators: $+$ and $-$.\\
      But $-$ by the same amount produces a larger interval than $+$.
    - The exponential way also uses inverses: $\times$ and $\div$.\\
      Multiplying and dividing by the same amount produces the same interval.
#+attr_latex: :align |c|c|c|c|c|
|-------------+--------------------------+----------------------------|
| *Mapping*   | *Low*                    | *High*                     |
|-------------+--------------------------+----------------------------|
| Linear      | $2000-1000=1000$: P8     | $2000+1000=3000$: P5       |
|-------------+--------------------------+----------------------------|
| Exponential | $2000 \div 1.5=1500$: P5 | $2000 \times 1.5=3000$: P5 |
|-------------+--------------------------+----------------------------|
**** So:
     For frequency, the depth should be a multiplier.

*** Thought process
**** /Reason/ about the UGen ranges.
     - The range I've got: $-1$ to $1$. \pause
     - The range I need is \egls{exponential}: Use \mth{exprange}. \pause
     - A balanced \egls{linear} range is $-d$ to $d$.\\
       - Lower bound = negative (\mth{neg}) of upper bound.
       - Center = 0. \pause
     - A balanced \egls{exponential} range is $\frac{1}{d}$ to $d$.
       - Lower bound = \mth{reciprocal} of upper bound.
       - Center = 1. \pause
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.

*** Converting the LFO to multiplication			   :noexport:
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.
**** Convert the LFO's \egls{linear} signal into an \egls{exponential} range.
     - The \mth{exprange} method does this automatically.
     - The lower bound should be $\frac{1}{depth}$; upper, $depth$.

*** Exponentially-scaled modulator: Code
**** *Note:* You will probably have to close the GUI window and re-create it using \cd{p.gui}.
#+latex: \glsadd{reciprocal}
#+name: explfo
#+caption: Replace the linear-scale LFO with an exponential-scale LFO.
#+begin_src {} -i
~filtlfo = {
   var depth = ~depth + 1;  // Add 1
   // Use reciprocal and exprange
   SinOsc.kr(~lfreq).exprange(depth.reciprocal, depth)
};

~filter = { |ffreq = 2000, rq = 0.08|
   // Multiply by the LFO, not add
   ffreq = (ffreq * ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};

~lfreq.addSpec(\lfreq, [0.5, 18, \exp]);
~depth.addSpec(\depth, [0, 4]);
#+end_src

*** TODO Modulation summary?

*** Refinements 						   :noexport:
**** Making it sound richer
     - Detuned oscillators
     - ??
**** Controlling the sound musically
     - Envelopes: Playing notes
     - Parameter control
       - Internal: Low Frequency Oscillators (LFOs)
       - External: GUI and device input

* Effects common in subtractive synthesis			   :noexport:
** Chorus
** Distortion
