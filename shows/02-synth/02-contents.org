#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Sequencing with Event Patterns
** Patterns and Events
*** Patterns make Events very easily
**** An \clss{Event} is a set of named values.
     - Each value's name says how the value will be used for synthesis.
     - To use the values, call \mth{play} on the event.
**** A pattern called \clss{Pbind} is a list of /named patterns/.
     - Every \mth{next} value collects one value from each child pattern.
     - \mth{next} needs an empty \clss{Event} as a container for the new values.
#+name: pbind1
#+caption: Pbind collects child patterns' return values under given names.
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;

p.next(Event.new);
#+end_src

*** What does Pbind actually do?
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;
#+end_src
    1. Associate names with patterns:
       - \ci{\textbackslash freq} will be random between 100 and 400.
       - \ci{\textbackslash dur} will be a random multiple of 0.125.
    2. Automatically make streams from those patterns.
    3. Go through the pairs /in order/:
       - Get a value from that name's stream.
       - Add the value into the input \clss{Event}.

*** DebugPbind: Watch the event get filled
**** In Listing [[pbind1]], change \clss{Pbind} to \clss{DebugPbind}.
     Now you can read exactly what's going on.
     1. Start with an empty event.
     2. \ci{\textbackslash freq} gets the value 133.25.
     3. The empty event becomes \cd{(freq: 133.25)}.
     4. \ci{\textbackslash dur} gets 0.125.
     5. The final event has both values, with the right names.
#+begin_src {} -i
Source event: (  )
stream ID: freq
Event going in: (  )
streamout: 133.24577125341
stream ID: dur
Event going in: ( 'freq': 133.24577125341 )
streamout: 0.125
Result event: ( 'dur': 0.125, 'freq': 133.24577125341 )
#+end_src

*** Events and timing
**** In a \clss{Routine}/\clss{Task}, you could \mth{wait} until the next event.
     This happens automatically in an Event Pattern.
     - Events can calculate a \gls{delta} time.
     - Then, we just need something that will play the event and wait
       the right amount of time.
**** This is \clss{EventStreamPlayer}.
     - If you call \mth{play} on a pattern, it makes an \clss{EventStreamPlayer}.
     - This plays the events and waits for the event's delta.
     - The \egls{delta} may be given directly, or calculated from \cd{\textasciitilde dur}.
       - \cd{delta = \textasciitilde dur * \textasciitilde stretch}

*** Event patterns: One-stop shopping
    Let's be clear about the implications:
**** Event patterns handle everything for sequencing
     - Parameter setting
       - New parameter values are saved in the event
     - Timing
       - Every event has a \egls{delta}

*** Compare: Pattern vs. Routine to play notes
    - We've seen a \clss{Routine} that plays notes, using \mth{set}.
    - Let's see how the same is done with a \egls{pattern}.
#+name: rVsPbind
#+caption: A Pbind, expressing the same as the earlier Routine.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \t_trig, 1,
   \freq, Pexprand(110, 440, inf),
   \dur, 0.5
);

~player.clear;
#+end_src

**** \mth{psSet}						   :noexport:
     This modifier tells the pattern's events to operate on existing
     \clsspl{NodeProxy} within the \clss{ProxySpace}.

*** Patterns: "Declarative" programming
**** \eGlspl{Routine} are \egls{imperative}-style programming.
     - Listing [[noteseq1]] said: "Do this, then that."
       - Set the trigger and the frequency.
       - Wait 0.5 beats.
**** \eGlspl{pattern} are more like \egls{declarative} programming.
     - Listing [[rVsPbind]] says:
       - I want \ci{\textbackslash freq} to be like this.
       - I want \ci{\textbackslash dur} to be like that.
       - Go do it.
**** The two examples /do/ the same thing, but write it differently.

*** What is \textbackslash psSet?
**** \ci{\textbackslash psSet} says how the pattern's events should be used.
     - \clss{Pbind} doesn't say /what to do/.\\
       It only says what information to use.
     - The \clss{Event} interprets the data and takes action, based on the \egls{event type}.
**** \ci{\textbackslash psSet} is an event type.
     - It tells the pattern's events to operate on existing \clsspl{NodeProxy} within the \clss{ProxySpace}.
     - Actually a bit more: It connects the events to the current \clss{ProxySpace}.

*** Event types
**** Common \glspl{event type}:
     - \ci{\textbackslash note} :: Play a new \clss{Synth}.
     - \ci{\textbackslash set} :: Set controls in an existing \clss{Synth}.
     - \ci{\textbackslash off} :: Release an existing \clss{Synth}.
     - \ci{\textbackslash midi} :: Send note or control data to a hardware MIDI device.
**** Event types let you change the action without changing the data.
     - You can write a \ci{\textbackslash note} pattern, and hear the notes in scsynth.
     - Or, change to the \ci{\textbackslash midi} type and hear the notes from a hardware synth.

*** Why not use \textbackslash note?
**** If \ci{\textbackslash note} is the normal \gls{event type}, why not use it?
     - We will, later.
     - We are beginning with a \egls{modular} approach, for reasons noted earlier.
     - This approach needs a different event type.

*** TODO Exercises: Different pitch and rhythm patterns
** Special event keys: Pitch and Time
*** Pitch and time in events
**** Many levels to write pitch and time.
     You can organize pitch and time in different ways, appropriate to different musical ideas.
**** "Physical" level
     Ultimately, SC uses specific event keys for the final result. These can be calculated from higher levels.
     - Time :: \ci{delta} and \ci{sustain}
     - Pitch :: \ci{freq}

*** Time model
**** Physical level: \ci{delta} and \ci{sustain}.
     - \ci{delta} :: How many beats until the next event.
     - \ci{sustain} :: How many beats before releasing the envelope.
**** Higher level: \ci{dur}, \ci{legato}, \ci{stretch}
     - Larger \ci{stretch} makes things go slower.
     - Smaller \ci{legato} makes the notes shorter.
     - \cd{delta = dur * stretch}
     - \cd{sustain = dur * stretch * legato}

*** Example: Articulation using \textbackslash legato
    First a synth. Further explanation tomorrow.
#+name: legato1
#+caption: A modular synth, with amplitude and filter frequency envelopes for articulation.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;
~oscil = { |freq = 440|
   Mix(Pulse.ar(
      Lag.kr(freq, 0.08) * { exprand(1/1.005, 1.005) }.dup(5),
      { rrand(0.4, 0.5) }.dup(5)
   ))
};
~ampEg = { |gt|
   EnvGen.kr(Env.adsr(0.01, 0.1, 0.6, 0.15), gt)
};
~feg = { |gt, width = 3|
   EnvGen.kr(Env.perc(0.01, 0.14, width), gt) + 1
};
~filter = { |ffreq = 1800, rq = 0.2, amp = 0.05|
   (RLPF.ar(~oscil.ar, clip(ffreq * ~feg, 20, 20000), rq)
      * amp * ~ampEg).dup
};
~filter.play;
#+end_src

*** The \textbackslash legato pattern
    Play it with a \mth{psSet} pattern.
    - Two possible \ci{\textbackslash legato} values:
      - 0.5: Half the note's duration---staccato
      - 1.05: Longer than the note's duration---legato\\
        This makes a sliding pitch, like a classic mono synth.
    - \ci{\textbackslash legato} is easier than calculating
      \ci{sustain} by hand.
#+name: legato2
#+caption: A pattern, to play the previous synth like a mono synth with fingered glides.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pwhite(36, 48, inf),
   \dur, Pwhite(1, 3, inf) * 0.125,
   \legato, Prand(#[0.5, 1.05], inf),
   \gt, 1
);

~player.clear;
#+end_src

* Subtractive synthesis
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** Syntax alert! Arguments
**** Function \gls{arguments} using vertical pipe characters
     \cd{|ffreq = 2000|} means the same as \cd{arg ffreq = 2000;}.
     - ffreq :: The argument name.
     - 2000 :: The argument's default value.
**** Arguments are magical in synthesis functions.
     - They automatically become \gls{control inputs}.
     - You can set the value from outside, and it changes the sound inside.
     - One synthesis function can make many frequencies, amplitudes, filtering behaviors etc.

*** Syntax alert: Argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an \egls{exponential} curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: \eGls{exponential}.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[./img/three-waves2.png]]
   #+end_center
\\ *Note:* Band-limited triangle oscillators may be found in the
sc3-plugins package.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%).\\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     We like small imperfections: Human players are never exactly in tune.
**** Do the same in a synth.
#+name: detune
#+caption: Detuning the oscillator.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}.\\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array.\\
      \cd{freq * [1, detun, detun.reciprocal]}\\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
#+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_src {} -i
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_src

*** Multichannel expansion is super cool
**** Parallel processing of multiple channels is very common.
     Multichannel expansion makes it easy (in the basic cases): Just
     write the processing as if for one channel, and SC automatically
     duplicates it for all channels.

     Max/MSP is effectively limited to only the third, most redundant,
     form. You have to copy the whole signal-processing chain for each
     channel /by hand/.

     Since multichannel processing is more convenient in SC, you'll do
     more of it and get more interesting sounds.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[./img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}:\\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses \ci{rq} = $\frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.

* Modulation: Low-Frequency Oscillators
** Modulation: Low-Frequency Oscillators
*** Modulation
**** Little secret: Synthesis techniques are sometimes /really simple/.
     We just beef them up with /layering/ and \egls{modulation}.
**** Modulate a parameter by another signal.
     - We already did this, with the filter frequency envelope.
     - Another modulation source: \eglspl{LFO} (Low-Frequency Oscillators)
     - SC has a /lot/ of them.
**** For this section:
     - Introduce LFO shapes and mechanism
     - Talk about signal ranges

*** LFO + filter
**** Start with an earlier synth, slightly modified.
#+name: scifi1
#+caption: Basic detuned synth.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 120|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 2000, rq = 0.08|
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
~filter.play;

~filter.addSpec(\ffreq, \freq);
~filter.addSpec(\rq, [1, 0.02, \exp]);
p.gui;
#+end_src

*** Add an LFO: sci-fi heaven
**** Same pattern as before:
     - Add a new module (\ci{\textasciitilde filtlfo}). This is a slowly-changing signal.
     - Use it in the filter (@@latex:\cd{ffreq + \textasciitilde
       filtlfo}@@). Adding it to the basic filter frequency means that
       the actual filter cutoff goes slowly above and below the set
       frequency.
#+name: scifi2
#+caption: Add an LFO to the filter.
#+begin_src {} -i
~lfreq = 1; ~lfreq.addSpec(\value0, [0.5, 18, \exp]);
~depth = 100; ~depth.addSpec(\value0, [0, 1000]);
~filtlfo = { SinOsc.kr(~lfreq) * ~depth };

~filter = { |ffreq = 2000, rq = 0.08|
   ffreq = (ffreq + ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
#+end_src

*** LFO shape
**** Many common LFO shapes exist.
     This one is a simple sinewave (\clss{SinOsc}).\\
     Audio UGens may often be used for control signals.
**** Try some other shapes.
     What do they sound like?
#+latex: \glsadd{LFPulse}\glsadd{LFTri}\glsadd{LFSaw}
#+name: lfoshapes
#+caption: Play with some other common LFO shapes.
#+begin_src {} -i
~filtlfo = { LFPulse.kr(~lfreq) * ~depth };
~filtlfo = { LFTri.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth.neg };
~filtlfo = { LFNoise0.kr(~lfreq) * ~depth };
#+end_src
     - \ugen{LFNoise0} is like a standard synthesizer LFO called \egls{sample-and-hold}.

*** Uncommon LFO shapes
# **** SC goes further than the standard shapes.
    - Single-shot lines (\ugen{Line}, \ugen{XLine}).
    - Ramps (\ugen{LFNoise1}) and curves (\ugen{LFNoise2}) between random numbers.
    - Various functions from mathematics:
      - Gaussian (bell-curve) wave
      - Many, many \egls{chaotic} generators. 
#+latex: \glsadd{LFGauss}\glsadd{LinCongL}\glsadd{QuadL}
#+name: lfoshapes2
#+caption: LFO shapes not commonly found in other software.
#+begin_src {} -i
~filtlfo = { LFNoise1.kr(~lfreq) * ~depth };
~filtlfo = { LFNoise2.kr(~lfreq) * ~depth };
~filtlfo = { LFGauss.ar(~lfreq) * ~depth };

// chaotic
~filtlfo = { LinCongL.ar(~lfreq, 1.2, 0.08) * ~depth };
~filtlfo = { QuadL.ar(~lfreq) * ~depth };
#+end_src

** Range mapping for modulation
*** Modulation: All about signal ranges
**** Remember the key questions from before:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Modulation range for frequency
**** Frequency needs a wider range of variation.
     - Suppose the base frequency is 440.
     - If the modulator's range is $-1$ to $1$, the frequency will vary between 439 and 441.
     - That's $\frac{1}{440}=$ 0.23\%. The ear can't tell that it's changing!
**** You need to expand the range.
     That's the purpose of the \ci{\textasciitilde depth} module.

*** mul, add
**** Almost all UGens have \ci{mul} and \ci{add} arguments.
     - @@latex:\cd{SinOsc.ar(440, 0, 100, 440)} $\to$\\
       \cd{SinOsc.ar(440, 0) * 100 + 440}.@@
     - Converts the normal output range $-1$ to $1$ into 340 to 540.
     - If \ci{add} is 0, \ci{mul} acts like an amplifier.
**** In the previous LFO example:
#+attr_latex: :align |c|c|
|------------------------------------+----------------------|
| *Operation*                        | *Range*              |
|------------------------------------+----------------------|
| \ugen{SinOsc}                      | Bipolar: $-1$ to $1$ |
|------------------------------------+----------------------|
| \cd{* \textasciitilde depth} ($d$) | $-d$ to $d$          |
|------------------------------------+----------------------|
| \cd{+ ffreq} ($f$)                 | $f-d$ to $f+d$       |
|------------------------------------+----------------------|

*** Range mapping methods
**** All UGens have two methods to make it easier:
     - \cd{UGen.ar(...).range(low, high)}: \eGls{linear} mapping.
     - \cd{UGen.ar(...).exprange(low, high)}: \eGls{exponential} mapping.
#+latex: \glsadd{range}\glsadd{exprange}
**** Also, methods that are good for numbers as well as UGens:
Arguments: inMin, inMax, outMin, outMax, clip.
     - \mth{linlin} :: \eGls{linear} input, \egls{linear} output.
     - \mth{linexp} :: \eGls{linear} input, \egls{exponential} output.
     - \mth{explin} :: \eGls{exponential} input, \egls{linear} output.
     - \mth{lincurve} :: \eGls{linear} input, \te{curved} output. (Extra argument for the curve factor.)
     - \mth{curvelin} :: \te{Curved} input, \egls{linear} output.

*** What is "exponential"?
**** \eGls{exponential} means using multiplication in place of addition.
     - Every octave up means multiplying by 2.
     - Start at 55 Hz, octaves are 55, 110, 220, 440, 880.
     - \cd{0.5.linlin(0, 1, 55, 880)} is 467.5.\\
       Halfway between 55 and 880, but it isn't the /octave/.
     - \cd{0.5.linexp(0, 1, 55, 880)} is 220.
#+name: linExpPlot
#+caption: Plot a line covering four octaves of frequency, first linearly, second exponentially.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);  // out: 0.0-1.0
   [
      // in range: 0-1; out range: 55-880
      line.linlin(0, 1, 55, 880),
      line.linexp(0, 1, 55, 880)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** What is "curved"?
**** \te{Curved} mappings let you control the amount of curve.
     - If \ci{curve} is 0, you get a straight line.
     - A negative curve "pulls" the line to the left.
     - A positive curve pulls it to the right.
     - The larger the number, the more extreme the curve.
#+name: linCurvePlot
#+caption: Plot a line covering four octaves of frequency with different curve factors.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);
   [
      line.lincurve(0, 1, 55, 880, -6),
      line.lincurve(0, 1, 55, 880, -2),
      line.lincurve(0, 1, 55, 880, 4)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** Exponential modulation for frequency
**** Earlier, we used \ci{+} to modulate frequency.
     Using the \mth{cpsmidi} method, we can get MIDI note numbers, and
     see how many semitones between given frequencies.
     - Assuming the base frequency is 2000 and the depth is 1000:
#+latex: \glsadd{round}\glsadd{differentiate}
#+name: expscale
#+caption: Convert modulation ranges for frequency into intervals.
#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.round(0.01);
// prints: [ 83.21, 95.21, 102.23 ]

[1000, 2000, 3000].cpsmidi.differentiate.round(0.01);
// prints: [ 83.21, 12, 7.02 ]

[2000 / 1.5, 2000, 2000 * 1.5].cpsmidi.differentiate.round(0.01);
// prints: [ 88.19, 7.02, 7.02 ]
#+end_src

*** Note: Differentiate					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Listing [[expscale]] illustrates how we can use arrays to do the same
operation repeatedly. To get the interval (number of semitones)
between two frequencies, we subtract the higher frequency's MIDI note
number from the same for the lower frequency. Here, we have three
frequencies---let's call them $f_0$, $f_1$ and $f_2$---and we want the
results $f_1 - f_0$ and $f_2 - f_1$. That's what \mth{differentiate}
does: it makes a new array where each item is the difference between
two of the original items that are right next to each other.

It also copies the first item. This is so that you can reconstruct the
original array using \mth{integrate}. We aren't interested in the
first item, so we can ignore it. If you need to get rid of the first
item, use \mth{drop}:

#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.differentiate.drop(1).round(0.01);
// prints: [ 12, 7.02 ]
#+end_src

*** How to make the intervals match?
    - The linear way uses inverse math operators: $+$ and $-$.\\
      But $-$ by the same amount produces a larger interval than $+$.
    - The exponential way also uses inverses: $\times$ and $\div$.\\
      Multiplying and dividing by the same amount produces the same interval.
#+attr_latex: :align |c|c|c|c|c|
|-------------+--------------------------+----------------------------|
| *Mapping*   | *Low*                    | *High*                     |
|-------------+--------------------------+----------------------------|
| Linear      | $2000-1000=1000$: P8     | $2000+1000=3000$: P5       |
|-------------+--------------------------+----------------------------|
| Exponential | $2000 \div 1.5=1500$: P5 | $2000 \times 1.5=3000$: P5 |
|-------------+--------------------------+----------------------------|
**** So:
     For frequency, the depth should be a multiplier.

*** Thought process
**** /Reason/ about the UGen ranges.
     - The range I've got: $-1$ to $1$. \pause
     - The range I need is \egls{exponential}: Use \mth{exprange}. \pause
     - A balanced \egls{linear} range is $-d$ to $d$.\\
       - Lower bound = negative (\mth{neg}) of upper bound.
       - Center = 0. \pause
     - A balanced \egls{exponential} range is $\frac{1}{d}$ to $d$.
       - Lower bound = \mth{reciprocal} of upper bound.
       - Center = 1. \pause
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.

*** Converting the LFO to multiplication			   :noexport:
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.
**** Convert the LFO's \egls{linear} signal into an \egls{exponential} range.
     - The \mth{exprange} method does this automatically.
     - The lower bound should be $\frac{1}{depth}$; upper, $depth$.

*** Exponentially-scaled modulator: Code
**** *Note:* You will probably have to close the GUI window and re-create it using \cd{p.gui}.
#+latex: \glsadd{reciprocal}
#+name: explfo
#+caption: Replace the linear-scale LFO with an exponential-scale LFO.
#+begin_src {} -i
~filtlfo = {
   var depth = ~depth + 1;  // Add 1
   // Use reciprocal and exprange
   SinOsc.kr(~lfreq).exprange(depth.reciprocal, depth)
};

~filter = { |ffreq = 2000, rq = 0.08|
   // Multiply by the LFO, not add
   ffreq = (ffreq * ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};

~lfreq.addSpec(\lfreq, [0.5, 18, \exp]);
~depth.addSpec(\depth, [0, 4]);
#+end_src

*** TODO Modulation summary?

*** Refinements 						   :noexport:
**** Making it sound richer
     - Detuned oscillators
     - ??
**** Controlling the sound musically
     - Envelopes: Playing notes
     - Parameter control
       - Internal: Low Frequency Oscillators (LFOs)
       - External: GUI and device input

** Another envelope use: Articulation
*** Envelopes for articulation
**** Envelopes can control any parameter.
     /Very/ common: control the filter frequency, for articulation.
     - Create a new \ugen{EnvGen}, as a multiplier for \ci{ffreq}.
     - Use it in the \ci{\textasciitilde filter} module.
#+latex: \glsadd{clip}
#+name: filterEg
#+caption: Apply an envelope to the filter frequency.
#+begin_src {} -i
~feg = { |gt = 0|
   EnvGen.kr(Env([1, 4, 1], [0.01, 0.15], -4), gt)
};

~filter = { |ffreq = 2000, rq = 0.2|
   RLPF.ar(~oscil.ar,
      clip(ffreq * ~feg, 20, 20000),
      rq
   )
};

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src

*** Notes on that example
**** Filter envelope as a multiplier.
     - The envelope /modulates/ the set filter frequency. You get
       articulation /and/ independent timbre control.
     - \cd{ffreq * \textasciitilde feg} may go outside the valid
       frequency range. \mth{clip} it for safety.
       - \mth{clip} moves out-of-range values to the nearest boundary.
       - Filters tend to blow up if the frequency goes out of range.
**** \cd{p.setEvent} treats the control inputs globally.
     - \cd{gt: 1} in the event sets \ci{gt} in both envelope modules
       simultaneously.

*** Articulation: Noise oscillator with envelope
**** With envelopes, we can use a noise generator.
     - A classic analog synthesizer trick for a "chff" in the attack.
     - Add a short, percussive (\cd{Env.perc}) burst of noise.
     - Usually use a \clss{BPF} to color the noise.
**** Typical noise generators
     - \ugen{WhiteNoise} :: Very bright, harsh noise.
     - \ugen{PinkNoise} :: Still bright, but more pleasant than white noise.
     - \ugen{BrownNoise} :: Darker sound. Named after \egls{Brownian motion}, not the color.

*** Add a noise attack to the previous example
    Based on Listing [[filterEg]].
#+name: noiseAtk
#+caption: Create a noise generator, and an envelope and filter for it.
#+begin_src {} -i
~noiseEg = { |gt, noiseDur = 0.08|
   EnvGen.kr(Env.perc(0.01, noiseDur), gt)
};
~noise = { |noiseAmp = 0.8|
   PinkNoise.ar(noiseAmp * ~noiseEg)
};
~noiseFilt = { |ffreq = 11000, rq = 0.34|
   BPF.ar(~noise.ar, ffreq, rq).dup
};
~noiseFilt.play;

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
**** You can also add an envelope to the \ugen{BPF} frequency.
     Exercise for you.
**** Settings for a BPF frequency envelope			   :noexport:
ffreq = 2300
~noiseFeg = { |gt|
   EnvGen.kr(Env.perc(0.01, 0.2), gt)
   .linexp(0, 1, 1, 4)
};

*** Note control summary: Envelopes
**** \eGls{breakpoint} \eglspl{envelope}
     - Idea: Start level, list of segments
     - Written in \clss{Env} using three arrays: \ci{levels}, \ci{times}, \ci{curve}
**** \eGls{envelope generator}
     - Renders the segments into a signal.
     - Responds to \eglspl{trigger} and \eglspl{gate}.
**** Triggers and gates: signal > 0
     - A \te{trigger} is instantaneous, when the signal becomes > 0.
     - A \te{gate} is open when > 0, closed otherwise.

*** Note control summary: Gates and Events
**** \eGlspl{gate} must be opened and closed.
     - By hand, using \cd{\textasciitilde something.set(\textbackslash gt, 1)} or \cd{0}.
     - An \clss{Event} can close the gate for you, after a given \ci{sustain} time.
       - \ci{sustain} can be given directly, or you can provide \ci{dur} and \ci{legato}.
**** Events can set many parameters at once.
     Very useful for sequencing: The start of a note can change pitch,
     amplitude, timbre controls all at once.

* Effects common in subtractive synthesis 			   :noexport:
** Chorus
** Distortion
