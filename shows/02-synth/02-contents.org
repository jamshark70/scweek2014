#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Events and Sequencing						   :noexport:
** Events and synthesis control
*** What are Events?
**** \clsspl{Event} represent a pre-defined action.
     Two main features:
     - Storage :: Events hold information under names that you choose.
     - Play-ability :: \mth{play} an \clss{Event} to fire the action.
**** They make the musical /information/ more important.
     - Yesterday's \clsspl{Task} combined /data/ and /action/ into one
       code block.\\
       If the \clss{Task} is written to play notes by \ci{set}-ting
       controls, /it can do nothing else/ without rewriting.  Only one
       way to play notes: \cd{something.set(...)}.
     - With \clsspl{Event}, you can use the same event data for different things.
#        - \Gls{event type} \ci{\textbackslash note} plays it in SC's audio server.
#        - \ci{\textbackslash midi} sends MIDI to hardware or other software.
#        - Two actions, same sequencing code.

*** Playing events
**** An "empty" event can \mth{play}.
#+name: event1
#+caption: The simplest possible event.
#+begin_src {} -i
().play;
#+end_src

**** But look what it prints out:
# Note, this must be a block, to clear the previous name/caption

#+begin_src {} -i
( 'instrument': default, 'msgFunc': a Function, 'amp': 0.1,
  'sustain': 0.8, 'server': localhost, 'isPlaying': true,
  'freq': 261.6255653006, 'hasGate': true, 'id': [ 1000 ] )
#+end_src

**** Where did all that come from?

*** The default event
**** Playing the \clss{Event} uses a large set of \eglspl{default}.
     - \Gls{event type} :: \ci{\textbackslash note}
     - SynthDef :: \ci{\textbackslash instrument} = \ci{\textbackslash default}.\\<all>
		   The default \clss{SynthDef} is defined for you.
     - Pitch :: \ci{\textbackslash freq} = 440 Hz (calculated from other defaults).
     - Length :: \ci{\textbackslash sustain} = 0.8 seconds (calculated).
     - Volume :: \ci{\textbackslash amp} = 0.1 (calculated from -20 dB).
     - Pan :: \ci{\textbackslash pan} = 0 (center).
#+name: eventDefaults
#+caption: Print a list of events of default values.
#+begin_src {} -i
Event.default.parent.postSorted; ""
#+end_src
A little trick: Add an empty string after printing a collection, for cleaner output.

*** Writing your own events
**** \clsspl{Event} are written as /key/value/ pairs.
     - This comes from the parent class, \clss{Dictionary}.
     - \clss{Event} has a short syntax: \cd{(key: value, ...)}.
       - (Written differently in \clss{Dictionary}.)
#+name: event2
#+caption: Put your own values into events, and play them.
#+begin_src {} -i
(freq: 330, amp: 0.5, sustain: 2, pan: 0.5).play;
#+end_src

*** Automatic calculations in events: Time
**** Time information lives at two levels:
     - Basic level
       - \mth{delta} :: Same as wait-time in a \clss{Task}.
       - \ci{sustain} :: How long to hold an envelope's \gls{gate} open.
     - Higher level
       - \ci{dur} :: Wait time. \ci{dur = delta * stretch}.
       - \ci{legato} :: Proportion of dur to hold the gate open. < 1 leaves space between notes (staccato); > 1 makes notes overlap.
       - \ci{stretch} :: Multiplies all time values. Can make a sequence play faster or slower.
#+name: event2
#+caption: Sustain is calculated automatically from "dur" and "legato."
#+begin_src {} -i
(freq: 330, amp: 0.5, dur: 3, legato: 0.5).play;
#+end_src

*** Automatic calculations in events: Pitch
**** Pitch information lives at /several/ levels:
#      The most important are:
     - \ci{freq} :: Note frequency, in Hz.
     - \ci{midinote} :: MIDI note number. 60 = middle C, about 261 Hz.
     - \ci{degree} :: A diatonic scale degree. Depends on:
       - \ci{scale}: The whole/half-step pattern for the scale. See the \clss{Scale} class.
       - \ci{root}: The \egls{pitch class} of the tonic note. 0 = C.
       - \ci{octave}: An octave number. 5 is the octave from middle C to the B above.
#+name: event3
#+caption: Different ways of writing pitch.
#+begin_src {} -i
(freq: [220, 275, 330]).play;
(midinote: [57, 61, 64], sustain: 1.5).play;
(degree: [0, 2, 4], root: 9, octave: 4, sustain: 1.5).play;

(degree: [0, 2, 4], root: 9, octave: 4,
   scale: Scale.minor, sustain: 1.5).play;
#+end_src

*** Details on Event parameters and calculations
    See the following help files for documentation on \clss{Event} parameters.
    - /Pattern Guide 07: Value Conversions/\\<all>
      [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_07_Value_Conversions.html][Web link]]
    - /Pattern Guide 08: Event Types and Parameters/\\<all>
      [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters.html][Web link]]

*** What are the example events actually doing?
**** The default \ci{\textbackslash note} \gls{event type} plays and releases a synth.
     1. Calculate time and pitch values.
     2. Send messages to the server to create new synth nodes.
     3. /If/ the \clss{SynthDef} has a \mth{gate} argument, schedule
        release messages to be sent \ci{\textasciitilde sustain} beats
        later.
**** This event type is designed for "canonical" style.
     - We are using \clss{ProxySpace} in a specific way, for modular synthesis.
     - So we need another way.

*** Event types
**** Common \glspl{event type}:
     - \ci{\textbackslash note} :: Play a new \clss{Synth}.
     - \ci{\textbackslash set} :: Set controls in an existing \clss{Synth}.
     - \ci{\textbackslash off} :: Release an existing \clss{Synth}.
     - \ci{\textbackslash midi} :: Send note or control data to a hardware MIDI device.
**** Event types let you change the action without changing the data.
     - You can write a \ci{\textbackslash note} pattern, and hear the notes in scsynth.
     - Or, change to the \ci{\textbackslash midi} type and hear the notes from a hardware synth.

*** ProxySpace "setEvent" method
    - Calling \mth{setEvent} on a \clss{ProxySpace} prepares an \clss{Event} to set controls within that ProxySpace.
    - Provide an event as an argument, with the values you want to set.
    - \ci{gt} arguments will be closed automatically after \ci{sustain} beats.
#+name: gateEvent
#+caption: Hold a gate open for a given amount of time using an Event.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~out = { |freq = 440, width = 0.5, gt|
   var eg = EnvGen.kr(Env.adsr, gt);
   (VarSaw.ar(freq, 0, width) * eg * 0.1).dup
};
~out.play;

p.setEvent((freq: exprand(200, 400), sustain: 0.5)).play;
p.setEvent((freq: exprand(200, 400), sustain: 3)).play;
#+end_src

*** Event summary
**** With \clsspl{Event}, we can:
     - Write musical information without worrying about server details.
     - Write pitches three ways:
       - Frequency (Hz);
       - MIDI note numbers (chromatic);
       - Scale degrees (diatonic---major, minor etc.).
     - Control gated envelopes with one command.
**** What do we need for sequencing?
     - An easy way to fill events from streams.
     - Rhythm control directly from the events.

** Patterns and Events
*** Patterns make Events very easily
**** An \clss{Event} is a set of named values.
     - Each value's name says how the value will be used for synthesis.
**** A pattern called \clss{Pbind} is a list of /named patterns/.
     - Every \mth{next} value collects one value from each child pattern.
     - \mth{next} needs an empty \clss{Event} as a container for the new values.
#+name: pbind1
#+caption: Pbind collects child patterns' return values under given names.
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;

p.next(Event.new);
#+end_src

*** What does Pbind actually do?
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;
#+end_src
    1. Associate names with patterns:
       - \ci{\textbackslash freq} will be random between 100 and 400.
       - \ci{\textbackslash dur} will be a random multiple of 0.125.
    2. Automatically make streams from those patterns.
    3. Go through the pairs /in order/:
       - Get a value from that name's stream.
       - Add the value into the input \clss{Event}.

*** DebugPbind: Watch the event get filled
**** In Listing [[pbind1]], change \clss{Pbind} to \clss{DebugPbind}.
     Now you can read exactly what's going on.
     1. Start with an empty event.
     2. \ci{\textbackslash freq} gets the random value, e.g. 133.25.
     3. The empty event becomes \cd{(freq: 133.25)}.
     4. \ci{\textbackslash dur} gets 0.125.
     5. The final event has both values, with the right names.
#+begin_src {} -i
Source event: (  )
stream ID: freq
Event going in: (  )
streamout: 133.24577125341
stream ID: dur
Event going in: ( 'freq': 133.24577125341 )
streamout: 0.125
Result event: ( 'dur': 0.125, 'freq': 133.24577125341 )
#+end_src

*** Events and timing
**** In a \clss{Routine}/\clss{Task}, we \mth{wait} until the next event.
     This happens automatically in an Event Pattern.
     - Events can calculate a \gls{delta} time.
     - Then, we just need something that will play the event and wait
       the right amount of time.
**** This is \clss{EventStreamPlayer}.
     - If you call \mth{play} on a pattern, it makes an \clss{EventStreamPlayer}.
     - Each event has a \egls{delta} time, given directly or
       calculated from \cd{dur}.
       - \cd{delta = dur * stretch}
     - Each event is \mth{play}ed. Then the \clss{EventStreamPlayer}
       waits, for the event's \egls{delta} time.

*** "Canonical" Pbind example
**** Using \clss{Pbind} to play default synths, the "canonical" way.
     Note what happens with \ci{legato}.
     - Some notes are short.
     - Other notes hold over, into the next note.
#+name: pbind2
#+caption: A "canonical" Pbind, playing notes in the default SynthDef.
#+begin_src {} -i
a = Pbind(
   \degree, Pwhite(-7, 7, inf),
   \dur, Pwhite(1, 4, inf) * 0.125,
   \legato, Prand([0.5, 2], inf)
).play;

a.stop;
#+end_src

*** Notes on previous example				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
This has a somewhat complex flow, wrapped up in a simple expression. It divides into these parts:

- *\clss{EventStreamPlayer} control of rhythm and event-playing.*\\<all>
  In a loop:
  1. Get an \clss{Event} from the \clss{Pbind}'s stream.
  2. Play the event.
  3. Ask the event for its \mth{delta} time, and \mth{wait} for that duration.

- *\clss{Pbind} evaluation of events.*\\<all>
  Every time the \clss{EventStreamPlayer} asks for an event, loop through the key/pattern pairs:
  1. Get a value from the child pattern's stream.
  2. Put the value into the event, using the pattern's key.
  At the end of this, the event will have a value for every key.

- *The event's action, triggered by \mth{play}.*\\<all>
  Takes action, according to the \egls{event type}.

*** Patterns: "Declarative" programming
**** \eGlspl{Routine} and \glspl{Task} are \egls{imperative}-style programming.
     - They say: "Do this, then that."
       - Set the trigger and the frequency.
       - Wait 0.5 beats.
**** \eGlspl{pattern} are more like \egls{declarative} programming.
     - Listing [[pbind2]] says:
       - I want \ci{\textbackslash degree} to be like this.
       - I want \ci{\textbackslash dur} to be like that.
       - Go do it.
# **** The two examples /do/ the same thing, but write it differently.

*** Pbind in ProxySpace
**** We need something like \cd{p.setEvent} for patterns.
     Some \clss{ProxySpace} tricks:
     - You can use a \clss{Pbind} in \clss{ProxySpace}, just like a synthesis function.
     - The pattern's synths will belong to the resulting \clss{NodeProxy}.
     - You can change the way the \clss{NodeProxy} behaves with a modifier:\\
       \cd{\textasciitilde name = \textbackslash modifier -> thing;}, where \cd{thing} is the function or pattern.
     - The \cd{\textbackslash psSet} modifier makes every event from
       the pattern act like \cd{p.setEvent}.

*** \textbackslash psSet pattern example
# **** Main point: This is easy.
#      - There are a lot of concepts behind this example.
#      - But using it---playing notes automatically---is convenient.
#+name: rVsPbind
#+caption: A Pbind, controlling NodeProxies in a ProxySpace.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pexprand(110, 440, inf),
   \dur, 0.5
);

~player.clear;
#+end_src
**** *Note:* \ci{\textasciitilde player} is now a \clss{NodeProxy}.
     - Just like \ci{\textasciitilde out} in Listing [[gateEvent]].
     - You can change the synthesis function any time.
     - Likewise, you can change \ci{\textasciitilde player}'s pattern anytime!\\
       Just assign a new pattern (with \ci{\textbackslash psSet}).

*** Pbind summary
**** \clss{Pbind} unifies everything you need for sequencing.
     - Note data come from value \glspl{pattern}.
     - The data go into an \clss{Event}.
     - The event turns the data into action.
     - The event also tells the \clss{EventStreamPlayer} how long to wait.
**** To control modular synthesis by Pbind, use the \cd{\textbackslash psSet} modifier.
     - Within a \clss{ProxySpace}:\\<all>
       \cd{\textasciitilde name = \textbackslash psSet -> Pbind(...);}.
**** Now we can run lots of notes while playing with synthesis techniques.

*** Exercises: Different pitch and rhythm patterns
**** Change the pattern from Listing [[rVsPbind]]:
     *Note:* You may use \clss{Pdefn}.
     1. Choose notes from the C major scale.
     2. Choose C major notes, but favor C, E and G.\\
	Hint: Use \clss{Pwrand}. Check its help file for details.
     3. Make it E major (change the \ci{\textbackslash root}).
     4. Try \clss{Pwhite} for rhythm (with fractional low/high).\\
	Then try \clss{Pexprand}. How would you describe the difference?
     5. With \ci{\textbackslash psSet}, what's the difference between
        \ci{\textbackslash legato} < 1 and > 1?

* Subtractive synthesis						   :noexport:
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens							   :noexport:
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** addSpec and argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an \egls{exponential} curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: \eGls{exponential}.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[../02-synth/img/three-waves2.png]]
   #+end_center
\\ *Note:* Band-limited triangle oscillators may be found in the
sc3-plugins package.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%).\\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     - Human players are never exactly in tune.
     - We can do the same in a synth.
#+name: detune
#+caption: Detuning: Make several oscillators and mix (add) them.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   0.1 * (
      Saw.ar(freq) + Saw.ar(freq * detun) + Saw.ar(freq / detun)
   ).dup
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Detuning, explained
#+begin_src {} -i
      Saw.ar(freq)
      + Saw.ar(freq * detun)
      + Saw.ar(freq / detun)
#+end_src
**** Detuning involves several oscillators, out of tune.
     We have three:
     - Original frequency;
     - /Up/ by a small interval (assuming \cd{detun > 1});
     - /Down/ by the same small interval.
**** Add the oscillators to make a combined signal.
     The almost-exact frequencies create changes in the spectrum.

*** An easier way
**** What if you want more oscillators?
     - Inconvenient to write \ci{+} for every one.
**** Solution: \ugen{Mix} with an array.
     - Write the oscillators into an array.
     - \ugen{Mix} will find the most efficient way to add them.
#+name: detune2
#+caption: Mix an array of oscillators, instead of explicitly adding them.
#+begin_src {} -i
~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix([
      Saw.ar(freq),
      Saw.ar(freq * detun),
      Saw.ar(freq / detun)
   ])).dup
};
#+end_src

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}.\\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** That's not easy enough
**** \eGls{multichannel expansion} can make it easier.
     - Most UGens are monophonic: one channel in, one out.
     - Here, we provide an array of three frequencies.
**** How can a monophonic UGen do that?
     - It performs \egls{multichannel expansion}, and makes three \ugen{Saw}s.
     - The \ugen{Saw}s are in an array, which we can give to \ugen{Mix}.
#+name: mc-exp1
#+caption: Multichannel expansion: An array of frequencies turns into an array of oscillators.
#+begin_src {} -i
Saw.ar([1, 2, 3]);  // prints: [ a Saw, a Saw, a Saw ]

~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix(
      Saw.ar([freq, freq * detun, freq / detun])
   )).dup
};
#+end_src

*** One further step
    - It isn't even necessary to write \ci{freq} every time.
    - You can multiply \ci{freq} by an array of factors.
    - Small problem: If the operator is \ci{*}, how to do \ci{/}?\\<all>
      Get the \mth{reciprocal} of \ci{detun}.
#+name: detune4
#+caption: Mix an array of oscillators, instead of explicitly adding them.
#+begin_src {} -i
~oscil = { |freq = 220, detun = 1.003|
   (0.1 * Mix(
      Saw.ar(freq * [1, detun, detun.reciprocal])
   )).dup
};
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_src {} -i
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_src

*** Notes on MC expansion				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Multichannel expansion is super cool.
Parallel processing of multiple channels is very common. For example,
if you're playing a one-channel sound file, you would need
\ugen{PlayBuf} $\to$ amplifier \ci{*} $\to$ output. For a stereo file,
you need /two/ channels from \ugen{PlayBuf} and two amplifiers.

In Max/MSP, you would have to create each of the 
\cd{[*\textasciitilde ]} amplifiers by hand. Adding or removing a channel can force you to
make cascading changes through large sections of the patch.

In SuperCollider, the difference is merely:

- One channel: \cd{PlayBuf.ar(1, ...) * amp}.
- Two channels: \cd{PlayBuf.ar(2, ...) * amp}.

In the second case, \cd{PlayBuf.ar} gives you an array of two
signals. This automatically expands the \ci{*} operator: @@latex:\cd{[left,
right] * amp} = \cd{[left * amp, right * amp]}@@. You could even go up
to large multichannel diffusion systems, and amplify all the channels
at once in exactly the same way.

Even for ordinary synthesis: Because multichannel processing is more
convenient in SC, you'll do more of it and get more interesting sounds
for less work.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[../02-synth/img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}:\\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses \ci{rq} = $\frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.

*** Next step: Modulation
**** That's pretty much it for subtractive synthesis.
     - Multiple oscillators, slightly detuned and with different octave relationships.
     - Different types of filters.
**** The power comes from \egls{modulation}.
     - Modulation means that the parameters are not constant.
     - We'll talk about that next.

* Modulation: Low-Frequency Oscillators				   :noexport:
** Modulation: Low-Frequency Oscillators
*** Modulation
**** Little secret: Synthesis techniques are sometimes /really simple/.
     We just beef them up with /layering/ and \egls{modulation}.
**** Modulate a parameter by another signal.
     - We can use envelopes for this.
     - Another modulation source: \eglspl{LFO} (Low-Frequency Oscillators)
     - SC has a /lot/ of them.
**** For this section:
     - Introduce LFO shapes and mechanism
     - Talk about signal ranges

*** LFO + filter
**** Start with an earlier synth, slightly modified.
#+name: scifi1
#+caption: Basic detuned synth.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 120|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 2000, rq = 0.08|
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
~filter.play;

~filter.addSpec(\ffreq, \freq);
~filter.addSpec(\rq, [1, 0.02, \exp]);
p.gui;
#+end_src

*** Add an LFO: sci-fi heaven
**** Same pattern as before:
     - Add a new module (\ci{\textasciitilde filtlfo}). This is a slowly-changing signal.
     - Use it in the filter (@@latex:\cd{ffreq + \textasciitilde
       filtlfo}@@). Adding it to the basic filter frequency means that
       the actual filter cutoff goes slowly above and below the set
       frequency.
#+name: scifi2
#+caption: Add an LFO to the filter.
#+begin_src {} -i
~lfreq = 1; ~lfreq.addSpec(\value0, [0.5, 18, \exp]);
~depth = 100; ~depth.addSpec(\value0, [0, 1000]);
~filtlfo = { SinOsc.kr(~lfreq) * ~depth };

~filter = { |ffreq = 2000, rq = 0.08|
   ffreq = (ffreq + ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};
#+end_src

*** LFO shape
**** Many common LFO shapes exist.
     This one is a simple sinewave (\clss{SinOsc}).\\
     Audio UGens may often be used for control signals.
**** Try some other shapes.
     What do they sound like?
#+latex: \glsadd{LFPulse}\glsadd{LFTri}\glsadd{LFSaw}
#+name: lfoshapes
#+caption: Play with some other common LFO shapes.
#+begin_src {} -i
~filtlfo = { LFPulse.kr(~lfreq) * ~depth };
~filtlfo = { LFTri.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth };
~filtlfo = { LFSaw.kr(~lfreq) * ~depth.neg };
~filtlfo = { LFNoise0.kr(~lfreq) * ~depth };
#+end_src
     - \ugen{LFNoise0} is like a standard synthesizer LFO called \egls{sample-and-hold}.

*** Uncommon LFO shapes
# **** SC goes further than the standard shapes.
    - Single-shot lines (\ugen{Line}, \ugen{XLine}).
    - Ramps (\ugen{LFNoise1}) and curves (\ugen{LFNoise2}) between random numbers.
    - Various functions from mathematics:
      - Gaussian (bell-curve) wave
      - Many, many \egls{chaotic} generators. 
#+latex: \glsadd{LFGauss}\glsadd{LinCongL}\glsadd{QuadL}
#+name: lfoshapes2
#+caption: LFO shapes not commonly found in other software.
#+begin_src {} -i
~filtlfo = { LFNoise1.kr(~lfreq) * ~depth };
~filtlfo = { LFNoise2.kr(~lfreq) * ~depth };
~filtlfo = { LFGauss.ar(~lfreq) * ~depth };

// chaotic
~filtlfo = { LinCongL.ar(~lfreq, 1.2, 0.08) * ~depth };
~filtlfo = { QuadL.ar(~lfreq) * ~depth };
#+end_src

** Range mapping for modulation
*** Modulation: All about signal ranges
**** Remember the key questions from before:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Modulation range for frequency
**** Frequency needs a wider range of variation.
     - Suppose the base frequency is 440.
     - If the modulator's range is $-1$ to $1$, the frequency will vary between 439 and 441.
     - That's $\frac{1}{440}=$ 0.23\%. The ear can't tell that it's changing!
**** You need to expand the range.
     That's the purpose of the \ci{\textasciitilde depth} module.

*** mul, add
**** Almost all UGens have \ci{mul} and \ci{add} arguments.
     - @@latex:\cd{SinOsc.ar(440, 0, 100, 440)} $\to$\\
       \cd{SinOsc.ar(440, 0) * 100 + 440}.@@
     - Converts the normal output range $-1$ to $1$ into 340 to 540.
     - If \ci{add} is 0, \ci{mul} acts like an amplifier.
**** In the previous LFO example:
#+attr_latex: :align |c|c|
|------------------------------------+----------------------|
| *Operation*                        | *Range*              |
|------------------------------------+----------------------|
| \ugen{SinOsc}                      | Bipolar: $-1$ to $1$ |
|------------------------------------+----------------------|
| \cd{* \textasciitilde depth} ($d$) | $-d$ to $d$          |
|------------------------------------+----------------------|
| \cd{+ ffreq} ($f$)                 | $f-d$ to $f+d$       |
|------------------------------------+----------------------|

*** Range mapping methods
**** All UGens have two methods to make it easier:
     - \cd{UGen.ar(...).range(low, high)}: \eGls{linear} mapping.
     - \cd{UGen.ar(...).exprange(low, high)}: \eGls{exponential} mapping.
#+latex: \glsadd{range}\glsadd{exprange}
**** Also, methods that are good for numbers as well as UGens:
Arguments: inMin, inMax, outMin, outMax, clip.
     - \mth{linlin} :: \eGls{linear} input, \egls{linear} output.
     - \mth{linexp} :: \eGls{linear} input, \egls{exponential} output.
     - \mth{explin} :: \eGls{exponential} input, \egls{linear} output.
     - \mth{lincurve} :: \eGls{linear} input, \te{curved} output. (Extra argument for the curve factor.)
     - \mth{curvelin} :: \te{Curved} input, \egls{linear} output.

*** What is "exponential"?
**** \eGls{exponential} means using multiplication in place of addition.
     - Every octave up means multiplying by 2.
     - Start at 55 Hz, octaves are 55, 110, 220, 440, 880.
     - \cd{0.5.linlin(0, 1, 55, 880)} is 467.5.\\
       Halfway between 55 and 880, but it isn't the /octave/.
     - \cd{0.5.linexp(0, 1, 55, 880)} is 220.
#+name: linExpPlot
#+caption: Plot a line covering four octaves of frequency, first linearly, second exponentially.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);  // out: 0.0-1.0
   [
      // in range: 0-1; out range: 55-880
      line.linlin(0, 1, 55, 880),
      line.linexp(0, 1, 55, 880)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** What is "curved"?
**** \te{Curved} mappings let you control the amount of curve.
     - If \ci{curve} is 0, you get a straight line.
     - A negative curve "pulls" the line to the left.
     - A positive curve pulls it to the right.
     - The larger the number, the more extreme the curve.
#+name: linCurvePlot
#+caption: Plot a line covering four octaves of frequency with different curve factors.
#+begin_src {} -i
{
   var line = Line.ar(0, 1, 0.01);
   [
      line.lincurve(0, 1, 55, 880, -6),
      line.lincurve(0, 1, 55, 880, -2),
      line.lincurve(0, 1, 55, 880, 4)
   ]
}.plot(minval: 50, maxval: 900);
#+end_src

*** Exponential modulation for frequency
**** Earlier, we used \ci{+} to modulate frequency.
     Using the \mth{cpsmidi} method, we can get MIDI note numbers, and
     see how many semitones between given frequencies.
     - Assuming the base frequency is 2000 and the depth is 1000:
#+latex: \glsadd{round}\glsadd{differentiate}
#+name: expscale
#+caption: Convert modulation ranges for frequency into intervals.
#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.round(0.01);
// prints: [ 83.21, 95.21, 102.23 ]

[1000, 2000, 3000].cpsmidi.differentiate.round(0.01);
// prints: [ 83.21, 12, 7.02 ]

[2000 / 1.5, 2000, 2000 * 1.5].cpsmidi.differentiate.round(0.01);
// prints: [ 88.19, 7.02, 7.02 ]
#+end_src

*** Note: Differentiate					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Listing [[expscale]] illustrates how we can use arrays to do the same
operation repeatedly. To get the interval (number of semitones)
between two frequencies, we subtract the higher frequency's MIDI note
number from the same for the lower frequency. Here, we have three
frequencies---let's call them $f_0$, $f_1$ and $f_2$---and we want the
results $f_1 - f_0$ and $f_2 - f_1$. That's what \mth{differentiate}
does: it makes a new array where each item is the difference between
two of the original items that are right next to each other.

It also copies the first item. This is so that you can reconstruct the
original array using \mth{integrate}. We aren't interested in the
first item, so we can ignore it. If you need to get rid of the first
item, use \mth{drop}:

#+begin_src {} -i
[1000, 2000, 3000].cpsmidi.differentiate.drop(1).round(0.01);
// prints: [ 12, 7.02 ]
#+end_src

*** How to make the intervals match?
    - The linear way uses inverse math operators: $+$ and $-$.\\
      But $-$ by the same amount produces a larger interval than $+$.
    - The exponential way also uses inverses: $\times$ and $\div$.\\
      Multiplying and dividing by the same amount produces the same interval.
#+attr_latex: :align |c|c|c|c|c|
|-------------+--------------------------+----------------------------|
| *Mapping*   | *Low*                    | *High*                     |
|-------------+--------------------------+----------------------------|
| Linear      | $2000-1000=1000$: P8     | $2000+1000=3000$: P5       |
|-------------+--------------------------+----------------------------|
| Exponential | $2000 \div 1.5=1500$: P5 | $2000 \times 1.5=3000$: P5 |
|-------------+--------------------------+----------------------------|
**** So:
     For frequency, the depth should be a multiplier.

*** Thought process
**** /Thinking/ about the UGen ranges.
     - The range I've got: $-1$ to $1$. \pause
     - The range I need is \egls{exponential}: Use \mth{exprange}. \pause
     - A balanced \egls{linear} range is $-d$ to $d$.\\
       - Lower bound = negative (\mth{neg}) of upper bound.
       - Center = 0. \pause
     - A balanced \egls{exponential} range is $\frac{1}{d}$ to $d$.
       - Lower bound = \mth{reciprocal} of upper bound.
       - Center = 1. \pause
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.

*** Converting the LFO to multiplication			   :noexport:
**** Give \ci{depth} in terms of a /multiplier/.
     - It's more natural to think of depth 0 meaning no modulation.
     - The multiplier should center around 1.
     - So we will add 1 to get the range.
**** Convert the LFO's \egls{linear} signal into an \egls{exponential} range.
     - The \mth{exprange} method does this automatically.
     - The lower bound should be $\frac{1}{depth}$; upper, $depth$.

*** Exponentially-scaled modulator: Code
**** *Note:* You will probably have to close the GUI window and re-create it using \cd{p.gui}.
#+latex: \glsadd{reciprocal}
#+name: explfo
#+caption: Replace the linear-scale LFO with an exponential-scale LFO.
#+begin_src {} -i
~filtlfo = {
   var depth = ~depth + 1;  // Add 1
   // Use reciprocal and exprange
   SinOsc.kr(~lfreq).exprange(depth.reciprocal, depth)
};

~filter = { |ffreq = 2000, rq = 0.08|
   // Multiply by the LFO, not add
   ffreq = (ffreq * ~filtlfo).clip(20, 20000);
   RLPF.ar(~oscil.ar, ffreq, rq, 0.1).dup;
};

~lfreq.addSpec(\lfreq, [0.5, 18, \exp]);
~depth.addSpec(\depth, [0, 4]);
#+end_src

*** Note on efficiency					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** A note on efficiency:
The above example calculates \cd{\textasciitilde depth + 1}, saves it
in a variable, and then uses the variable in \mth{exprange}. Why?

If it were written @@latex:\cd{.exprange((\textasciitilde depth +
1).reciprocal, \textasciitilde depth + 1)}@@, the server would
calculate \cd{\textasciitilde depth + 1} /twice/. There are two
\cd{+ 1} operations, and it's too difficult for the \gls{SynthDef} builder
to identify that both will have the same result.

As written above, there is one addition, and the result is used twice.

The equivalent in Pure Data shows the difference graphically.

#+begin_center
#+attr_latex: :height 1.1in
[[../02-synth/img/pd-save-an-add.png]]
#+end_center

*Tip:* Whenever you need to use a signal in more than one place in a
synthesis function, assign it to a variable.
- "Calculate once, use many times" is more efficient.
- The variable name can remind you of the signal's purpose.

*** Modulation summary
**** For effective modulation:
     The key is to think about:
     - The expected range of the /modulated/ input;
     - How to convert a UGen's range to match.
**** This applies to all kinds of LFOs.
     - Oscillators
     - Sample players (at slow playback rates).
     - Envelopes (next...).

** Another envelope use: Articulation
*** Envelopes for articulation
**** Envelopes can control any parameter.
     /Very/ common: control the filter frequency, for articulation.
     - Create a new \ugen{EnvGen}, as a multiplier for \ci{ffreq}.
     - Use it in the \ci{\textasciitilde filter} module.
#+latex: \glsadd{clip}
#+name: filterEg
#+caption: Apply an envelope to the filter frequency.
#+begin_src {} -i
~feg = { |gt = 0|
   EnvGen.kr(Env([1, 4, 1], [0.01, 0.15], -4), gt)
};

~filter = { |ffreq = 2000, rq = 0.2|
   RLPF.ar(~oscil.ar,
      clip(ffreq * ~feg, 20, 20000),
      rq
   )
};

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src

*** Notes on that example
**** Filter envelope as a multiplier.
     - The envelope /modulates/ the set filter frequency. You get
       articulation /and/ independent timbre control.
     - \cd{ffreq * \textasciitilde feg} may go outside the valid
       frequency range. \mth{clip} it for safety.
       - \mth{clip} moves out-of-range values to the nearest boundary.
       - Filters tend to blow up if the frequency goes out of range.
**** \cd{p.setEvent} treats the control inputs globally.
     - \cd{gt: 1} in the event sets \ci{gt} in both envelope modules
       simultaneously.

*** Articulation: Noise oscillator with envelope
**** With envelopes, we can use a noise generator.
     - A classic analog synthesizer trick for a "chff" in the attack.
     - Add a short, percussive (\cd{Env.perc}) burst of noise.
     - Usually use a \clss{BPF} to color the noise.
**** Typical noise generators
     - \ugen{WhiteNoise} :: Very bright, harsh noise.
     - \ugen{PinkNoise} :: Still bright, but more pleasant than white noise.
     - \ugen{BrownNoise} :: Darker sound. Named after \egls{Brownian motion}, not the color.

*** Add a noise attack to the previous example
    Based on Listing [[filterEg]].
#+name: noiseAtk
#+caption: Create a noise generator, and an envelope and filter for it.
#+begin_src {} -i
~noiseEg = { |gt, noiseDur = 0.08|
   EnvGen.kr(Env.perc(0.01, noiseDur), gt)
};
~noise = { |noiseAmp = 0.8|
   PinkNoise.ar(noiseAmp * ~noiseEg)
};
~noiseFilt = { |ffreq = 11000, rq = 0.34|
   BPF.ar(~noise.ar, ffreq, rq).dup
};
~noiseFilt.play;

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
**** You can also add an envelope to the \ugen{BPF} frequency.
     Exercise for you.
**** Settings for a BPF frequency envelope			   :noexport:
ffreq = 2300
~noiseFeg = { |gt|
   EnvGen.kr(Env.perc(0.01, 0.2), gt)
   .linexp(0, 1, 1, 4)
};

*** Exercise: Fingered portamento
    1. Clear the ProxySpace. Then write a modular synth:
       - \ci{\textasciitilde oscil} :: Detuned oscillator.
       - \ci{\textasciitilde ampEg} :: Amplitude envelope.
       - \ci{\textasciitilde filtEg} :: Filter frequency envelope.
       - \ci{\textasciitilde filter} :: Resonant lowpass filter and main output.
    2. Write a \ci{\textbackslash psSet} pattern to play notes.
       - Use \ci{\textbackslash legato} so that some notes slur, but not all.
    3. The pitches don't slide. Look up \ugen{Lag}'s help file, and
       apply it to the oscillator's frequency.

* Frequency modulation (FM) synthesis				   :noexport:
** John Chowning's experiment
*** John Chowning's discovery of FM
**** Let's replicate a famous 1967 experiment by John Chowning.
     - We will /modulate/ \glsadd{modulation}a sinewave's frequency by another sinewave.
     - This led to the discovery of \egls{frequency modulation} (FM) synthesis.
**** Terms
     - \egls{modulator} :: The signal controlling the modulation.
     - \egls{carrier} :: The output signal, subject to the modulation.
     - \egls{modulation index} :: The amount of modulation.

*** The FM experiment: Code
#+name: fm1
#+caption: The first FM synthesis experiment, translated to SuperCollider.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;

~freq = 440;

~modulator.addSpec(\mod_freq, [1, 880, \exp]);
~modulator.addSpec(\mod_index, [0, 5, 2]);
~modulator = { |mod_freq = 5, mod_index = 0|
   SinOsc.ar(mod_freq, 0, mod_index);
};

~carrier = { |amp = 0.1|
   SinOsc.ar(~freq * (~modulator.ar + 1), 0, amp).dup
};
~carrier.play;
#+end_src

*** The experiment
    1. To hear the modulation, raise the \ci{mod\textunderscore index}.
    2. Now, slowly, bring up \ci{mod\textunderscore freq}.\\
       What happens when you can't hear individual frequency sweeps anymore? \pause
**** The sound's \egls{spectrum} changes!
     General observations you can make:
     - What's the effect of raising or lowering the modulation index?
     - What happens when the modulator's frequency is an exact multiple of the carrier frequency?

*** Note on linear vs. exponential			    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
You might recall from the discussion of \glspl{LFO} that frequency is
an exponential scale. But, in Listing [[fm1]], we are adding the modulator
signal to the frequency, instead of multiplying. This is important to
the way FM synthesis works. As written above, when the modulation
index is > 1, the carrier frequency will sometimes be negative. The
distortion of the waveshape that comes from the negative frequency is
part of the distinctive color of FM synthesis.

In fact, if you rewrite Listing [[fm1]] to convert the modulator into an
exponential range and multiply directly by the modulator (not the
modulator + 1 as above), you'll find that it pushes the perceived
pitch higher.

A variant on frequency modulation, called \egls{phase modulation}
avoids this problem of frequency deviation.

*** Modulator frequency
**** Integer multiples of the main frequency produce "harmonic" \glspl{spectrum}.
     - A harmonic spectrum is what we typically call a "musical" sound.
     - This is so important that we usually write the modulator frequency as a /ratio/ (multiplier).
     - Then you get harmonic spectra with ratio = 1, 2, 3 etc.
**** Now you can change \ci{\textasciitilde freq} in the GUI, and the modulator moves with it.
#+name: fm2
#+caption: Convert the modulator to use a frequency ratio instead of a direct frequency.
#+begin_src {} -i
~modulator.addSpec(\ratio, [0.1, 8, 2]);
~modulator = { |ratio = 1, mod_index = 0|
   SinOsc.ar(~freq * ratio, 0, mod_index);
};
#+end_src

** Refining FM synthesis
*** FM synthesis in practice
**** One \gls{modulator}-\gls{carrier} pair is boring.
     Refinements:
     - More modulators and carriers, connected in various arrangements.\\
       Yamaha FM synthesizers called the arrangements "algorithms."
     - Detuning modulators and carriers.
     - More complex waveforms.\\
       Introducing: \egls{wavetable} oscillators.
     - Envelopes and LFOs applied to modulator and carrier parameters.

*** Modulator and carrier layout
**** Lots of room for creativity here.
     Three main techniques:
     1. Stack of modulators.
     2. Multiple carriers, mixed together.
     3. Feedback modulation.
     #+begin_center
     #+attr_latex: :height 1.25in
     [[../02-synth/img/fm-algorithm-chart.pdf]]
     #+end_center
**** All are easy to implement using ProxySpace modules.

*** Stack of modulators
    - First modulator, exactly as in Listing [[fm1]].
    - Second modulator includes the first as a modulation expression.
    - You can keep going three or four deep.
#+name: fm3
#+caption: Add another modulator to the chain.
#+begin_src {} -i
~mod2.addSpec(\ratio, [0.1, 8, 2]);
~mod2.addSpec(\mod_index, [0, 25, 2]);
~mod2 = { |ratio = 2, mod_index = 0|
   SinOsc.ar(~freq * ratio, 0, mod_index);
};
~modulator = { |ratio = 1, mod_index = 0|
   SinOsc.ar(~freq * ratio * (~mod2.ar + 1), 0, mod_index);
};
#+end_src

*** Multiple carriers
**** No code example---this one is pretty simple.
     - The \ci{amp} parameter is important.
     - Controls the balance between different components.

*** Feedback modulation
**** Feedback makes some fantastic ugly noises!
     - For feedback, simply refer to the module that should be fed back:
       \ci{\textasciitilde modulator.ar} in the example.
     - You can also use \ugen{LocalIn} and \ugen{LocalOut}, but this is limited to one module.
     - By reference, you can create longer feedback chains.
     - *Note:* Add a new 0--1 parameter for feedback.
#+name: fm4
#+caption: Feedback modulation.
#+begin_src {} -i
~modulator.addSpec(\feedback, [0, 1]);
~modulator = { |mod_freq = 5, mod_index = 0, feedback = 0|
   SinOsc.ar(mod_freq * ((~modulator.ar * feedback) + 1),
      0, mod_index);
};
#+end_src

*** Detuning, Envelopes and LFOs
**** Detuning the modulator adds richness to the sound.
     - You can add an offset in Hz.
     - Or multiply by a detune factor, like we did before.
**** Envelopes and LFOs
     Very useful trick: \Gls{envelope} on the \gls{modulation index}.
     - As the modulation index goes up, the sound gets brighter.
     - Envelopes can produce lots of shapes and colors for a note's attack.
     - This is one of the best features of FM synthesis.

*** FM exercises
    1. Use envelopes on the carrier and modulator to make a sound like an electric piano.
       - The carrier envelope controls volume.\\
	 What's the volume curve of an electric piano?
       - The modulator envelope controls brightness.\\
	 What's the brightness curve of an electric piano?
    2. Try different modulator frequency ratios.
       - What do different integers sound like?
       - What about non-integers?
       - What happens when the ratio is exactly 0.5?

** Wavetable oscillators
*** Modulating more complex wave shapes
**** Wavetables give you more interesting sound, "for free."
     - Essentially no CPU cost.
**** Steps:
     1. Make the wavetable in a server \clss{Buffer}.\\
	The buffer must be in \egls{wavetable format}.
     2. Provide the buffer number to a wavetable oscillator.\\
	\ugen{Osc} and \ugen{COsc} for now.

*** Wavetable buffers
**** \clsspl{Buffer} hold audio data in the server.
     - Wavetables, audio samples, recordings.
**** Steps for using wavetable buffers:
     1. Allocate memory for the buffer (\mth{alloc}).
	- Put the buffer object in a variable.
	- It's helpful to \mth{free} whatever was in the variable, to avoid leaking memory.
     2. Fill the buffer with a sum of sinewaves:\\
	\mth{sine1}, \mth{sine2}, \mth{sine3}
#+name: wt1
#+caption: A few partials of a sawtooth wave, in a wavetable buffer. Run these statements one by one.
#+begin_src {} -i
b.free;
b = Buffer.alloc(s, 2048, 1);
b.sine1((1 .. 3).reciprocal);
b.plotWavetable;
#+end_src

*** Wavetable oscillators
**** Use wavetable \glspl{oscillator} in place of other oscillators.
     - \ugen{Osc} :: A simple wavetable oscillator.
     - \ugen{COsc} :: A chorusing wavetable oscillator: Two waves at slightly different frequencies.
**** *Note:* \ugen{COsc} is not a good idea for FM synthesis.
     Detuning means that the frequency ratio between \gls{carrier} and \gls{modulator} will no longer be an integer.
#+name: wt2
#+caption: Substitute a wavetable oscillator in the carrier, in place of the earlier SinOsc.
#+begin_src {} -i
~carrier = { |amp = 0.1|
   Osc.ar(b, ~freq * (~modulator.ar + 1), 0, amp).dup
};

// Run these statements alternately, and hear the result.
b.sine1([1]);
b.sine1((1 .. 3).reciprocal);
#+end_src

*** Prefer simpler wavetables
**** For FM synthesis, use simpler waveforms.
     - FM synthesis adds more frequencies to the carrier.
     - If the carrier is already complex, the result may be too noisy.
     - I recommend 3--5 partials at most.
**** Extra partials in the \egls{carrier}.
     Like adding partials to a simple waveform. Good for organ sounds.
**** Extra partials in the \egls{modulator}.
     Oddly, this seems to soften the tone color (make it less harsh).

*** Symmetrical modulator waveform
**** A wavetable for a \gls{modulator} should be /symmetrical/.
     - The modulator controls the \gls{carrier}'s deviation above the central pitch.
     - If the modulator is symmetrical, the deviation is equal, above and below.
     - If it's asymmetrical, the carrier goes further above than below, or vice versa.
       You'll hear a different pitch.
#+latex: \glsadd{sine2}
#+name: wtSymm
#+caption: A plot of symmetrical vs. asymmetrical waveforms. Run the lines one by one.
#+begin_src {} -i
b.sine1((1 .. 3).reciprocal);
b.plotWavetable;

b.sine2([1, 2, 5.5], (1 .. 3).reciprocal);
b.plotWavetable;
#+end_src

*** Notes on symmetry					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
In fact, the spectrum doesn't have to look symmetrical. The only
requirement is that its energy must be equally distributed above and
below 0: mathematically, $\sum_{i=0}^{n-1}{y_i} = 0$.

For example, shifting the \eglspl{phase} of a symmetrical wavetable
produces an asymmetrical graph. But the sum of the samples is
still 0. (It might not be exactly 0 because of floating-point rounding
error, but it will be very close.) If you use this wavetable as a
modulator, the carrier's pitch will not drift.

#+begin_src {} -i
y = Signal.sineFill(512,
	(1..3).reciprocal,
	Array.fill(3, { 2pi.rand })
);

y.plot;  // Looks asymmetrical
y.sum;   // very close to 0
#+end_src

*** Listen to an asymmetrical modulator
**** Two things happen with the asymmetrical \gls{modulator}:
     - The \gls{spectrum} becomes \gls{inharmonic}.
     - The main pitch drifts away from center.
     - To hear the pitch drift, set \ci{mod\textunderscore ratio} to 1.04.
     - The spectrum becomes more \gls{harmonic}.\\
       So, the actual average pitch of the carrier is 4\% higher than given.
#+name: wtSymm2
#+caption: Switch the carrier back to SinOsc, and the modulator to the asymmetrical wavetable.
#+begin_src {} -i
(
~carrier = { |amp = 0.1|
   SinOsc.ar(~freq * (~modulator.ar + 1), 0, amp).dup
};
~modulator = { |ratio = 1, mod_index = 0|
   Osc.ar(b, ~freq * ratio, 0, mod_index);
};
)
#+end_src

*** Asynchronous buffer ops
**** *IMPORTANT:* Buffer operations are not instantaneous!
     - When you allocate or fill a \clss{Buffer}, it will take a little time.
     - You have to wait until it's finished before using the buffer.
     - This is why the earlier examples said to run one statement at a time.
**** In bigger code blocks, \mth{sync} the buffer operations.
     - Prepare the buffers in a \clss{Routine} or \clss{Task}.\\
       Shortcut method: \mth{fork}.
     - Write \cd{s.sync;} before operations that depend on previous operations.\\
       That is, \mth{alloc} $\to$ \mth{sync} $\to$ \mth{sine1}.

*** Example: Filling a wavetable in one shot
    If you need to fill a buffer at one go, do it like this.
#+name: wtAsync1
#+caption: Using sync for buffer operations.
#+begin_src {} -i
fork {
   b = Buffer.alloc(s, 2048, 1);
   s.sync;
   b.sine1((1..3).reciprocal);
};
#+end_src

*** Other methods					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
For simplicity, the presentation slides cover just one way to handle
\gls{asynchronous} buffer operations. The \mth{sync} approach is
reliable in all cases for buffer preparation. It works for other
asynchronous actions, like sending \clsspl{SynthDef}.

SC has two other mechanisms for asynchronous behaviors.

*Completion messages.* Some server messages, such as buffer
allocation, allow another message to be attached. This message will
execute after the main message finishes. This is another shortcut for
filling a wavetable.

#+begin_src {} -i
b = Buffer.alloc(s, 2048, 1, completionMessage: { |buf|
   buf.sine1Msg((1..3).reciprocal);
});
#+end_src

The \ci{completionMessage} is usually written as a function. In this
example, the \ci{sine1Msg} needs to know the buffer number, but you
don't know the buffer number until code execution enters
\mth{alloc}. The \ci{completionMessage} function receives the buffer
object, with the buffer number; then the function can build the
message.

Note also that you must use \ci{sine1Msg} in this case, to get the
message. If you use \mth{sine1} instead, it will try to fill the
buffer before allocating the buffer---which obviously will fail.

*Action functions.* These are necessary to receive information from
the server. To get values from a buffer, the language must send a
request to the server and wait for the reply. After the reply comes
in, it will run a function that you choose. Assuming \ci{b} has
already been filled:

#+begin_src {} -i
b.getn(0, 10, { |data| data.postln });
#+end_src

*** Summary: FM synthesis
**** Basic formulas:
     - \eGls{modulator}: \cd{oscil.ar(freq * ratio, mul: mod\textunderscore index)}.
     - \eGls{carrier}: \cd{oscil.ar(freq * (mod + 1))}.
**** Parameters:
     - Ratio :: Determines the type of \gls{spectrum}. Integer ratios
                produce \egls{harmonic} spectra; non-integers produce
                \egls{inharmonic} spectra.
     - Modulation index :: Brightness, or complexity, of the resulting
          sound. An envelope on the index can produce many types of
          attacks.
**** Wavetable oscillators can enrich the sound, at no CPU cost.

* Sample playback and manipulation
** Loading and playing samples					   :noexport:
*** Buffers for audio samples
**** \clsspl{Buffer} can hold audio data, not only wavetables.
     - Loaded from disk files.
     - Recorded within the server.
**** Play back the audio in many ways.
     - Simple playback, at any rate: one shot, or cut into fragments.
     - Sampler-style instruments.
     - \eGls{granular} synthesis for time stretching or pitch shifting.

*** Loading sound files from disk
**** Methods to read sound files:
     - \mth{read} :: Read all or part of a sound file. Arguments: /server, path, startFrame, numFrames, action, bufnum/.
     - \mth{readChannel} :: Read some channels from the file, but not all. Same arguments, plus /channels/.
**** As before, release buffers before loading.
     - If you don't, eventually memory will run out.
#+name: sf1
#+caption: Read SuperCollider's classic Apollo 11 example sound into a buffer.
#+begin_src {} -i
b.free;
b = Buffer.read(s,
   Platform.resourceDir +/+ "sounds/a11wlk01.wav",
   action: { "done".postln; b.postln; }
);
#+end_src

*** Buffer loading is asynchronous
**** Look carefully at the output from that command.
#+begin_src {} -i
Buffer(0, nil, nil, nil, 
   /usr/local/share/SuperCollider/sounds/a11wlk01.wav)
done
Buffer(0, 188893, 1, 44100, 
   /usr/local/share/SuperCollider/sounds/a11wlk01.wav)
#+end_src
     - First \clss{Buffer} line: \mth{read} must return something.\\
       The buffer object exists in the language, but isn't ready yet. So we see \ci{nil}.
     - Second \clss{Buffer}: After reading is finished.\\
       Now the buffer knows how many \glspl{frame} and channels, and the sample rate.
**** You must \mth{sync} before using a buffer loaded from disk.

*** Frames
**** What's a \egls{frame}?
     - A mono sound file is just a stream of samples:\\
       \cd{s$_0$, s$_1$, s$_2$, ... s$_n$}
     - A stereo sound file has two samples at every instant:
       - @@latex:\cd{[s$_{0a}$, s$_{0b}$]}@@,
       - @@latex:\cd{[s$_{1a}$, s$_{1b}$]}@@,
       - @@latex:\ldots{}@@
       - @@latex:\cd{[s$_{na}$, s$_{nb}$]}@@
     - Each one of those lines is a \egls{frame}.\\
       One sample per channel, at a given time.

*** Loading sound file fragments by frames
**** \Glspl{frame} are another time measure for sound files or buffers.
     - \cd{frames = seconds * sampleRate}.
     - It doesn't matter how many channels.
**** Example:
     To read 0.5 seconds starting at 1 second:
     - \ci{startFrame} = 1 sec * 44100 frames/sec = 44100 frames
     - \ci{numFrames} = 0.5 sec * 44100 frames/sec = 22050 frames

*** Buffer playback
**** Easiest UGen for buffer playback: \ugen{PlayBuf}.
     *IMPORTANT:* The first argument must be a real number.
     - The language must know the number of channels when processing the synthesis function.
     - You can use \cd{b.numChannels}---this is an actual number.
#+name: playbuf1
#+caption: PlayBuf, with rate control.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~playbuf = { |rate = 1|
   (PlayBuf.ar(1, b, rate, 1, loop: 1)
      * 0.1).dup
};
~playbuf.addSpec(\rate, [0.1, 10, \exp]);
~playbuf.play;
)

p.gui;
#+end_src

*** Notes (numChannels)					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Why does \ci{numChannels} have to be an actual number?
The server and process audio only in a \clss{SynthDef}. The language
builds SynthDefs out of synthesis functions by arranging \glspl{UGen}
and their connections. Once the language lays out the UGens, /the
server cannot change the arrangement in any way/. The only way to
change the layout is for the language to build a new SynthDef.

The arrangement of the UGens depends on the number of channels coming
from \clss{PlayBuf}. Compare a mono \clss{PlayBuf} with an amplifier,
against a stereo one. The only difference between the
\clsspl{SynthDef} is \cd{PlayBuf(1, ...)} vs. \cd{PlayBuf(2, ...)},
but the resulting graphs are quite different.

#+begin_center
#+attr_latex: :width 0.3\textwidth
[[../02-synth/img/playbuf-1chan.png]]
#+attr_latex: :width 0.3\textwidth
[[../02-synth/img/playbuf-2chan.png]]
#+end_center

The server cannot convert one arrangement into the other. The language
can produce them. The server can only do what the language specifies.

It's possible, in the server, to get the number of channels in a
buffer using one of the buffer-info \glspl{UGen}:
\ugen{BufChannels}. But you /may not/ use this, or a synth argument,
in the \ci{numChannels} input. If you do, you'll get this error:
"ERROR: Primitive '\textunderscore BasicNew' failed. Index not an
Integer."  (\cd{b.numChannels} would be valid because it uses
information already available in the language.)

*** PlayBuf inputs
    - \ci{numChannels} :: This must match the buffer's channels.
    - \ci{bufnum} :: The buffer number or object.
    - \ci{rate} :: Playback rate scaling. 2 = twice as fast.
    - \ci{trigger} :: Causes \clss{PlayBuf} to jump back to \ci{startPos}.
    - \ci{startPos} :: Frame number to start playing from.
    - \ci{loop} :: If > 0, playback loops to the beginning or end.
    - \ci{doneAction} :: Don't use, for now.

*** Rate correction
**** What if the buffer is not at the server's audio rate?
     - \ci{rate} = 1 will play at the /server's/ sample rate.
     - If the buffer's rate is different, it will play too fast or slow.
**** \ugen{BufRateScale} corrects for this.
     - \cd{BufRateScale = bufferRate / sampleRate}.\\
     - Multiply your desired rate by \ugen{BufRateScale}, and it will play as expected.\\
       \cd{rate * BufRateScale.kr(bufnum)}

** Triggering sound file fragments				   :noexport:
*** Triggering sound file fragments
**** The \ci{trigger} and \ci{startPos} inputs control playback position.
     *Note:* \ci{setEvent} and \ci{psSet} include a trigger automatically.
#+name: playseg1
#+caption: Using startPos with a trigger to play different fragments.
#+begin_src {} -i
~playbuf = { |rate = 1, t_trig = 0, start = 0|
   (PlayBuf.ar(1, b, rate, t_trig, start)
      * 0.1).dup
};

p.setEvent((start: rrand(0, 100000))).play;

~player = \psSet -> Pbind(
   \start, Pwhite(0, 100000, inf),
   \dur, Pwhite(0.25, 1.0, inf)
);
#+end_src

*** Problem: Clicking
**** Every so often, there's an ugly click in the sound.
     Why do you think that is? \pause
**** Jumping from one part of the wave to another.
#+begin_center
#+attr_latex: :height 1.5in
[[../02-synth/img/click.png]]
#+end_center

*** Envelopes are mandatory
**** No. 1 rule of audio: /Everything/ needs an envelope.
     - Listing [[playseg1]] clicked because there is no envelope on the transitions.
     - To make a smooth transition, you need to \egls{crossfade} the segments.
**** \eGls{crossfade}: Fade out the old, fade in the new.
#+begin_center
#+attr_latex: :height 1.4in
[[../02-synth/img/crossfade.png]]
#+end_center

*** Overlapping envelopes
**** O1: Envelopes						  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
#+begin_center
#+attr_latex: :height 1.4in
[[../02-synth/img/crossfade-envelopes-1-time.pdf]]
#+end_center
***** \cd{Env.linen}\glsadd{Env}\glsadd{linen} makes a fade-in/out shape.
       - It's a timed envelope.
       - The \clss{SynthDef} will have a \ci{time} argument.
       - If \ci{time == delta}\glsadd{delta}, the envelopes will overlap as shown.
**** O2: Fade time						  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
#+begin_center
#+attr_latex: :height 1.4in
[[../02-synth/img/crossfade-envelopes-2-time-fade.pdf]]
#+end_center
***** We can also have an argument for \ci{fade} time.
       - *Note:* In envelopes, levels and times don't have to be fixed numbers.
       - Control inputs (arguments) and other UGens are OK.
**** O3: Fade time + calc					  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
#+begin_latex
\only<presentation>{
\begin{center}
\includegraphics[height=1.4in]{../02-synth/img/crossfade-envelopes-2-time-fade.pdf}
\end{center}
}
#+end_latex
# #+begin_center
# #+attr_latex: :height 1.4in
# [[../02-synth/img/crossfade-envelopes-2-time-fade.pdf]]
# #+end_center
***** \cd{Env.linen} takes these arguments:
       - \ci{attackTime} = fade
       - \ci{sustainTime} = \textbf{??}
       - \ci{releaseTime} = fade
***** What should \ci{sustainTime} be?
**** O4: All							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
#+begin_center
#+attr_latex: :height 1.4in
[[../02-synth/img/crossfade-envelopes-3-all.pdf]]
#+end_center
***** Subtract \ci{fade} from \ci{time}.
      - \cd{Env.linen(fade, time - fade, fade)}
      - The total synth duration will be \cd{time + fade}.
      - This is OK, because we want the overlap.

*** Note: Equal power					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** \eGls{linear} vs. \egls{equal-power} crossfades
If we want to fuss over the details, the above graphs are not exactly
right.

If you add the /linear/ fade-out and fade-in segments together, the
sum will be 1. But, the way we /hear/ the simultaneous fades makes it
seem like the volume drops slightly (about --3 dB) in the middle.

An /equal-power/ crossfade makes sure that the separate signals fade
in or out according to human perception. To make an equal-power
crossfade, use a linear envelope and take the square root (\mth{sqrt})
of the envelope generator.

#+begin_center
#+attr_latex: :height 1.1in
[[../02-synth/img/xfade-equal-power.png]]
#+end_center

You can see the effect for yourself. Don't worry for now about how
this function is handling the envelopes---you can always come back and
work it out later, using some help files. (\Gls{multichannel expansion} is
the key to this example.)

#+begin_src {} -i
p = ProxySpace.new; p.push;

(
~test = {
   var sig = SinOsc.ar([220, 440], 0, 0.1),
   trig = Impulse.kr(0.5),
   trigs = PulseDivider.kr(trig, 2, [1, 0]),
   // linear xfade at first
   egs = EnvGen.kr(Env.linen(0.5, 1.5, 0.5), trigs);
   Mix(sig * egs).dup
};
~test.play;
)
#+end_src

Open the server's volume meter (/Language/ menu or \ks{Ctrl-M}) and
watch the green bar. You'll see that it drops a little bit when the
synth crossfades between the two pitches. Now, add \cd{.sqrt} after
\ci{egs}: \cd{Mix(sig * egs.sqrt).dup} and rerun the
\cd{\textasciitilde test = ...} block. This takes the square root of the
linear envelopes, making equal-power curves. Now the meter shows a
steady level.

Make sure to \cd{\textasciitilde test.clear;} before continuing.

The envelopes we will use here are so short that you won't notice the
flaw of linear crossfades. But, you should be aware of equal-power
fades and use them when needed.

*** Easiest crossfade: Canonical
**** \eGlspl{crossfade} are tricky in a single synth function.
     But they are very easy using "canonical" style!
     - One synth plays one segment.
     - One synth can envelope itself easily.
     - Two synths with a slight overlap make a crossfade.
**** We just need a template:
     - Play any buffer (with matching \ci{numChannels});
     - Start at any point;
     - Play for any duration.

*** Buffer segment player
**** The template is a \clss{SynthDef}.
     ... with arguments for buffer, position and duration.
#+name: segxf1
#+caption: A SynthDef that plays one segment of any duration from a mono buffer, starting anywhere.
#+begin_src {} -i
SynthDef(\bufseg1, { |out = 0, bufnum, start, rate = 1,
      time = 1, fade = 0.05, pan = 0, amp = 0.1|
   var sig = PlayBuf.ar(1, bufnum,
      rate * BufRateScale.kr(bufnum),
      1, start),
   eg = EnvGen.kr(Env.linen(fade, time - fade, fade),
      doneAction: 2);
   Out.ar(out, Pan2.ar(sig * eg, pan, amp));
}).add;
#+end_src

*** New elements
**** \ugen{Pan2} instead of \mth{dup} to get a stereo signal.
     --1 $\le$ \ci{pan} $\le$ +1 locates the sound left $\longleftrightarrow$ right.
**** \ugen{Out}: In \clss{SynthDef}, you have to output the signal explicitly.
     - \clsspl{NodeProxy} create the \ugen{Out} for you.
     - More about \ugen{Out} and \eglspl{bus} later.
     - For now, note the \ci{out} argument for the target bus.
**** \mth{doneAction} to remove the synth automatically.
     - Canonical style assumes the synth will remove itself.
     - \cd{doneAction: 2} in the \ugen{EnvGen} does this.
     - Not needed in modular style.

*** Stereo segment player
**** Two changes for stereo.
     - \ugen{PlayBuf}'s number of channels must be 2.
     - Use \ugen{Balance2} instead of \ugen{Pan2}.
       - \ugen{Pan2} is /only/ for mono input.
       - Note the separate left/right inputs for \ugen{Balance2}.
#+name: segxf1b
#+caption: A SynthDef that plays one segment from a stereo buffer.
#+begin_src {} -i
SynthDef(\bufseg2, { |out = 0, bufnum, start, rate = 1,
      time = 1, fade = 0.05, pan = 0, amp = 0.1|
   var sig = PlayBuf.ar(2, bufnum,
      rate * BufRateScale.kr(bufnum),
      1, start);
   sig = sig * EnvGen.kr(Env.linen(fade, time - fade, fade),
      doneAction: 2);
   Out.ar(out, Balance2.ar(sig[0], sig[1], pan, amp));
}).add;
#+end_src

*** Sequencing canonical-style in ProxySpace
**** How to run a SynthDef-based pattern in \clss{ProxySpace}?
     - Easy: Just omit \ci{\textbackslash psSet ->}.
     - Then play the resulting proxy.
     - Note \clss{Pkey}. It reads a value that was put into the event before.\\
       Here, it makes sure \cd{\textbackslash time == \textbackslash dur}.
#+name: segxf2
#+caption: A canonical-style pattern in ProxySpace.
#+begin_src {} -i
~bufsegs = Pbind(
   \instrument, \bufseg1,
   \bufnum, b,
   \start, Pwhite(0, 88200, inf),
   \dur, Pexprand(0.1, 0.5, inf),
   \time, Pkey(\dur)
);
~bufsegs.play;

~bufsegs.stop;
#+end_src

*** Modular use of a regular pattern
**** Now, the /really/ cool thing about \clss{ProxySpace}.
     - In Listing [[segxf2]], the pattern runs inside a \clss{NodeProxy}.
     - We already saw how to plug one \clss{NodeProxy}'s output into another.
     - The same applies to \ci{\textasciitilde bufsegs}!
**** Remember when we started with modular synthesis.
     - After we created an oscillator, it was running in the server.
     - It was silent because it was disconnected from the output.
     - Same with regular patterns:
       - The pattern is always running.
       - You only hear it when it's connected to the output, or another proxy.

*** Apply a filter
**** We can filter the pattern's audio, just like any oscillator.
     \cd{\textasciitilde bufsegs.ar} here is no different from
     \cd{\textasciitilde oscil.ar} earlier.
#+name: segxf3
#+caption: Plug the pattern's proxy into a filter's input.
#+begin_src {} -i
~filter = {
   var ffreq = LFNoise1.kr(5).exprange(200, 1000);
   RLPF.ar(~bufsegs.ar, ffreq, 0.05)
};

~filter.play;

~filter.stop;
#+end_src

*** Doing weird things
**** SC lets you do some strange things...
     - With commercial VSTs, you have a sampler and an FM plug-in.
     - With SC, you can plug the sampler (\ci{\textasciitilde bufsegs}) into an FM oscillator!
     - That's not "normal" synthesis... but it's fun!
**** Exercise for you
     - Recall the formula for an FM \egls{carrier}.
     - Substitute the buffer player.
     - *Hint:* The modulator doesn't have an \ci{index} anymore.\\
       Write it into the new carrier instead.

*** Musical uses: Percussion
**** Drum machines
     - Load drum hits into separate buffers.
     - Write separate patterns for kick, snare etc.
**** Breakbeats
     - Load a drum loop into a buffer.
     - Use a soundfile editor (e.g., Audacity) to find where the drum hits begin (\gls{frame} indices).
     - Keep the frame indices in a data structure.
       - \clss{Event} is nice because you can name the drum types.
     - Choose the right type of hit for each time point.

*** Breakbeat example: Preparation
**** We need to store the information somewhere.
     - Can't do it inside \clss{ProxySpace}.
     - Choose an \egls{interpreter} variable (\ci{a}--\ci{z}).
     - Put an empty \clss{Event} in it.
#+name: break1Prep
#+caption: Preparation for a breakbeat: the buffer, and frame numbers within the buffer.
#+begin_src {} -i
q = ();
q[\buf] = Buffer.read(s, thisProcess.nowExecutingPath
   .dirname.dirname.dirname +/+ "samples/rider.wav");
q[\hits] = (
   kick: [64, 50670],
   snare: [25410, 75844],
   tamb: [12818, 38360, 63146, 89028],
   offkick: [69445, 82436],
   offsnare: [44700, 56908, 95421]
);
#+end_src

*** Breakbeat example: Pattern
**** Very simple to start:
     Kick on 1 and 3, snare on 2 and 4.
**** Accessing the frame numbers from \cd{q[\textbackslash hits]}:
     - Use a pattern to produce the hit type's name.
     - \mth{collect} over the names to choose the actual frame.
#+name: break1Prep
#+caption: The breakbeat pattern.
#+begin_src {} -i
~break = Pbind(
   \instrument, \bufseg1, \buffer, q[\buf],
   \start, Pseq([\kick, \snare], inf).collect { |hit|
      q[\hits][hit].choose
   },
   \rate, 1.14588,  // match loop to 120 bpm
   \dur, 0.5, \time, 0.5,
   \amp, 0.5
);
~break.play;
#+end_src

*** Going further with breakbeats
**** Mostly: Wait until the discussion of musical use of patterns.
     Some hints for now:
     - Set the clock's tempo to the real tempo you want:\\
       \cd{TempoClock.tempo = beatsPerSec;} or
       \cd{TempoClock.tempo = beatsPerMin / 60;}.
     - Divide by the tempo for \ci{\textbackslash time}:\\
       \cd{timePattern / Ptempo()}\glsadd{Ptempo}
     - Use \clss{Ptime} to know where you are in the measure.

*** Summary: Buffer segments
**** \eGlspl{crossfade} are absolutely essential!
     Easiest way: Canonical style.
     - \clss{SynthDef} to play one segment with an envelope.
     - \cd{doneAction: 2}\glsadd{doneAction} to remove old synths.
     - Normal pattern (without \ci{\textbackslash psSet}).
**** Regular patterns in \clss{ProxySpace}.
     - Plug into other \clsspl{NodeProxy}, just like any signal.

** Sampled instrument players -- ALWAYS NOEXPORT 		   :noexport:
*** Too much for now
*** Buffers for instrument samples
**** If we can load drums into buffers, why not notes?
     No problem!
**** Techniques we need:
     - Handling pitch.
     - Overlap and crossfade across pitch ranges.
     - Not covered in this workshop:
       - Sample looping;
       - Streaming samples from disk ("DFD" in Kontakt).

** Granular synthesis
*** Granular synthesis: Extremely powerful
**** Many common effects are based on \egls{granular} synthesis.
     - Notably, time stretching and pitch shifting.
     - Also good for long, complex drones.
**** A form of /microsound/.
     - Typically, sounds between 10 and 100 ms duration.
     - Rhodes, Curtis (2001). /Microsound/.

*** What is granular synthesis?
**** \eGls{granular} synthesis composes sounds from clouds of very short \eglspl{grain}.
     - When you have enough grains, you hear only the cloud.
     - As in these graphics: The more grains, the harder to see the individuals.
#+begin_center
#+attr_latex: :width 0.3\textwidth
[[../02-synth/img/grains100.png]]
#+attr_latex: :width 0.3\textwidth
[[../02-synth/img/grains200.png]]
#+attr_latex: :width 0.3\textwidth
[[../02-synth/img/grains500.png]]
#+end_center

*** Characteristics of grains and clouds
**** Important things about a \gls{grain}:
     - *Duration:* How long it is.
     - *Envelope:* Its shape.\\
       Sine-shaped envelopes work especially well.
     - *Spectral content.* Usually comes from sampled audio in a \clss{Buffer}.
**** Important things about grain clouds:
     - *Overlap:* How many grains simultaneously. (May vary.)
     - *Time distribution:* Are the grains evenly spaced in time?

*** Sine-shaped envelopes
**** Sine envelopes work well because they are complementary.
     - /Complementary/: Add them together, with the right offset, and you get a constant.
     - So, the individual envelopes blend together into a consistent volume.
#+begin_center
#+attr_latex: :height 1.5in
[[../02-synth/img/sinusoidal-envelopes.png]]
#+end_center

*** Start simple: Individual grains
**** \Gls{granular} UGens have a number of parameters.
     - If we do too many at once, it's confusing.
**** Parameters needed for single \glspl{grain}:
     - *Trigger:* We'll use \ugen{Impulse}, controlled by frequency.
     - *Duration*.
     - *Position* within the buffer: for now, in seconds.
#        , as a \egls{normalize}\emph{d} range.
#        - 0 = buffer start, 1 = buffer end.
#        - Why? \Glspl{Buffer} may be of different sizes.
#        - If it's normalized, the position input can be the same for any buffer.

*** TGrains UGen
**** Basic granulator: \ugen{TGrains}.
     - You can control trigger frequency, grain duration and buffer position.
     - Raise the trigger frequency until the grains blend together.
#+name: grain1
#+caption: Granular synthesis: first step.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~grains.addSpec(\tfreq, [1, 20, \exp]);
~grains.addSpec(\pos, [0, b.duration]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, pos = 0.5,
   amp = 0.2|
   var trig = Impulse.ar(tfreq);
   GrainBuf.ar(2, trig, graindur, b, 1, pos, 2, pan) * amp;
};
~grains.play;
)

p.gui;  // if it's not already open
#+end_src

*** Automating buffer position
**** Let's move forward through the buffer.
     Constant rate---what do you think will be the result?
**** Replace the \ci{pos} argument with a \ugen{Phasor}.
     - \ugen{Phasor} is a looping line segment, with a rate control.
     - \ci{rate} is in units per sample.\\
       At audio rate, \cd{rate = 1} will increase by 44100 in one second.
     - We want to increase by 1.0 per second.\\
       See \ugen{SampleDur}, which outputs $\frac{1}{samplerate}$.
     - What's the upper boundary?\\
       \Gls{Buffer} duration: \cd{b.duration} or \ugen{BufDur}\cd{.kr(b)}.
**** Exercise for you: Write the \ugen{Phasor}.
# #+name: grain2
# #+caption: Use a Phasor to move through the buffer in real time.
#+begin_src {} -i :exports none
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.2|
   var trig = Impulse.ar(tfreq),
   pos = Phasor.ar(0, SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, pos, graindur, pan, amp)
};
#+end_src

*** Speed of buffer movement
**** What if we move through the buffer at different speeds?
     - Add a new argument, \ci{speed}.
     - Set its range, using \mth{addSpec}, to \cd{[0.25, 4, \textbackslash exp]}.
     - How to incorporate \ci{speed} into the \ugen{Phasor}?\\
       *Hint:* \ci{speed} should /scale/ (multiply) the \ugen{Phasor} rate that is already there.
**** Exercise: Write this yourself.
     What is the result?
# #+name: grain3
# #+caption: Adjust the buffer movement speed by a synth argument.
#+begin_src {} -i :exports none
~grains.addSpec(\speed, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain rate
**** What about the \ci{rate} argument in \ugen{TGrains}?
     - We adjusted the \ugen{Phasor} rate, and got a time effect.
     - What do you think \ugen{TGrains}'s rate will do?
**** Let's find out: Write the change yourself.
     - Add a new \ci{rate} argument.
     - Give it a similar exponential range.
     - Plug it into \ugen{TGrains}.
# #+name: grain4
# #+caption: Adjust the grain playback rate by a synth argument.
#+begin_src {} -i :exports none
~grains.addSpec(\rate, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   rate = 1, speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, rate, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain duration vs. overlap
**** Sometimes better to control how many overlapping \glspl{grain}.
     - That is, adjust the grain duration along with trigger frequency.
     - If you want 4 overlapping grains, and 1 trigger/sec, how long should each grain be?\pause\\
       4 seconds.\pause
     - If you have 2 triggers/sec, how long should the grains be?\pause\\
       2 seconds.\pause
     - What, then, is the formula?\pause\\
       \cd{overlap / trigfreq}\pause
**** Exercise, on your own time:
     Edit the synth to use an \ci{overlap} argument instead of \ci{graindur}.

*** Summary: Granular synthesis parameters
**** \Gls{granular} synthesis gives you independent control over:
     - Time (buffer position's rate of change);
     - Pitch (playback rate of each \gls{grain});
     - Continuity (frequency of triggers, grain duration, overlap).
**** Tone color comes from whatever is in the buffer.

*** Sustaining sounds

*** Glitchy sounds

* Effects common in subtractive synthesis 			   :noexport:
** Chorus
** Distortion

#+begin_comment
* Removed							   :noexport:
*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array.\\
      \cd{freq * [1, detun, detun.reciprocal]}\\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
# #+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** More convenience for gates: Events
**** Sequencing: Inconvenient to close gates by hand.
     Introducing \clss{Event}.
     - We saw an \clss{Event} briefly, in the "canonical" example (Listing [[canonical]]).
     - It both played and released a Synth.
     - We will learn more about events as we go.
**** Events have lots of properties, including timing.
     - \ci{dur} :: Number of beats until the next event.
     - \ci{sustain} :: Number of beats to keep a gate open. (May
		       also be calculated from \cd{dur * legato}.)

*** Event patterns: One-stop shopping
    Let's be clear about the implications:
**** Event patterns handle everything for sequencing
     - Parameter setting
       - New parameter values are saved in the event
     - Timing
       - Every event has a \egls{delta}

*** What is \textbackslash psSet?
**** \ci{\textbackslash psSet} says how the pattern's events should be used.
     - \clss{Pbind} doesn't say /what to do/.\\
       It only says what information to use.
     - The \clss{Event} interprets the data and takes action, based on the \egls{event type}.
**** \ci{\textbackslash psSet} is an event type.
     - It tells the pattern's events to operate on existing \clsspl{NodeProxy} within the \clss{ProxySpace}.
     - Actually a bit more: It connects the events to the current \clss{ProxySpace}.

*** Why not use \textbackslash note?
**** If \ci{\textbackslash note} is the normal \gls{event type}, why not use it?
     - We will, later.
     - We are beginning with a \egls{modular} approach, for reasons noted earlier.
     - This approach needs a different event type.

*** Note control summary: Envelopes
**** \eGls{breakpoint} \eglspl{envelope}
     - Idea: Start level, list of segments
     - Written in \clss{Env} using three arrays: \ci{levels}, \ci{times}, \ci{curve}
**** \eGls{envelope generator}
     - Renders the segments into a signal.
     - Responds to \eglspl{trigger} and \eglspl{gate}.
**** Triggers and gates: signal > 0
     - A \te{trigger} is instantaneous, when the signal becomes > 0.
     - A \te{gate} is open when > 0, closed otherwise.

*** Note control summary: Gates and Events
**** \eGlspl{gate} must be opened and closed.
     - By hand, using \cd{\textasciitilde something.set(\textbackslash gt, 1)} or \cd{0}.
     - An \clss{Event} can close the gate for you, after a given \ci{sustain} time.
       - \ci{sustain} can be given directly, or you can provide \ci{dur} and \ci{legato}.
**** Events can set many parameters at once.
     Very useful for sequencing: The start of a note can change pitch,
     amplitude, timbre controls all at once.

** Special event keys: Pitch and Time
*** Pitch and time in events
**** Many levels to write pitch and time.
     You can organize pitch and time in different ways, appropriate to different musical ideas.
**** "Physical" level
     Ultimately, SC uses specific event keys for the final result. These can be calculated from higher levels.
     - Time :: \ci{delta} and \ci{sustain}
     - Pitch :: \ci{freq}

*** Time model
**** Physical level: \ci{delta} and \ci{sustain}.
     - \ci{delta} :: How many beats until the next event.
     - \ci{sustain} :: How many beats before releasing the envelope.
**** Higher level: \ci{dur}, \ci{legato}, \ci{stretch}
     - Larger \ci{stretch} makes things go slower.
     - Smaller \ci{legato} makes the notes shorter.
     - \cd{delta = dur * stretch}
     - \cd{sustain = dur * stretch * legato}

*** Example: Articulation using \textbackslash legato
    First a synth. Further explanation later today.
#+name: legato1
# #+caption: A modular synth, with amplitude and filter frequency envelopes for articulation.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;
~oscil = { |freq = 440|
   Mix(Pulse.ar(
      Lag.kr(freq, 0.08) * { exprand(1/1.005, 1.005) }.dup(5),
      { rrand(0.4, 0.5) }.dup(5)
   ))
};
~ampEg = { |gt|
   EnvGen.kr(Env.adsr(0.01, 0.1, 0.6, 0.15), gt)
};
~feg = { |gt, width = 3|
   EnvGen.kr(Env.perc(0.01, 0.14, width), gt) + 1
};
~filter = { |ffreq = 1800, rq = 0.2, amp = 0.05|
   (RLPF.ar(~oscil.ar, clip(ffreq * ~feg, 20, 20000), rq)
      * amp * ~ampEg).dup
};
~filter.play;
#+end_src

*** The \textbackslash legato pattern
    Play it with a \mth{psSet} pattern.
    - Two possible \ci{\textbackslash legato} values:
      - 0.5: Half the note's duration---staccato
      - 1.05: Longer than the note's duration---legato\\
        This makes a sliding pitch, like a classic mono synth.
    - \ci{\textbackslash legato} is easier than calculating
      \ci{sustain} by hand.
#+name: legato2
# #+caption: A pattern, to play the previous synth like a mono synth with fingered glides.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pwhite(36, 48, inf),
   \dur, Pwhite(1, 3, inf) * 0.125,
   \legato, Prand(#[0.5, 1.05], inf),
   \gt, 1
);

~player.clear;
#+end_src

#+end_comment
