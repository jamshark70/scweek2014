#+startup: beamer

#+TITLE: SuperCollider Week, Day 1 \\ Introductory SC and Synthesis
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL: 

# #+INCLUDE: "../slidehead.org"
#+INCLUDE: "../printhead.org"

#+include: "01-glossary.org"

* Resume export						    :B_ignoreheading:
  :PROPERTIES:
  :BEAMER_env: ignoreheading
  :END:

#+call: makegloss01
#+results: makegloss01

#+name: classgloss01
#+call: makegloss01(tbl=class01,glosstype="class") :results value latex
#+results: classgloss01

#+call: ugengloss01
#+results: ugengloss01

* Workshop introduction
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001)
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou
     - Subjects: Electronic music production, Film music
**** Special interests:
     - Danceclub music
     - Real-time performance with computers

*** What is SuperCollider?
**** /Programming language/ for audio and composition
     - Created by James McCartney
     - Conceptual basis: SmallTalk
       - /Object-oriented/ like Java, but still fun (not like Java)
     - Syntax: More like C
**** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
**** Right							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

*** Workshop goals
**** Teach synthesis techniques by experimentation
     - SC lets us take apart synthesizer components, and put them back together
     - SC's /Just-In-Time library/ makes it easy to re-patch components interactively
**** Teach techniques for live control and performance
     - Control by graphic interfaces and external devices
     - End goal: A group composition, to perform together
**** *Have fun programming!*
     - Emphasis on /play/ over /correctness/

*** Audio programming before SuperCollider, 1
    Not a complete survey!
**** *Music \emph{n}* languages
     - Orchestra file to define synthesis
     - Score file (what to play, when)
     - Modern incarnation: /csound/
**** Lisp: *Common Lisp Music*, *Nyquist*
     - Music: Hierarchies of structure
     - Lisp: Data structures are hierarchical! Good for composition

*** Audio programming before SuperCollider, 2
**** Dataflow: *Max/MSP*, *Pure Data*
     Represent everything as signal flow
     - Good: Intuitive to wire up interfaces quickly
     - Bad:
       - Relatively weak data structures (hard to represent musical information in an articulate way)
       - Monophonic processes, easy; polyphonic, hard
       - Complexity barrier

*** Version history
**** McCartney's work before SuperCollider
     - /Synth-O-Matic/ (1990)
     - /Pyrite/ (scripting language for Max)
**** SuperCollider
     - SC1: Synth-O-Matic + Pyrite
     - SC2: Influence from SmallTalk
       - SC language is nearly complete
       - Notable audio processing inefficiencies
     - SC3 ("SC Server")
       - Audio processing is more efficient, by handling audio in a /server/ process

* SC architecture, usage
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - =scide=: SC Integrated Development Environment
       - Code editor, display, documentation
     - =sclang=: SC language
       - IDE sends code to sclang
       - sclang runs the code, sends printed output back to IDE
     - =scsynth=: SC synthesis server
       - sclang sends Open Sound Control messages to scsynth
       - scsynth sends audio to the hardware
       - May also reply to sclang

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[./img/sc-with-guis.pdf]]
    #+end_center

*** Why separate the functions?
**** If one component crashes, the others keep working.
     Especially important: The code window stays intact!
**** They work together like one unit.

*** Server/client design
**** *Server/client* design
     - Server does heavier work (e.g., databases)
     - Client makes requests of the server
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server \\
       /Open Sound Control/ (OSC) protocol
       - "Here's a /synthesis definition/."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

*** Why server/client?
**** Efficiency
     - Synthesis definitions are /reusable/.
**** Networked applications
     - Many clients can use the same server
**** Not limited to SC language
     - Any language that supports OSC can use SC audio!
     - Python, Clojure, Scala, Haskell, Scheme...
     - In free software, /user choice/ is important. Prefer /open/
       designs, rather than closed.

*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status
       - Server control (click on the server status)

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end \\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps
** Making noise
*** Let's make some noise!
   1. Boot the audio server: \ks{Ctrl-B} \\
      See also /Language/ menu and server status. \\
      *Linux:* Start JACK before doing this.
   2. Type and run some code. \\
      Just run the first line at first.
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

*** Tweak it
**** Try changing the numbers.
     On your own---a minute or so to experiment.
     - Run \cd{a.release} before re-running the synth.
     - What happens if you forget?
       - If you forget: press \ks{Ctrl-.} to stop everything.
       - \ks{Ctrl-.} is SC's panic button.
**** Be careful with the third number!			       :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     If it's too high, you could hurt your ears.
**** What do you think the numbers mean?

*** Easier tweaking: ProxySpace
**** \ci{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \ci{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

*** Important idea: /Modular/ design
**** A \te{modular} approach breaks a problem into smaller pieces.
    - For synthesis, it means you can play with the different pieces independently.
#+name: ps2
#+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

** SC language syntax
*** Taking it apart
**** Now we know enough to step back and see what this is made of.
     - This part is a little dry and technical.
     - But, to talk about SC, you need to know some important terms.

*** Taking it apart: Functions
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-02-function.pdf]]
     #+end_center
***** A \te{function} is a block of code in curly braces.
     - Functions can take information in through \te{arguments}.
     - They always return one result.
     - \te{Call} a function using \ci{value}.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg x, y; sqrt(x.squared + y.squared) };

f.value(3, 4);  // prints "5"
#+end_src
# **** More about functions later.

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** A \te{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \ci{release} the synth. So, save the \ci{Synth} object in a variable.
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Declared} variables
     - Any function can \te{declare} variable names.
     - Declared variables exist only inside that function! \\
       This is called \te{local} scope.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Interpreter} variables
      - Single letters \cd{a}--\cd{z}. 
      - \te{Global} scope. Interpreter variables may be used anywhere
       	(unless a function declares a single-letter variable).
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** ProxySpace uses environment variables for synth nodes.

*** Taking it apart: Classes
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-03-class.pdf]]
     #+end_center
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** A \te{class} is an \te{object type}.
       Classes define two things:
       - Data :: Objects remember specific information. \\
       	 E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
       - Actions :: Objects know how to do specific things. \\
       	 E.g., You can add two \ci{Point}s together: \cd{point1 + point2}. \\
       	 The \cd{Point} \te{class} declares how a Point should do \cd{+}.
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \ugen{SinOsc} is a \te{Unit Generator} class.
       - Unit generators ("UGens") are audio-processing operations in the server.
       - UGen classes in SC language:
	 - /Name/ the audio processors.
	 - /Connect/ UGens together.

*** Taking it apart: Methods
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-04-methods.pdf]]
     #+end_center
***** A \te{method} defines an action that an object can perform.
      It's like a function, but it has a name and belongs to a class.
      - \ci{ar} :: Makes an \te{audio rate} instance of \ugen{SinOsc}.
      - \ci{dup} :: Copies the mono signal from \ugen{SinOsc} into both left and right channels.
      - \ci{play} :: Makes a \te{synth node} from the function. \\
       	\ci{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

*** Taking it apart: Arguments
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-05-args.pdf]]
     #+end_center
***** \te{Arguments} pass information into a method or function.
      - In general, UGens take numbers or signals as inputs.
      - They generate signals as output.
      - \ugen{SinOsc}'s arguments are:
       	- freq :: In Hz.
       	- phase :: In radians (0--$2\pi$).
       	- mul :: Amplitude.
       	- add :: An offset (generally not used for audio).

*** Syntax
**** \te{Syntax}: Rules defining "legal" expressions.
E.g., \cd{x + y} is legal, while \cd{x y + 3} is not. You can't have \cd{x} and \cd{y} next to each other with only a space in between.
**** SC language syntax is all about /calling methods/.
Everything happens in SC through method calls. *Everything.*

*** Parts of a method call
**** Method calls consist of three parts:
    - Receiver :: The object that will perform the method.
    - Selector :: The method's name.
    - Arguments :: Additional input (optional).
\\
In \cd{SinOsc.ar(440)}:
    - Receiver = the class \cd{SinOsc}
    - Selector = \cd{ar}
    - Argument = \cd{440}

*** Method call syntax
**** Three ways to call methods in SC.
    - "Dot" style :: \cd{receiver.selector(arguments...)}
    - Function style :: \cd{selector(receiver, arguments...)}
    - Infix style :: \cd{receiver selector: argument} \\
      Infix style allows only one argument. \\
      Binary operators (\cd{+}, \cd{-}, \cd{*}, \cd{/}, \cd{**}) are methods that use infix style.
      In \cd{1 + 2}: Receiver = 1, Selector = '+', Argument = 2
#+Name: callstyles
#+Caption: Three styles of method calls. They all answer with the same result, because the receiver, selector and argument are the same.
#+begin_src {} -i
[2.pow(3), pow(2, 3), 2 pow: 3]
// answers: [ 8, 8, 8 ]
#+end_src

*** Beginning usage: Summary 1
**** Write audio processing into \te{functions}.
     - These functions should create UGens: \cd{SinOsc.ar} or \cd{.kr}.
     - \cd{aFunction.play} /adds/ new synthesis into the server.
**** \ci{ProxySpace} for plug-and-play.
     - Automatically turns functions into synthesis.
     - Reassigning an environment variable /replaces/ synthesis.
**** \te{Modular} style of writing.
     - Use /small/ synthesis functions.
     - Connect them by using the environment variable in another UGen's inputs.

*** Beginning usage: Summary 2
**** \te{Unit Generators} ("UGens")
     - Input signals \to UGen \to Output signal
     - Connections: UGen A's output \to UGen B's input
**** Important SC language concepts
     - Class :: An object definition: /Data/ and /actions/
     - Method :: An action that an object that knows how to perform.
     - Variable :: A placeholder for an object (a reference to it).
     - Argument :: The input to a function or method. UGens are created by the \ci{ar} and \ci{kr} methods; here is where you write the input signals.

*** Next: Synthesis techniques
    Now we know enough to start exploring standard synthesis techniques.

* Subtractive synthesis
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - Oscillator :: Produces a waveform with lots of harmonics
     - Filter :: Takes away parts of the spectrum

*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens
     - Saw :: A \te{band-limited} sawtooth oscillator
     - LPF :: A Low-Pass Filter

*** Syntax alert! Arguments
**** Function arguments using vertical pipe characters
     \cd{|ffreq = 2000|} means the same as \cd{arg ffreq = 2000;}.
     - ffreq :: The argument name.
     - 2000 :: The argument's default value.
**** Arguments are magical in synthesis functions.
     - They automatically become \te{control inputs}.
     - You can set the value from outside, and it changes the sound inside.
     - One synthesis function can make many frequencies, amplitudes, filtering behaviors etc.

*** Syntax alert: Argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an exponential curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \class{ControlSpec}(low, high, curve, step, default)
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: Exponential.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric sawtooth is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \te{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
   #+begin_center
   #+attr_latex: :height 2in
   [[./img/three-waves2.png]]
   #+end_center
\\ *Note:* The upper partials of a triangle wave are much weaker than
in a sawtooth or pulse wave. So there is no band-limited triangle UGen
in SC.

*** Pulse width
**** Pulse wave: Up and down times can differ
    - If equal, the pulse width is 0.5 (50%). \\
      This is a \te{square wave}.
    - If unequal, the sound is brighter and thinner.
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

** Filters
*** Filters
**** We identify filters based on their \te{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[./img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \te{Q}: the filter's \te{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}: \\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
     \ugen{VarSaw} is not band-limited. It should be OK if \ci{width} is
     close to 0.5 (a triangle wave). \ci{width} = 0 is the same as
     \ugen{LFSaw}, and will cause aliasing.

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses $rq = \frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.
** Standard synthesizer components

* Glossary
** UGens
# http://www.latex-community.org/forum/viewtopic.php?f=5&t=16833
#+LaTeX: \renewcommand{\glossarysection}[2][]{}
# #+LaTeX: \glsaddall
#+LaTeX: \printglossary[type=ugen]
# #+LaTeX: \printglossaries
