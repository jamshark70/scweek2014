#+startup: beamer

#+TITLE: SuperCollider Week, Day 1 \\ Introductory SC, Synthesis and Sequencing
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL: 

#+INCLUDE: "../slidehead.org"
# #+INCLUDE: "../printhead.org"

#+include: "../glossary.org"

* Temp, just to put it in a frame
*** Temp, just to put it in a frame
#+call: makegloss
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :results value latex
#+results: mthgloss

#+call: ugengloss
#+results: ugengloss

* Workshop introduction						   :noexport:
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001)
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou
     - Subjects: Electronic music production, Film music
**** Special interests:
     - Danceclub music
     - Real-time performance with computers

*** What is SuperCollider?
**** /Programming language/ for audio and composition
     - Created by James McCartney
     - Conceptual basis: SmallTalk
       - /Object-oriented/ like Java, but still fun (not like Java)
     - Syntax: More like C
**** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
**** Right							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

*** Workshop goals
**** Teach synthesis techniques by experimentation
     - SC lets us take apart synthesizer components, and put them back together
     - SC's /Just-In-Time library/ makes it easy to re-patch components interactively
**** Teach techniques for live control and performance
     - Control by graphic interfaces and external devices
     - End goal: A group composition, to perform together
**** *Have fun programming!*
     - Emphasis on /play/ over /correctness/

*** Audio programming before SuperCollider, 1
    Not a complete survey!
**** *Music \emph{n}* languages
     - Orchestra file to define synthesis
     - Score file (what to play, when)
     - Modern incarnation: /csound/
**** Lisp: *Common Lisp Music*, *Nyquist*
     - Music: Hierarchies of structure
     - Lisp: Data structures are hierarchical! Good for composition

*** Audio programming before SuperCollider, 2
**** Dataflow: *Max/MSP*, *Pure Data*
     Represent everything as signal flow
     - Good: Intuitive to wire up interfaces quickly
     - Bad:
       - Relatively weak data structures (hard to represent musical information in an articulate way)
       - Monophonic processes, easy; polyphonic, hard
       - Complexity barrier

*** Version history
**** McCartney's work before SuperCollider
     - /Synth-O-Matic/ (1990)
     - /Pyrite/ (scripting language for Max)
**** SuperCollider
     - SC1: Synth-O-Matic + Pyrite
     - SC2: Influence from SmallTalk
       - SC language is nearly complete
       - Notable audio processing inefficiencies
     - SC3 ("SC Server")
       - Audio processing is more efficient, by handling audio in a /server/ process

* SC architecture, usage					   :noexport:
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - \egls{scide}: SC Integrated Development Environment
       - Code editor, display, documentation
     - \egls{sclang}: SC language
       - IDE sends code to sclang
       - sclang runs the code, sends printed output back to IDE
     - \egls{scsynth}: SC synthesis server
       - sclang sends \gls{OSC} (Open Sound Control) messages to scsynth
       - scsynth sends audio to the hardware
       - May also reply to sclang

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[./img/sc-with-guis.pdf]]
    #+end_center

*** Why separate the functions?
**** If one component crashes, the others keep working.
     Especially important: The code window stays intact!
**** They work together like one unit.

*** Server/client design
**** *Server/client* design
     - Server does heavier work (e.g., databases)
     - Client makes requests of the server
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server. \\
       /Open Sound Control/ (\gls{OSC}) protocol
       - "Here's a /synthesis definition/."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

*** Why server/client?
**** Efficiency
     - Synthesis definitions are /reusable/. \\
       Optimizing a \clss{SynthDef} is relatively slow. Doing this
       once for thousands of notes is more efficient than once for
       every note.
**** Networked applications
     - Many clients can use the same server
**** Not limited to SC language
     - Any language that supports OSC can use SC audio!
     - Python, Clojure, Scala, Haskell, Scheme...
     - In free software, /user choice/ is important. Prefer /open/
       designs, rather than closed.

*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status
       - Server control (click on the server status)

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end \\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps					   :noexport:
** Making noise
*** Let's make some noise!
   1. Boot the audio server: \ks{Ctrl-B} \\
      See also /Language/ menu and server status. \\
      *Linux:* Start JACK before doing this.
   2. Type and run some code. \\
      Just run the first line at first.
      @@latex:\glsadd{play}\glsadd{release}\glsadd{dup}\glsadd{SinOsc}@@
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

*** Tweak it
**** Try changing the numbers.
     On your own---a minute or so to experiment.
     @@latex:\glsadd{release}@@
     - Run \cd{a.release} before re-running the synth.
     - What happens if you forget?
       - If you forget: press \ks{Ctrl-.} to stop everything.
       - \ks{Ctrl-.} is SC's panic button.
**** Be careful with the third number!			       :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     If it's too high, you could hurt your ears.
**** What do you think the numbers mean?

*** Easier tweaking: ProxySpace
**** \clss{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \clss{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
      @@latex:\glsadd{ProxySpace}\glsadd{VarSaw}\glsadd{dup}\glsadd{SinOsc}\glsadd{play}\glsadd{stop}@@
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

*** Important idea: /Modular/ design
**** A \te{modular} approach breaks a problem into smaller pieces.
    - For synthesis, it means you can play with the different pieces independently.
#+name: ps2
#+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

** SC language syntax
*** Taking it apart
**** Now we know enough to step back and see what this is made of.
     - This part is a little dry and technical.
     - But, to talk about SC, you need to know some important terms.

*** Taking it apart: Functions
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-02-function.pdf]]
     #+end_center
***** A \clss{Function} is a block of code in curly braces.
     - Functions can take information in through \egls{arguments}.
     - They always return one result.
     - \te{Call} a function using \mth{value}.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg x, y; sqrt(x.squared + y.squared) };

f.value(3, 4);  // prints "5"
#+end_src
# **** More about functions later.

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** A \egls{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \mth{release} the synth. So, save the \clss{Synth} object in a variable.
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Declared} variables
     - Any function can \egls{declare} variable names.
     - Declared variables exist only inside that function! \\
       This is called \egls{local} scope.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{interpreter} variables
      - Single letters \cd{a}--\cd{z}. 
      - \eGls{global} scope. Interpreter variables may be used anywhere
       	(unless a function declares a single-letter variable).
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** ProxySpace uses environment variables for synth nodes.

*** Taking it apart: Classes
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-03-class.pdf]]
     #+end_center
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** A \egls{class} is an \te{object type}.
       Classes define two things:
       - Data :: Objects remember specific information. \\
       	 E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
       - Actions :: Objects know how to do specific things. \\
       	 E.g., You can add two \ci{Point}s together: \cd{point1 + point2}. \\
       	 The \cd{Point} \te{class} declares how a Point should do \cd{+}.
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \ugen{SinOsc} is a \egls{UGen} (Unit Generator) class.
       - Unit generators are audio-processing operations in the server.
       - UGen classes in SC language:
	 - /Name/ the audio processors.
	 - /Connect/ UGens together.

*** Taking it apart: Methods
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-04-methods.pdf]]
     #+end_center
***** A \egls{method} defines an action that an object can perform.
      It's like a function, but it has a name and belongs to a class.
      - \mth{ar} :: Makes an \te{audio rate} instance of \ugen{SinOsc}.
      - \mth{dup} :: Copies the mono signal from \ugen{SinOsc} into both left and right channels.
      - \mth{play} :: Makes a \te{synth node} from the function. \\
       	\mth{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

*** Taking it apart: Arguments
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-05-args.pdf]]
     #+end_center
***** \eGls{arguments} pass information into a method or function.
      - In general, UGens take numbers or signals as inputs.
      - They generate signals as output.
      - \ugen{SinOsc}'s arguments are:
       	- freq :: In Hz.
       	- phase :: In radians (0--$2\pi$).
       	- mul :: Amplitude.
       	- add :: An offset (generally not used for audio).

*** Syntax
**** \te{Syntax}: Rules defining "legal" expressions.
E.g., \cd{x + y} is legal, while \cd{x y + 3} is not. You can't have \cd{x} and \cd{y} next to each other with only a space in between.
**** SC language syntax is all about /calling methods/.
Everything happens in SC through method calls. *Everything.*\\
(Except variable \egls{assignment}: \cd{x = 1}.)

*** Parts of a method call
**** A \gls{method call} consists of three parts:
    - \Gls{receiver} :: The object that will perform the method.
    - \Gls{selector} :: The method's name.
    - \Gls{arguments} :: Additional input (optional).
\\
In \cd{SinOsc.ar(440)}:
    - Receiver = the class \cd{SinOsc}
    - Selector = \cd{ar}
    - Argument = \cd{440}

*** Method call syntax
**** Three ways to call methods in SC.
    - "Dot" style :: \cd{receiver.selector(arguments...)}
    - Function style :: \cd{selector(receiver, arguments...)}
    - Infix style :: \cd{receiver selector: argument} \\
      Infix style allows only one argument. \\
      Binary operators (\cd{+}, \cd{-}, \cd{*}, \cd{/}, \cd{**}) are methods that use infix style.
      In \cd{1 + 2}: Receiver = 1, Selector = '+', Argument = 2
#+Name: callstyles
#+Caption: Three styles of method calls. They all answer with the same result, because the receiver, selector and argument are the same.
#+begin_src {} -i
[2.pow(3), pow(2, 3), 2 pow: 3]
// answers: [ 8, 8, 8 ]
#+end_src

*** Beginning usage: Summary 1
**** Write audio processing into a \clss{Function}.
     - These functions should create \eglspl{UGen}: \cd{SinOsc.ar} or \cd{.kr}.
     - \cd{aFunction.play} /adds/ new synthesis into the server.
**** \clss{ProxySpace} for plug-and-play.
     - Automatically turns functions into synthesis.
     - Reassigning an environment variable /replaces/ synthesis.
**** \te{Modular} style of writing.
     - Use /small/ synthesis functions.
     - Connect them by using the environment variable in another UGen's inputs.

*** Beginning usage: Summary 2
**** \eglspl{UGen} (Unit Generators)
     - Input signals \to UGen \to Output signal
     - Connections: UGen A's output \to UGen B's input
**** Important SC language concepts
     - \gls{class} :: An object definition: /Data/ and /actions/
     - \gls{method} :: An action that an object that knows how to perform.
     - \gls{variable} :: A placeholder for an object (a reference to it).
     - \gls{arguments} :: Inputs to a function or method. UGens are created by the \ci{ar} and \ci{kr} methods; here is where you write the input signals.

*** Next: Synthesis techniques
    Now we know enough to start exploring standard synthesis techniques.

* Subtractive synthesis						   :noexport:
** Overview
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** Syntax alert! Arguments
**** Function \gls{arguments} using vertical pipe characters
     \cd{|ffreq = 2000|} means the same as \cd{arg ffreq = 2000;}.
     - ffreq :: The argument name.
     - 2000 :: The argument's default value.
**** Arguments are magical in synthesis functions.
     - They automatically become \gls{control inputs}.
     - You can set the value from outside, and it changes the sound inside.
     - One synthesis function can make many frequencies, amplitudes, filtering behaviors etc.

*** Syntax alert: Argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an \egls{exponential} curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: \eGls{exponential}.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[./img/three-waves2.png]]
   #+end_center
\\ *Note:* Band-limited triangle oscillators may be found in the
sc3-plugins package.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%). \\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     We like small imperfections: Human players are never exactly in tune.
**** Do the same in a synth.
#+name: detune
#+caption: Detuning the oscillator.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}. \\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array. \\
      \cd{freq * [1, detun, detun.reciprocal]} \\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
#+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_src {} -i
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_src

*** Multichannel expansion is super cool
**** Parallel processing of multiple channels is very common.
     Multichannel expansion makes it easy (in the basic cases): Just
     write the processing as if for one channel, and SC automatically
     duplicates it for all channels.

     Max/MSP is effectively limited to only the third, most redundant,
     form. You have to copy the whole signal-processing chain for each
     channel /by hand/.

     Since multichannel processing is more convenient in SC, you'll do
     more of it and get more interesting sounds.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;
	
p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[./img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}: \\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses \ci{rq} = $\frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.

* Note control
** Playing notes by envelopes
*** Playing separate notes
**** What defines a "note"?
     Mainly, it has a beginning and end!
**** How do we give a note a beginning and end?
     Standard way: \eGlspl{envelope}.
     - This is a standard feature of all synthesizers, including VST/AUs.
*** Breakpoint envelopes
**** Usually, envelopes are defined in terms of \eglspl{breakpoint}.
     This funny-shaped envelope has four segments, defined by five breakpoints.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
#+Name: env1
#+Caption: Plotting a breakpoint envelope.
#+Begin_src {} -i
Env(
   levels: [0, 1, 0.2, 0.6, 0],
   times: [0.1, 0.3, 0.8, 0.25],
   curve: [\lin, -4, 5, -2]
).plot;
#+end_src
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
# #+name: env1png
# #+caption: 
#+attr_latex: :width 0.4\paperwidth
[[./img/breakpoint-env.png]]
**** Graphic comes from						   :noexport:
w = Window("env", Rect(800, 200, 400, 300)).front;
x = EnvelopeView(w, w.view.bounds.insetBy(2, 2)).setEnv(e);

*** Envelope definition
**** An envelope is made of:
     - A starting value
     - A number of \eglspl{segment} (no practical limit):
       - A target level
       - A time duration
       - A segment shape (curve)
     - A \egls{releaseNode} and \egls{loopNode} (optional)
**** Note the difference between the /starting value/ and the segments' /target values/.
     This will become important later.

*** Writing an envelope definition
**** It's written like this:
#+begin_latex
\cd{Env(\\<all>
\hspace{0.5cm}levels: [start, level$_0$, level$_1$, level$_2$...],\\<all>
\hspace{0.5cm}times: [time$_0$, time$_1$, time$_2$...],\\<all>
\hspace{0.5cm}curve: [curve$_0$, curve$_1$, curve$_2$...],\\<all>
\hspace{0.5cm}releaseNode: nil, loopNode: nil\\<all>
)}
#+end_latex
**** Notes
     - Segment 0 is defined by @@latex:\cd{levels[\textbf{1}]}@@,
       \cd{times[0]} and \cd{curve[0]}.
     - \cd{levels[0]} is the starting value---not part of any segment!
     - \ci{curve} may be an array or a single value (which applies to
       every segment).

*** Add an envelope to the synth
**** Audio synths should have an amplitude envelope.
     - Start from silence, end with silence.
#+latex: \glsadd{EnvGen}\glsadd{Impulse}
#+Name: ampenv1
#+Caption: Apply an evenly-triggered amplitude envelope.
#+Begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq) };
~filter.addSpec(\ffreq, \freq);
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };

~out = { (~filter.ar * ~eg).dup }; ~out.play;

~out.stop;  // We'll use these proxies some more
#+End_src

*** Envelope generator UGen
# deliberately no caption: Don't want this numbered or collated
#+Begin_src {} -i
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };
#+End_src
**** \clss{Env} defines the envelope. \ugen{EnvGen} plays it.
     - Inputs used here:
       - envelope :: The \clss{Env} definition.
       - gate :: The trigger or gate input. (More about gates later.)
     - Its output is a signal which:
       - Starts at 0;
       - Rises quickly to 1 over 0.01 seconds every time a trigger comes into \ci{gate};
       - Falls back to 0 over 0.6 seconds.

*** Triggers
**** Plot code							   :noexport:
{ var trig = Impulse.ar(300);
   [trig, EnvGen.ar(Env.perc(0.01, 0.6), trig, timeScale: 1/300)]
}.plot;
**** A \egls{trigger} happens when a signal crosses from $\le$ 0 to > 0.
     - Many UGens respond to triggers.
     - Here, the trigger signal consists of \eglspl{impulse}.
     - Common trigger UGens:
       - \ugen{Impulse} :: Impulses at a constant frequency.
       - \ugen{Dust} :: Impulses at random durations, according to an average density.
#+Begin_center
#+attr_latex: :height 1in
[[./img/trigger-and-envgen.png]]
#+End_center

*** Envelope generator as amplifier
**** Amplifier is multiplication (\ci{*}).
#+Begin_src {} -i
~out = { (~filter.ar * ~eg).dup }; ~out.play;
#+End_src
     Amplitude envelope is usually last in the chain.
     - Here, it's in an \cd{\textasciitilde out} proxy.
     - \cd{\textasciitilde out} is the one that gets played.
#+begin_center
#+attr_latex: :height 1.5in
[[./img/visualize-proxy-network.pdf]]
#+end_center

*** Explore envelope behavior
**** Add two parameters: trigger frequency and decay time.
     Try these settings. Why do they sound like that?
     - Normal decay, high trigger rate > 30.
     - Short decay, high trigger rate.
     - Long decay > 1, medium trigger rate $\approx$ 3.5.
#+Name: ampenv2
#+Caption: Add parameters to the envelope generator.
#+Begin_src {} -i
~eg = { |tfreq = 1, decay = 0.6|
   EnvGen.kr(
      Env([0, 1, 0], [0.01, decay], -4),
      Impulse.kr(tfreq)
   )
};
~eg.addSpec(\tfreq, [0.5, 50, \exp]);
~eg.addSpec(\decay, [0.05, 1.5, 2]);
p.gui;
#+End_src

*** Envelope graphs
**** Plot functions						   :noexport:
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300) }.plot;
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** Initial settings
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope has plenty of time to fall to 0 (silence) between
       notes.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-normal-d0.6-f1.png]]
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** Same decay, much faster triggers
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope doesn't have enough time to decay, so the sound is
       almost continuous.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.6-f30.png]]
***** O3 							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
****** Fast triggers, very short decay.
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope decays quickly, so the sound gets much quieter
       between triggers. But the triggers come very quickly---30 Hz is
       within audio range---so we hear a strong \egls{amplitude modulation}
       effect, adding another pitch.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.05-f30.png]]
***** O4							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
****** Medium triggers, long decay
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       You can hear the envelope decay, but it doesn't go all the way
       to silence. So the effect is more like /legato/ playing.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d1.12-f3.png]]

# #+Name: ampenv2
# #+Caption: Add parameters to the envelope generator.
# #+Begin_src {} -i
# {
#    [
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300)
#    ]
# }.plot;
# #+End_src

** Timed and sustaining envelopes
*** Standard envelope shapes: Timed
    - \mth{linen} :: Linear attack and decay, flat sustain.
    - \mth{perc} :: Curved attack and decay, no sustain.
    - \mth{sine} :: Sine-shaped attack and decay, no sustain.
#+name: tryEnv1
#+caption: Try plotting these timed envelope shapes. Modify the example to try the other methods. Use auto-completion to see the parameter names and defaults.
#+begin_src {} -i
Env.linen(0.1, 1, 0.1).plot;
#+end_src

*** Sustaining envelopes (OK with \glspl{gate})
    *Note:* For these two, \ci{sustain} is a level, not a time.
    - \mth{adsr} :: Attack-Decay-Sustain-Release.\\
      This is one of the most standard envelope types, found in
		    almost any synthesizer.
    - \mth{asr} :: Same as \ci{adsr}, but without the decay
		   portion.
#+name: tryEnv2
#+caption: Try plotting these sustaining envelope shapes.
#+begin_src {} -i
Env.adsr(0.1, 0.25, 0.5, 0.2).plot;
#+end_src

*** Sustaining envelopes
**** Why sustaining envelopes?
     - When playing on a MIDI keyboard, you don't know in advance how long to sustain.
     - So you need an envelope that will wait for a signal to release.
**** \egls{releaseNode} creates a sustaining envelope.
     - The release node is the release segment's index.
     - For example, ADSR has:
       - Attack: Segment 0
       - Decay: Segment 1
       - Release: Segment 2
     - So releaseNode is 2.

*** Sustaining envelopes and gates
**** Plot code							   :noexport:
{ var trig = Impulse.ar(30);
	trig = Trig1.ar(trig, TRand.ar(1/120, 1/40, trig));
	[trig, EnvGen.ar(Env.adsr(0.01, 0.1, 0.5, 0.01), trig, timeScale: 1/30)]
}.plot(0.1);

{ var trig = Impulse.kr(1);
    trig = Trig1.kr(trig, TRand.kr(3/12, 3/4, trig));
    [trig, EnvGen.kr(Env.adsr(0.01, 0.1, 0.5, 0.2), trig)]
}.plot(2);
**** That signal is a \egls{gate}.
     - A gate is > 0 when open, and $\le$ 0 when closed.
     - \ugen{EnvGen} triggers when a gate opens, and releases when it closes.
     Note the effect of the different open/close times.
#+Begin_center
#+attr_latex: :height 1.5in
[[./img/gates-and-env.png]]
#+End_center

*** Sustaining envelope in ProxySpace
**** Replace the timed envelope with a sustaining envelope.
     - No longer a trigger, so change \ci{t\textunderscore trig} to \ci{gt}.
       - Normally a \clss{SynthDef} calls the gate input \ci{gate},
         but that's reserved for another use in \clss{ProxySpace}.
     - Use \mth{set} to open and close the gate.
#+name: susEnv
#+caption: Plug a sustaining envelope into the analog-style synth.
#+begin_src {} -i
~eg = { |gt = 0|
   EnvGen.kr(
      envelope: Env.adsr(0.01, 0.15, 0.4, 0.1),
      gate: gt
   )
};

~eg.set(\gt, 1);  // trigger
~eg.set(\gt, 0);  // release
#+end_src

** Events and envelope gaets
*** More convenience for gates: Events
**** Sequencing: inconvenient to close gates by hand.
     Introducing \clss{Event}.
     - We will learn more about events as we go.
     - Events have lots of pryoperties, including timing.
       - \ci{dur} :: Number of beats until the next event.
       - \ci{sustain} :: Number of beats to keep a gate open. (May
                         also be calculated from \cd{dur * legato}.)

*** Events with ProxySpace
    - In \clss{ProxySpace}, a special event type can set parameters globally in the entire space.
      - \mth{setEvent}
    - This event type handles \ci{gt} specially.
      - It automatically closes the gate if you provide a \ci{sustain} time.
      - So, for this usage pattern, get used to using \ci{gt} for gates.
#+name: gateEvent
#+caption: Hold a gate open for a given amount of time using an Event.
#+begin_src {} -i
p.setEvent((gt: 1, sustain: 0.5)).play;
p.setEvent((gt: 1, sustain: 3)).play;
#+end_src

*** Coordinated changes with Events
**** An \clss{Event} can set lots of controls at once.
     - Just list them in the same \cd{name: value} syntax.
     - If the name exists anywhere in the \clss{ProxySpace}, the event will find it and set it.
     - \mth{exprand}: random frequency according to an \egls{exponential} scale.
     - \mth{degree}: interprets \mth{rrand} number as a diatonic scale degree.
# nb: \mth{degree} is actually listed in the main glossary
#+name: multiSetEvent
#+caption: Set both frequency and gate.
#+begin_src {} -i
p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;

p.setEvent((degree: rrand(-14, 0), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
     We are now /centimeters/ away from sequencing!

** Another envelope use: Articulation
*** Envelopes for articulation
**** Envelopes can control any parameter.
     /Very/ common: control the filter frequency, for articulation.
     - Create a new \ugen{EnvGen}, as a multiplier for \ci{ffreq}.
     - Use it in the \ci{\textasciitilde filter} module.
#+latex: \glsadd{clip}
#+name: filterEg
#+caption: Apply an envelope to the filter frequency.
#+begin_src {} -i
~feg = { |gt = 0|
   EnvGen.kr(Env([1, 4, 1], [0.01, 0.15], -4), gt)
};

~filter = { |ffreq = 2000, rq = 0.2|
   RLPF.ar(~oscil.ar,
      clip(ffreq * ~feg, 20, 20000),
      rq
   )
};

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src

*** Notes on that example
**** Filter envelope as a multiplier.
     - The envelope /modulates/ the set filter frequency. You get
       articulation /and/ independent timbre control.
     - \cd{ffreq * \textasciitilde feg} may go outside the valid
       frequency range. \mth{clip} it for safety.
       - \mth{clip} moves out-of-range values to the nearest boundary.
       - Filters tend to blow up if the frequency goes out of range.
**** \cd{p.setEvent} treats the control inputs globally.
     - \cd{gt: 1} in the event sets \ci{gt} in both envelope modules
       simultaneously.

*** Articulation: Noise oscillator with envelope
**** With envelopes, we can use a noise generator.
     - A classic analog synthesizer trick for a "chff" in the attack.
     - Add a short, percussive (\cd{Env.perc}) burst of noise.
     - Usually use a \clss{BPF} to color the noise.
**** Typical noise generators
     - \ugen{WhiteNoise} :: Very bright, harsh noise.
     - \ugen{PinkNoise} :: Still bright, but more pleasant than white noise.
     - \ugen{BrownNoise} :: Darker sound. Named after \egls{Brownian motion}, not the color.

*** Add a noise attack to the previous example
    Based on Listing [[filterEg]].
#+name: noiseAtk
#+caption: Create a noise generator, and an envelope and filter for it.
#+begin_src {} -i
~noiseEg = { |gt, noiseDur = 0.08|
   EnvGen.kr(Env.perc(0.01, noiseDur), gt)
};
~noise = { |noiseAmp = 0.8|
   PinkNoise.ar(noiseAmp * ~noiseEg)
};
~noiseFilt = { |ffreq = 11000, rq = 0.34|
   BPF.ar(~noise.ar, ffreq, rq).dup
};
~noiseFilt.play;

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
**** You can also add an envelope to the \ugen{BPF} frequency.
     Exercise for you.
**** Settings for a BPF frequency envelope			   :noexport:
ffreq = 2300
~noiseFeg = { |gt|
   EnvGen.kr(Env.perc(0.01, 0.2), gt)
   .linexp(0, 1, 1, 4)
};

*** Note control summary: Envelopes
**** \eGls{breakpoint} \eglspl{envelope}
     - Idea: Start level, list of segments
     - Written in \clss{Env} using three arrays: \ci{levels}, \ci{times}, \ci{curve}
**** \eGls{envelope generator}
     - Renders the segments into a signal.
     - Responds to \eglspl{trigger} and \eglspl{gate}.
**** Triggers and gates: signal > 0
     - A \te{trigger} is instantaneous, when the signal becomes > 0.
     - A \te{gate} is open when > 0, closed otherwise.

*** Note control summary: Gates and Events
**** \eGlspl{gate} must be opened and closed.
     - By hand, using \cd{\textasciitilde something.set(\textbackslash gt, 1)} or \cd{0}.
     - An \clss{Event} can close the gate for you, after a given \ci{sustain} time.
       - \ci{sustain} can be given directly, or you can provide \ci{dur} and \ci{legato}.
**** Events can set many parameters at once.
     Very useful for sequencing: The start of a note can change pitch,
     amplitude, timbre controls all at once.

* Sequencing
** Overview: Routines and Tasks
*** Sequencing: Basic requirements
**** For sequencing, we need:
     - /Musical/ information (pitch, timbre controls, etc.)
     - /Rhythm/ information:
       - How long to hold a note
       - How long to wait until the next note
     - Ways to do things /repeatedly/.
     - A way to /pause/ activity for some time, and resume exactly where it left off.

*** Pausing: Routine
**** In SC, a \clss{Routine} can pause and resume.
     - Routines \mth{yield} values.
     - Call \mth{next} to advance to the next \mth{yield}.
     - The routine will give back the value, and wait at exactly that point.
     - The next \mth{next} call will advance from there.
#+name: routine1
#+caption: A simple routine. Run r.next four times. How would you explain the results?
#+begin_src {} -i
r = Routine {
   1.yield;
   3.yield;
   5.yield;
};

r.next;
#+end_src

*** Repeated actions: Loops
**** Computer languages use \eglspl{loop} to do things again and again.
     - It's inconvenient to write \mth{yield} again and again.
     - We can use a \egls{loop} to write \mth{yield} once, but run it several times.
**** Loops make it easier to write bigger programs.
     - The last example yielded three values.
     - What if I want to yield 100 values?
     - Using a loop, I can write the values into a \egls{collection},
       and write the action only once.

*** Do loops
**** \mth{do} loops
     - \mth{do} runs a \clss{Function} several times.
     - We'll put the desired values into an \clss{Array}, then \mth{do} over it.
     - If \ci{func} is the function, this loop calls:
       - \cd{func.value(1, 0)}---1 is the item; 0 is its index
       - \cd{func.value(3, 1)}
       - \cd{func.value(5, 2)}
     - The array could be 100 items, but the \mth{do} function can stay the same.
#+name: do1
#+caption: A do loop.
#+begin_src {} -i
[1, 3, 5].do { |item|
   item.postln;
};
#+end_src

*** Do loop output
**** Let's look at the printed output from Listing [[do1]].
     - 1, 3 and 5 are easy enough to understand.
#+begin_src {} -i
1
3
5
[ 1, 3, 5 ]
#+end_src
**** Why is the \clss{Array} repeated at the end?
     - Every code block returns something as its result.
     - \mth{do} returns its \egls{receiver}, which is the array.
     - So: 1, 3 and 5 are printed inside the \mth{do} loop.
     - \cd{[ 1, 3, 5 ]} is returned by \mth{do} itself, and printed as
       the result of the whole code block.

*** Loops: When to stop
**** Without a \clss{Routine}, a \gls{loop} must stop somehow.
     - In Listing [[do1]], it stops at the end of the array.
     - \cd{5.do...} would run the function five times and stop.
     - \cd{inf.do...} will hang SC language. *Don't do that.*
       - \Gls{infinite loop} :: A loop with no end. Locks up the
            interpreter until you force-quit.
**** Use the /Language/ menu $\to$ /Quit interpreter/ to regain control. :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     Once the interpreter is locked, you can't run any code. Killing
     it is the only option.

*** Routines and yielding within loops
**** You may \mth{yield} inside a \mth{do} loop.
     Or any other kind of loop.
#+name: routine2_do
#+caption: A simple routine with a do loop. Run r.next four times.
#+begin_src {} -i
r = Routine {
   [1, 3, 5].do { |item|
      item.yield;
   };
};

r.next;
#+end_src
     - Same behavior as the earlier routine, but now easier to expand
       (just write a longer array).

*** Infinite loops in Routines
**** You /can/ write an \gls{infinite loop}, if it \mth{yield}s from a \clss{Routine}.
     - \mth{yield} means that the routine temporarily gives up control: No lockup.
     - The routine can produce an infinite number of values.\\
       Of course, you can never /ask for/ an infinite number!
**** Shortcut for an infinite loop: \ci{loop}.
     - *Never* use this without \mth{yield}!
#+latex: \glsadd{rrand}
#+name: routine2_do
#+caption: A simple routine with a infinite loop. Run r.next as many times as you like.
#+begin_src {} -i
r = Routine {
   loop {
      rrand(1, 10).yield;
   }
};

r.next;
#+end_src

*** Routines: Sequences of values
**** Now we know how to make sequences of values.
     - \mth{yield} values from a \clss{Routine}.
     - Any length sequence---even infinite!
     - Get values one by one using \mth{next}.
**** \clss{Routine} is a type of \clss{Stream}.
     - A \clss{Stream} responds to \mth{next} with its sequence's next value.
     - For example, a \clss{File} is a kind of stream, returning the
       file's characters one by one for \mth{next}.

** Time control: Clocks and scheduling
*** Timing
**** To play musical sequences, we need rhythm.
     Two key concepts:
     - \eGlspl{scheduler} :: An object that handles timing. Schedule
          actions to take place at a given time. The scheduler will
          "awaken" the action at the right time.
     - \eGlspl{delta} :: The amount of time between successive
                         events. Formally called "inter-onset
                         interval" or \egls{IOI} for short.

*** Scheduling
**** \eGlspl{scheduler} make something happen at a specific time in the future.
     - A scheduler is a \clss{Clock}. Most commonly used:
       - \clss{TempoClock} :: Adjustable tempo, given in beats per second (bps). Time is measured in \eglspl{beat}. Normally used for musical sequencing.
**** Scheduling methods
     - \mth{sched} :: Time is given as a number of beats later than "now."
     - \mth{schedAbs} :: Time is given as an absolute time point.

*** Scheduler usage
     Note that the order of the statements doesn't matter to the
     scheduler. The functions run at the /scheduled/ time, no matter
     which one went into the scheduler first.
#+name: sched1
#+caption: Scheduling simple actions. Run the blocks and watch the post window.
#+begin_src {} -i
(
"Right now".postln;
TempoClock.sched(1, { "one".postln });
TempoClock.sched(2, { "two".postln });
)

(
TempoClock.sched(2, { "two".postln });
"Right now".postln;
TempoClock.sched(1, { "one".postln });
)
#+end_src

*** Automatic rescheduling
**** Returning a number will /reschedule/ the action.
     - The number is a \egls{delta} time into the future.
**** *IMPORTANT:* Do not return delta $\le$ 0 accidentally!    :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     - If the return value is always $\le$ 0, it will lock up the interpreter.
     - To be safe, when scheduling a function, write \cd{nil} as the
       last expression.
#+name: resched1
#+caption: Automatic rescheduling. You'll have to use ctrl-. to stop it.
#+begin_src {} -i
(
var x = 0;
TempoClock.sched(1, {
   x = x + 1;
   x.postln;
   0.5  // this is the delta time
});
)
#+end_src

*** Rescheduling routines
**** A \clss{Routine}'s return value is \mth{yield}ed.
     - So, \mth{yield} the \gls{delta} time.
     - You can also write \mth{wait}.
**** Because it's a Routine, you can \mth{stop} it.
#+name: resched2
#+caption: Automatic rescheduling of a Routine with ``wait.''
#+begin_src {} -i
(
r = Routine {
   var x = 0;
   loop {
      x = x + 1;
      x.postln;
      0.5.wait;
   }
};

TempoClock.sched(1, r);
)

r.stop;
#+end_src

** Sequencing of notes
*** Note sequencing
**** To play notes, do it before \mth{wait}.
     - \cd{\textasciitilde out.set}: Trigger the envelope and set a new pitch.
     - Note \mth{play} here: More convenient than \cd{TempoClock.sched}.
#+name: noteseq1
#+caption: Note sequencing in a Routine.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~out = { |freq = 440, t_trig = 1|
   var eg = EnvGen.kr(Env.perc(0.01, 0.5), t_trig);
   (VarSaw.ar(freq) * eg * 0.1).dup
};
~out.play;

r = Routine {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
}.play;

r.stop;
#+end_src

*** Task and Tdef
**** \clss{Task} is like \clss{Routine}, with one advantage:
     - \mth{stop}ping a \clss{Routine} stops it permanently. You can
       only \mth{reset} back to the beginning.
     - After \mth{stop}ping a \clss{Task}, you can re-\mth{play} it
       and it will continue from the middle.
**** \clss{Tdef} is global storage for Tasks.
     - \mth{play} and \mth{stop} it just like a \clss{Task} or \clss{Routine}.
     - Get a play/stop control panel from \clss{TdefAllGui}.
     - You can switch the \clss{Tdef} function at any time.
       - This is like switching a synthesis function in a \clss{NodeProxy}.
**** Storage will become important later.

*** Graphical control of Tdef
#+name: tdef1
#+caption: Using Tdef for graphical control and replacing sequencing functions on-the-fly.
#+begin_src {} -i
Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
});

TdefAllGui.new;

Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(440, 1760));
      0.125.wait;
   };
});
#+end_src

*** Using ProxySpace-set Events
**** Remember the \clss{Event} type from "Events with ProxySpace"?[fn:1]
     - You can use \cd{p.setEvent((...))} in a \clss{Task} as well.
     - This is much easier than setting the controls individually on
       specific \clss{NodeProxy} objects.
#+name: tdefEvent
#+caption: Replace out.set with Events.
#+begin_src {} -i
Tdef(\player, {
   loop {
      p.setEvent((t_trig: 1, freq: exprand(110, 440))).play;
      0.5.wait;
   };
});
#+end_src
**** There is another really good reason to use Events: \eGlspl{pattern}.

*** Routine summary
**** \clss{Routine}, \clss{Task}: Pausable operations
     - Do work, then \mth{yield} something.
**** \eGlspl{loop}: Write code once, do it many times.
     - \cd{number.do}: Do it $n$ times.
     - \cd{array.do}: Do it once for every item in the array.
     - Loops should always have a way to stop. Avoid \eglspl{infinite loop}.

*** Note sequencing summary
**** Note sequencing with \clss{Routine} and \clss{Task}
     1. Calculate new musical values (pitch, rhythm etc.).
     2. Set controls within the \clss{ProxySpace}. Use \mth{setEvent} for convenience.
     3. Yield the time until the next event: \cd{time.wait}. \glsadd{wait}
**** Storage and GUI control with \clss{Tdef}
     - Also allows you to replace the function without breaking the flow.


* Effects common in subtractive synthesis			   :noexport:
** Chorus
** Distortion
* Glossary							   :noexport:
# #+LaTeX: \glsaddall
# http://www.latex-community.org/forum/viewtopic.php?f=5&t=16833
#+LaTeX: \renewcommand{\glossarysection}[2][]{}
** Concepts
#+LaTeX: \printglossary[type=main]
** UGens
#+LaTeX: \printglossary[type=ugen]
** Other classes
#+LaTeX: \printglossary[type=class]
** Methods
#+LaTeX: \printglossary[type=mth]
* Footnotes

[fn:1] Events with ProxySpace: [[Events with ProxySpace]].

