#+startup: beamer

#+TITLE: SuperCollider Week, Day 1 \\ Introductory SC and Synthesis
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL: 

#+INCLUDE: "../slidehead.org"
# #+INCLUDE: "../printhead.org"

#+include: "../glossary.org"

* Resume export						    :B_ignoreheading:
  :PROPERTIES:
  :BEAMER_env: ignoreheading
  :END:

#+call: makegloss
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :results value latex
#+results: mthgloss

#+call: ugengloss
#+results: ugengloss

* Workshop introduction						   :noexport:
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001)
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou
     - Subjects: Electronic music production, Film music
**** Special interests:
     - Danceclub music
     - Real-time performance with computers

*** What is SuperCollider?
**** /Programming language/ for audio and composition
     - Created by James McCartney
     - Conceptual basis: SmallTalk
       - /Object-oriented/ like Java, but still fun (not like Java)
     - Syntax: More like C
**** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
**** Right							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

*** Workshop goals
**** Teach synthesis techniques by experimentation
     - SC lets us take apart synthesizer components, and put them back together
     - SC's /Just-In-Time library/ makes it easy to re-patch components interactively
**** Teach techniques for live control and performance
     - Control by graphic interfaces and external devices
     - End goal: A group composition, to perform together
**** *Have fun programming!*
     - Emphasis on /play/ over /correctness/

*** Audio programming before SuperCollider, 1
    Not a complete survey!
**** *Music \emph{n}* languages
     - Orchestra file to define synthesis
     - Score file (what to play, when)
     - Modern incarnation: /csound/
**** Lisp: *Common Lisp Music*, *Nyquist*
     - Music: Hierarchies of structure
     - Lisp: Data structures are hierarchical! Good for composition

*** Audio programming before SuperCollider, 2
**** Dataflow: *Max/MSP*, *Pure Data*
     Represent everything as signal flow
     - Good: Intuitive to wire up interfaces quickly
     - Bad:
       - Relatively weak data structures (hard to represent musical information in an articulate way)
       - Monophonic processes, easy; polyphonic, hard
       - Complexity barrier

*** Version history
**** McCartney's work before SuperCollider
     - /Synth-O-Matic/ (1990)
     - /Pyrite/ (scripting language for Max)
**** SuperCollider
     - SC1: Synth-O-Matic + Pyrite
     - SC2: Influence from SmallTalk
       - SC language is nearly complete
       - Notable audio processing inefficiencies
     - SC3 ("SC Server")
       - Audio processing is more efficient, by handling audio in a /server/ process

* SC architecture, usage					   :noexport:
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - \egls{scide}: SC Integrated Development Environment
       - Code editor, display, documentation
     - \egls{sclang}: SC language
       - IDE sends code to sclang
       - sclang runs the code, sends printed output back to IDE
     - \egls{scsynth}: SC synthesis server
       - sclang sends \gls{OSC} (Open Sound Control) messages to scsynth
       - scsynth sends audio to the hardware
       - May also reply to sclang

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[./img/sc-with-guis.pdf]]
    #+end_center

*** Why separate the functions?
**** If one component crashes, the others keep working.
     Especially important: The code window stays intact!
**** They work together like one unit.

*** Server/client design
**** *Server/client* design
     - Server does heavier work (e.g., databases)
     - Client makes requests of the server
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server. \\
       /Open Sound Control/ (\gls{OSC}) protocol
       - "Here's a /synthesis definition/."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

*** Why server/client?
**** Efficiency
     - Synthesis definitions are /reusable/. \\
       Optimizing a \clss{SynthDef} is relatively slow. Doing this
       once for thousands of notes is more efficient than once for
       every note.
**** Networked applications
     - Many clients can use the same server
**** Not limited to SC language
     - Any language that supports OSC can use SC audio!
     - Python, Clojure, Scala, Haskell, Scheme...
     - In free software, /user choice/ is important. Prefer /open/
       designs, rather than closed.

*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status
       - Server control (click on the server status)

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end \\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps					   :noexport:
** Making noise
*** Let's make some noise!
   1. Boot the audio server: \ks{Ctrl-B} \\
      See also /Language/ menu and server status. \\
      *Linux:* Start JACK before doing this.
   2. Type and run some code. \\
      Just run the first line at first.
      @@latex:\glsadd{play}\glsadd{release}\glsadd{dup}\glsadd{SinOsc}@@
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

*** Tweak it
**** Try changing the numbers.
     On your own---a minute or so to experiment.
     @@latex:\glsadd{release}@@
     - Run \cd{a.release} before re-running the synth.
     - What happens if you forget?
       - If you forget: press \ks{Ctrl-.} to stop everything.
       - \ks{Ctrl-.} is SC's panic button.
**** Be careful with the third number!			       :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     If it's too high, you could hurt your ears.
**** What do you think the numbers mean?

*** Easier tweaking: ProxySpace
**** \clss{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \clss{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
      @@latex:\glsadd{ProxySpace}\glsadd{VarSaw}\glsadd{dup}\glsadd{SinOsc}\glsadd{play}\glsadd{stop}@@
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

*** Important idea: /Modular/ design
**** A \te{modular} approach breaks a problem into smaller pieces.
    - For synthesis, it means you can play with the different pieces independently.
#+name: ps2
#+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

** SC language syntax
*** Taking it apart
**** Now we know enough to step back and see what this is made of.
     - This part is a little dry and technical.
     - But, to talk about SC, you need to know some important terms.

*** Taking it apart: Functions
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-02-function.pdf]]
     #+end_center
***** A \egls{function} is a block of code in curly braces.
     - Functions can take information in through \egls{arguments}.
     - They always return one result.
     - \te{Call} a function using \mth{value}.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg x, y; sqrt(x.squared + y.squared) };

f.value(3, 4);  // prints "5"
#+end_src
# **** More about functions later.

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** A \egls{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \mth{release} the synth. So, save the \clss{Synth} object in a variable.
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Declared} variables
     - Any function can \egls{declare} variable names.
     - Declared variables exist only inside that function! \\
       This is called \egls{local} scope.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{interpreter} variables
      - Single letters \cd{a}--\cd{z}. 
      - \eGls{global} scope. Interpreter variables may be used anywhere
       	(unless a function declares a single-letter variable).
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** ProxySpace uses environment variables for synth nodes.

*** Taking it apart: Classes
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-03-class.pdf]]
     #+end_center
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** A \egls{class} is an \te{object type}.
       Classes define two things:
       - Data :: Objects remember specific information. \\
       	 E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
       - Actions :: Objects know how to do specific things. \\
       	 E.g., You can add two \ci{Point}s together: \cd{point1 + point2}. \\
       	 The \cd{Point} \te{class} declares how a Point should do \cd{+}.
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \ugen{SinOsc} is a \egls{UGen} (Unit Generator) class.
       - Unit generators are audio-processing operations in the server.
       - UGen classes in SC language:
	 - /Name/ the audio processors.
	 - /Connect/ UGens together.

*** Taking it apart: Methods
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-04-methods.pdf]]
     #+end_center
***** A \egls{method} defines an action that an object can perform.
      It's like a function, but it has a name and belongs to a class.
      - \mth{ar} :: Makes an \te{audio rate} instance of \ugen{SinOsc}.
      - \mth{dup} :: Copies the mono signal from \ugen{SinOsc} into both left and right channels.
      - \mth{play} :: Makes a \te{synth node} from the function. \\
       	\mth{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

*** Taking it apart: Arguments
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-05-args.pdf]]
     #+end_center
***** \eGls{arguments} pass information into a method or function.
      - In general, UGens take numbers or signals as inputs.
      - They generate signals as output.
      - \ugen{SinOsc}'s arguments are:
       	- freq :: In Hz.
       	- phase :: In radians (0--$2\pi$).
       	- mul :: Amplitude.
       	- add :: An offset (generally not used for audio).

*** Syntax
**** \te{Syntax}: Rules defining "legal" expressions.
E.g., \cd{x + y} is legal, while \cd{x y + 3} is not. You can't have \cd{x} and \cd{y} next to each other with only a space in between.
**** SC language syntax is all about /calling methods/.
Everything happens in SC through method calls. *Everything.*\\
(Except variable \egls{assignment}: \cd{x = 1}.)

*** Parts of a method call
**** A \gls{method call} consists of three parts:
    - \Gls{receiver} :: The object that will perform the method.
    - \Gls{selector} :: The method's name.
    - \Gls{arguments} :: Additional input (optional).
\\
In \cd{SinOsc.ar(440)}:
    - Receiver = the class \cd{SinOsc}
    - Selector = \cd{ar}
    - Argument = \cd{440}

*** Method call syntax
**** Three ways to call methods in SC.
    - "Dot" style :: \cd{receiver.selector(arguments...)}
    - Function style :: \cd{selector(receiver, arguments...)}
    - Infix style :: \cd{receiver selector: argument} \\
      Infix style allows only one argument. \\
      Binary operators (\cd{+}, \cd{-}, \cd{*}, \cd{/}, \cd{**}) are methods that use infix style.
      In \cd{1 + 2}: Receiver = 1, Selector = '+', Argument = 2
#+Name: callstyles
#+Caption: Three styles of method calls. They all answer with the same result, because the receiver, selector and argument are the same.
#+begin_src {} -i
[2.pow(3), pow(2, 3), 2 pow: 3]
// answers: [ 8, 8, 8 ]
#+end_src

*** Beginning usage: Summary 1
**** Write audio processing into \eglspl{function}.
     - These functions should create \eglspl{UGen}: \cd{SinOsc.ar} or \cd{.kr}.
     - \cd{aFunction.play} /adds/ new synthesis into the server.
**** \clss{ProxySpace} for plug-and-play.
     - Automatically turns functions into synthesis.
     - Reassigning an environment variable /replaces/ synthesis.
**** \te{Modular} style of writing.
     - Use /small/ synthesis functions.
     - Connect them by using the environment variable in another UGen's inputs.

*** Beginning usage: Summary 2
**** \eglspl{UGen} (Unit Generators)
     - Input signals \to UGen \to Output signal
     - Connections: UGen A's output \to UGen B's input
**** Important SC language concepts
     - \gls{class} :: An object definition: /Data/ and /actions/
     - \gls{method} :: An action that an object that knows how to perform.
     - \gls{variable} :: A placeholder for an object (a reference to it).
     - \gls{arguments} :: Inputs to a function or method. UGens are created by the \ci{ar} and \ci{kr} methods; here is where you write the input signals.

*** Next: Synthesis techniques
    Now we know enough to start exploring standard synthesis techniques.

* Subtractive synthesis
** Overview							   :noexport:
*** Subtractive synthesis
**** One of the most basic techniques
     - Easy to implement
     - Easy and intuitive to control
**** "Analog style"
     - The technique goes back to Moog and before

*** Main idea of subtractive synthesis
**** /Take away/ (subtract) from a basic waveform
     Components
     - \Gls{oscillator} :: Produces a waveform with lots of harmonics
     - \Gls{filter} :: Takes away parts of the spectrum
# @@latex:\glsadd{Saw}\glsadd{LPF}@@
*** Simple translation into SC
#+Name: sub1
#+Caption: Oscillator and filter, the basis of subtractive synthesis.
#+Begin_src {} -i
p = ProxySpace.new;
p.push;

~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
~ffreq.gui;

p.clear;
#+End_src
**** New UGens
     - \ugen{Saw} :: A \egls{band-limited} sawtooth oscillator
     - \ugen{LPF} :: A Low-Pass Filter

*** Syntax alert! Arguments
**** Function \gls{arguments} using vertical pipe characters
     \cd{|ffreq = 2000|} means the same as \cd{arg ffreq = 2000;}.
     - ffreq :: The argument name.
     - 2000 :: The argument's default value.
**** Arguments are magical in synthesis functions.
     - They automatically become \gls{control inputs}.
     - You can set the value from outside, and it changes the sound inside.
     - One synthesis function can make many frequencies, amplitudes, filtering behaviors etc.

*** Syntax alert: Argument /ranges/
**** *Important idea:* UGen inputs have /meaningful ranges/.
     - For frequency, 20--20000 Hz.
     - For amplitude, 0.0--1.0 (corresponds to $-\infty$--0 dB).
     - We will see many more ranges.

*** Manipulating ranges
**** A UGen's \te{output range} is one of its most important characteristics.
     - Controlling synthesis is about manipulating these ranges.
     - \ugen{SinOsc}'s range is \te{bipolar}: $-1.0$--$1.0$.
     - Multiply by 0.5; now the range is $-0.5$--$0.5$.
     - Add 1; now the range is $0.5$--$1.5$.
**** Key questions:
     - What is the range I /get from/ a UGen?
     - What is the range I need to /put into/ a UGen?
     - How can I convert one to the other, mathematically?

*** Mapping interfaces to meaningful ranges
**** A user interface should map the physical range onto the meaningful range.
#+latex: \glsadd{addSpec}
     - In SC, sliders etc. always have the range 0.0--1.0.
     - A range \te{specification} tells SC the desired range.
     - @@latex:\cd{\textasciitilde filter.addSpec(\textbackslash ffreq,
       \textbackslash freq)}@@ attaches a range
       @@latex:\ci{\textbackslash freq}@@ onto
       @@latex:\ci{\textasciitilde filter}@@'s
       @@latex:\ci{\textbackslash ffreq}@@ argument. The \ci{gui}
       instruction then uses this range.
     - \ci{\textbackslash freq} is a predefined range: 20--20000 Hz,
       with an exponential curve (because you go up an octave by
       /multiplying/, not adding).

*** Writing ranges in SC
    - Long form: \clss{ControlSpec}\cd{(low, high, curve, step, default)}
    - Short form: \cd{[low, high, curve, step, default]}
**** Curves
     - \ci{\textbackslash lin} :: Linear.
     - \ci{\textbackslash exp} :: Exponential.
     - \ci{\textbackslash sin} :: Sine-shaped.
     - Number :: User-controllable curve.
**** Examples
    - Frequency :: \cd{[20, 20000, \textbackslash exp, 0, 440]}
    - Phase :: \cd{[0, 2pi, \textbackslash lin, 0, 0]} (in radians)
#     - Amplitude :: \cd{[0, 1, \amp]}

** Analog-style oscillators					   :noexport:
*** Sawtooth oscillator
**** A geometric \gls{sawtooth} is made of straight lines.
    This is a problem for digital audio.
    - The sharp corners produce theoretically infinite frequencies.
    - Digital audio cannot represent infinite frequencies!
    - Frequencies above the limit fold back into the audio
      range. Sounds ugly. This is called \egls{aliasing}.
    - Band-limited oscillators keep all the frequencies in the safe
      range.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim1
#+Caption: Compare geometric vs. band-limited waves, visually. LFSaw parameters are to match the Saw plot more closely. Maximize the window after running.
#+Begin_src {} -i
{ [LFSaw.ar(440, 1, -0.7), Saw.ar] }.plot;
#+End_src

*** Listen to the difference
**** *Note:* Turn down the server volume first!		       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    The high frequency is pretty irritating, but necessary to make the
    aliasing really obvious.
#+latex: \glsadd{LFSaw}\glsadd{Saw}
#+Name: bandlim2
#+Caption: Compare geometric vs. band-limited waves, aurally.
#+Begin_src {} -i
p.clear;
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };
~oscil.play;

// Go back and forth several times
~oscil = { Saw.ar(2400, 0.1).dup };
~oscil = { LFSaw.ar(2400, 0, 0.05).dup };

p.clear;
#+End_src
**** *Safety tip:* Use band-limited waves for audio oscillators.
     The geometric waveforms are OK for control signals.

*** Other typical waveforms
#+latex: \glsadd{pulse wave}\glsadd{triangle wave}
   #+begin_center
   #+attr_latex: :height 2in
   [[./img/three-waves2.png]]
   #+end_center
\\ *Note:* The upper partials of a triangle wave are much weaker than
in a sawtooth or pulse wave. So there is no band-limited triangle UGen
in SC.

*** Pulse width
**** \Gls{pulse wave}: Up and down times can differ
    - If equal, the \egls{pulse width} is 0.5 (50%). \\
      This is a \egls{square wave}.
    - If unequal, the sound is brighter and thinner.
#+latex: \glsadd{Pulse}\glsadd{VarSaw}
#+Name: bandlim2
#+Caption: Hear the effect of changing the pulse width.
#+Begin_src {} -i
p = ProxySpace.new.push;

(
~oscil = { |width = 0.5| Pulse.ar(440, width, 0.1).dup };
~oscil.play;

~oscil.addSpec(\width, #[0, 1]);
~oscil.gui;
)

~oscil = { |width = 0.5| VarSaw.ar(440, 0, width, 0.1).dup };

p.clear;
#+End_src

*** Detuned oscillators
**** The ear doesn't like sound that is too perfect.
     We like small imperfections: Human players are never exactly in tune.
**** Do the same in a synth.
#+name: detune
#+caption: Detuning the oscillator.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter.play;

~oscil.addSpec(\detun, [1, 0.5.midiratio, \exp]);
~filter.addSpec(\ffreq, \freq);
p.gui;

p.clear;
#+end_src

*** New language elements
#+Latex: \glsadd{BinaryOpUGen}\glsadd{UnaryOpUGen}
    - \ugen{Mix} :: Mix a group of signals together (addition).
    - \clss{Array} :: An ordered collection of items.
    - \mth{midiratio} :: Convert a number of semitones into a frequency factor.
    - \mth{reciprocal} :: Equivalent to \cd{1 / number}, but slightly faster.

*** Math on UGens
**** UGens respond to math operators!
     - \cd{aUGen * bUGen} \to \cd{BinaryOpUGen('*', aUGen, bUGen)}
     - \cd{detun.reciprocal} \to \cd{UnaryOpUGen('reciprocal', detun)}
     - Transparent to the user. In SC, there is no \cd{*\textasciitilde}: just use regular math operators.

*** Arrays of signals
**** \clss{Array}: A \gls{collection} (grouping of objects), in the order given.
     - Written and displayed in square brackets \cd{[ ]}.
     - An \gls{ordered} collection: Items stay in the same order.
     - More about arrays later.

**** An array of UGens represents multiple audio channels.
     - Already seen: \cd{SinOsc.ar.dup} \to \cd{[ a SinOsc, a SinOsc ]}. \\
       The two-item array represents a stereo signal.
     - \ugen{Mix} adds several signals (in an array) together, /mixing/ them:\\
       Three \ci{Saw}s \to one mixed channel.

*** Multichannel expansion
    \cd{Saw.ar(220 * [1, detun, detun.reciprocal], 0.1)}
    - Most UGens are monophonic: one channel in, one out.
    - Here, we provide a control input multiplied by an array. \\
      \cd{freq * [1, detun, detun.reciprocal]} \\ \to \cd{[freq * 1, freq * detun, freq * detun.reciprocal]}
**** How does a monophonic UGen cope with three frequencies?
     It performs \egls{multichannel expansion}, and makes three \ci{Saw}s.
#+name: mc-exp1
#+caption: Multichannel expansion.
#+begin_src {} -i
Saw.ar([1, 2, 3])

// prints: [ a Saw, a Saw, a Saw ]
#+end_src

*** Unpacking multichannel expansion
**** All three of these expressions are identical
#+begin_example
// Compact form
Mix(Saw.ar(220 * [1, detun, detun.reciprocal], 0.1))

// Expanding *
Mix(Saw.ar([
   220 * 1,
   220 * detun,
   220 * detun.reciprocal
], 0.1))

// Fully expanded
Saw.ar(220 * 1, 0.1),
   + Saw.ar(220 * detun, 0.1),
   + Saw.ar(220 * detun.reciprocal, 0.1)
#+end_example

*** Multichannel expansion is super cool
**** Parallel processing of multiple channels is very common.
     Multichannel expansion makes it easy (in the basic cases): Just
     write the processing as if for one channel, and SC automatically
     duplicates it for all channels.

     Max/MSP is effectively limited to only the third, most redundant,
     form. You have to copy the whole signal-processing chain for each
     channel /by hand/.

     Since multichannel processing is more convenient in SC, you'll do
     more of it and get more interesting sounds.

*** Detuning by octaves or other intervals
**** Standard analog-style plug-ins (e.g. Massiv) feature multiple oscillators.
     - Independent control over frequency, relative to MIDI key.
     - A bass might have a low square wave with higher saws above.
#+name: multiosc
#+caption: Multiple oscillator types together.
#+begin_src {} -i
~oscil = { |freq = 110|
   var freq1 = freq * [0.5, 0.498, 0.503],
   freq2 = freq * [1, 0.997, 1.004];
   Mix(Pulse.ar(freq1)) + Mix(Saw.ar(freq2))
};
~filter = { |ffreq = 3000| LPF.ar(~oscil.ar, ffreq, 0.1).dup };
~filter.play;

~filter.addSpec(\ffreq, \freq);
p.gui;
	
p.clear;
#+end_src

*** Subtractive synthesis: Oscillator summary
**** Oscillators so far
     - \ugen{Saw} :: Band-limited sawtooth
     - \ugen{VarSaw} :: /Non/-band-limited sawtooth, with width control
     - \ugen{Pulse} :: Band-limited pulse wave, with width control
**** Use band-limited waveforms for audio, whenever possible.
**** Mix together several detuned oscillators for a richer sound.
     - Multichannel expansion can help.

** Filters							   :noexport:
*** Filters
#+latex: \glsadd{Saw}\glsadd{LPF}\glsadd{HPF}
**** We identify filters based on their \egls{frequency response}.
Filters affect some frequencies more than others.
#+Name: filt1
#+Caption: Watch and listen to the effect of different filter types.
#+Begin_src {} -i
(
s.freqscope;
~oscil = { Saw.ar(220, 0.1) };
~filter = { |ffreq = 2000| ~oscil.ar.dup };  // no filter
~filter.play;
~filter.addSpec(\ffreq, \freq);
~filter.gui;
)

// Swap different filters in and out.
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000| HPF.ar(~oscil.ar, ffreq).dup };
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src

*** Basic filter types
**** The most basic types of filters are:
     - Lowpass \ugen{LPF} :: Allow low frequencies to pass through. Cut high frequencies.
     - Highpass \ugen{HPF} :: Allow high frequencies to pass through. Cut low frequencies.
     - Bandpass \ugen{BPF} :: Allow a range in the middle to pass through. Cut high and low.

*** Butterworth filters
**** \ugen{LPF} and \ugen{HPF} are \te{Butterworth filters}.
    The frequency response curve is smooth, no bumps.
#+Begin_center
#+name: linearcurves
#+Caption: Frequency responses of different filter implementations. Image credit: Alessio Damato, http://commons.wikimedia.org/wiki/File:Electronic_linear_filters.svg.
#+attr_latex: :height 2.2in
[[./img/750px-Electronic_linear_filters.svg.png]]
#+End_center

*** BPF: Bandwidth
**** \ugen{BPF} needs to know how wide a band.
    - Set by \egls{Q}: the filter's \egls{quality}.
    - Higher Q, narrower band.
    - SC uses \ci{rq} = $\frac{1}{Q}$ because multiplication is faster than division.
Close the old GUI window, and try different \ci{rq} values.
#+latex: \glsadd{BPF}
#+Name: filtbw
#+Caption: Move rq and ffreq, and hear the effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~oscil.ar, ffreq, rq).dup
};
~filter.addSpec(\rq, #[1, 0.05, \exp]);
~filter.gui;
#+End_src
**** Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More pitched

*** Q and resonance
**** \ugen{RLPF} and \ugen{RHPF} add \te{resonance}.
    - Resonance is a "bump" around the cutoff frequency.
    - At high cutoff frequencies, sounds like whistling.
    - \te{Q} behaves as in \ugen{BPF}: \\
      Low \ci{rq} $\longleftrightarrow$ High \te{Q} $\longleftrightarrow$ More resonance
#+latex: \glsadd{RLPF}
#+Name: rlpf
#+Caption: Move rq and ffreq, and hear the lowpass-filter effect.
#+Begin_src {} -i
~filter = { |ffreq = 2000, rq = 0.1|
   RLPF.ar(~oscil.ar, ffreq, rq).dup
};
#+End_src
**** Also try \ugen{RHPF} (on your own).

*** Subtractive synthesis: Filter summary
**** Filters so far
     - \ugen{LPF} :: Lowpass filter (no resonance)
     - \ugen{HPF} :: Highpass filter (no resonance)
     - \ugen{RLPF} :: Lowpass filter /with/ resonance
     - \ugen{RHPF} :: Highpass filter /with/ resonance
     - \ugen{BPF} :: Bandpass filter.
**** Filter quality (Q) and \ci{rq} parameter.
     - Q is a standard measure. SC uses $rq = \frac{1}{Q}$ to save CPU.
     - \ugen{RLPF}, \ugen{RHPF}, and \ugen{BPF} all have a \ci{rq} input.
** Note control
*** Playing separate notes
**** What defines a "note"?
     Mainly, it has a beginning and end!
**** How do we give a note a beginning and end?
     Standard way: \eGlspl{envelope}.
     - This is a standard feature of all synthesizers, including VST/AUs.
*** Breakpoint envelopes
**** Usually, envelopes are defined in terms of \eglspl{breakpoint}.
     This funny-shaped envelope has four segments, defined by five breakpoints.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
#+Name: env1
#+Caption: Plotting a breakpoint envelope.
#+Begin_src {} -i
Env(
   levels: [0, 1, 0.2, 0.6, 0],
   times: [0.1, 0.3, 0.8, 0.25],
   curve: [\lin, -4, 5, -2]
).plot;
#+end_src
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
# #+name: env1png
# #+caption: 
#+attr_latex: :width 0.4\paperwidth
[[./img/breakpoint-env.png]]
**** Graphic comes from						   :noexport:
w = Window("env", Rect(800, 200, 400, 300)).front;
x = EnvelopeView(w, w.view.bounds.insetBy(2, 2)).setEnv(e);

*** Envelope definition
**** An envelope is made of:
     - A starting value
     - A number of \eglspl{segment} (no practical limit):
       - A target level
       - A time duration
       - A segment shape (curve)
     - A \egls{releaseNode} and \egls{loopNode} (optional)
**** Note the difference between the /starting value/ and the segments' /target values/.
     This will become important later.

*** Writing an envelope definition
**** It's written like this:
#+begin_latex
\cd{Env(\\<all>
\hspace{0.5cm}levels: [start, level$_0$, level$_1$, level$_2$...],\\<all>
\hspace{0.5cm}times: [time$_0$, time$_1$, time$_2$...],\\<all>
\hspace{0.5cm}curve: [curve$_0$, curve$_1$, curve$_2$...],\\<all>
\hspace{0.5cm}releaseNode: nil, loopNode: nil\\<all>
)}
#+end_latex
**** Notes
     - Segment 0 is defined by @@latex:\cd{levels[\textbf{1}]}@@,
       \cd{times[0]} and \cd{curve[0]}.
     - \cd{levels[0]} is the starting value---not part of any segment!
     - \ci{curve} may be an array or a single value (which applies to
       every segment).

*** Add an envelope to the synth
**** Audio synths should have an amplitude envelope.
     - Start from silence, end with silence.
#+latex: \glsadd{EnvGen}\glsadd{Impulse}
#+Name: ampenv1
#+Caption: Apply an evenly-triggered amplitude envelope.
#+Begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq) };
~filter.addSpec(\ffreq, \freq);
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };

~out = { (~filter.ar * ~eg).dup }; ~out.play;

~out.stop;  // We'll use these proxies some more
#+End_src

*** Envelope generator UGen
# deliberately no caption: Don't want this numbered or collated
#+Begin_src {} -i
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };
#+End_src
**** \clss{Env} defines the envelope. \ugen{EnvGen} plays it.
     - Inputs used here:
       - envelope :: The \clss{Env} definition.
       - gate :: The trigger or gate input. (More about gates later.)
     - Its output is a signal which:
       - Starts at 0;
       - Rises quickly to 1 over 0.01 seconds every time a trigger comes into \ci{gate};
       - Falls back to 0 over 0.6 seconds.

*** Envelope generator as amplifier
**** Amplifier is multiplication (\ci{*}).
#+Begin_src {} -i
~out = { (~filter.ar * ~eg).dup }; ~out.play;
#+End_src
     Amplitude envelope is usually last in the chain.
     - Here, it's in an \cd{\textasciitilde out} proxy.
     - \cd{\textasciitilde out} is the one that gets played.
#+begin_center
#+attr_latex: :height 1.5in
[[./img/visualize-proxy-network.pdf]]
#+end_center

*** Explore envelope behavior
**** Add two parameters: trigger frequency and decay time.
     Try these settings. Why do they sound like that?
     - Normal decay, high trigger rate > 30.
     - Short decay, high trigger rate.
     - Long decay > 1, medium trigger rate $\approx$ 3.5.
#+Name: ampenv2
#+Caption: Add parameters to the envelope generator.
#+Begin_src {} -i
~eg = { |tfreq = 1, decay = 0.6|
   EnvGen.kr(
      Env([0, 1, 0], [0.01, decay], -4),
      Impulse.kr(tfreq)
   )
};
~eg.addSpec(\tfreq, [0.5, 50, \exp]);
~eg.addSpec(\decay, [0.05, 1.5, 2]);
p.gui;
#+End_src

*** Envelope graphs
**** Plot functions						   :noexport:
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300) }.plot;
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** Initial settings
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope has plenty of time to fall to 0 (silence) between
       notes.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-normal-d0.6-f1.png]]
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** Same decay, much faster triggers
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope doesn't have enough time to decay, so the sound is
       almost continuous.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.6-f30.png]]
***** O3 							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
****** Fast triggers, very short decay.
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope decays quickly, so the sound gets much quieter
       between triggers. But the triggers come very quickly---30 Hz is
       within audio range---so we hear a strong amplitude modulation
       effect, adding another pitch.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.05-f30.png]]
***** O4							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
****** Medium triggers, long decay
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       You can hear the envelope decay, but it doesn't go all the way
       to silence. So the effect is more like /legato/ playing.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d1.12-f3.png]]

# #+Name: ampenv2
# #+Caption: Add parameters to the envelope generator.
# #+Begin_src {} -i
# {
#    [
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300)
#    ]
# }.plot;
# #+End_src

*** Standard envelope shapes: Helper methods
**** Timed envelopes (OK with \glspl{trigger})
     - \mth{linen} :: Linear attack and decay, flat sustain.
     - \mth{perc} :: Curved attack and decay, no sustain.
     - \mth{sine} :: Sine-shaped attack and decay, no sustain.
**** Sustaining envelopes (OK with \glspl{gate})
     *Note:* For these two, \ci{sustain} is a level, not a time.
     - \mth{adsr} :: Attack-Decay-Sustain-Release.\\
       This is one of the most standard envelope types, found in
                     almost any synthesizer.
     - \mth{asr} :: Same as \ci{adsr}, but without the decay
                    portion.
#+name: tryEnv
#+caption: Try plotting these different envelope shapes. Modify the example to try the other methods. Use auto-completion to see the parameter names and defaults.
#+begin_src {} -i
Env.linen(0.1, 1, 0.1).plot;
#+end_src



*** Refinements 						   :noexport:
**** Making it sound richer
     - Detuned oscillators
     - ??
**** Controlling the sound musically
     - Envelopes: Playing notes
     - Parameter control
       - Internal: Low Frequency Oscillators (LFOs)
       - External: GUI and device input


* Effects common in subtractive synthesis			   :noexport:
** Chorus
** Distortion
* Glossary							   :noexport:
# #+LaTeX: \glsaddall
# http://www.latex-community.org/forum/viewtopic.php?f=5&t=16833
#+LaTeX: \renewcommand{\glossarysection}[2][]{}
** Concepts
#+LaTeX: \printglossary[type=main]
** UGens
#+LaTeX: \printglossary[type=ugen]
** Other classes
#+LaTeX: \printglossary[type=class]
** Methods
#+LaTeX: \printglossary[type=mth]
