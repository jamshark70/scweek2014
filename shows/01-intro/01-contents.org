#+startup: beamer

#+TITLE: SuperCollider Week, Day 1 \\ Introductory SC and Synthesis
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL: 

#+INCLUDE: "../slidehead.org"
# #+INCLUDE: "../printhead.org"

* Workshop introduction						   :noexport:
** Who am I?
*** Composer, programmer, nerd
    - Ph.D., music composition, Duke University (2001)
    - Now: Associate Professor, Xinghai Conservatory, Guangzhou
    - Subjects: Electronic music production, Film music
*** Special interests:
    - Danceclub music
    - Real-time performance with computers

** What is SuperCollider?
*** /Programming language/ for audio and composition
    - Created by James McCartney
    - Conceptual basis: SmallTalk
      - /Object-oriented/ like Java, but still fun (not like Java)
    - Syntax: More like C
*** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
*** Right 							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

** Workshop goals
*** Teach synthesis techniques by experimentation
    - SC lets us take apart synthesizer components, and put them back together
    - SC's /Just-In-Time library/ makes it easy to re-patch components interactively
*** Teach techniques for live control and performance
    - Control by graphic interfaces and external devices
    - End goal: A group composition, to perform together
*** *Have fun programming!*
    - Emphasis on /play/ over /correctness/

** Audio programming before SuperCollider, 1
   Not a complete survey!
*** *Music \emph{n}* languages
    - Orchestra file to define synthesis
    - Score file (what to play, when)
    - Modern incarnation: /csound/
*** Lisp: *Common Lisp Music*, *Nyquist*
    - Music: Hierarchies of structure
    - Lisp: Data structures are hierarchical! Good for composition

** Audio programming before SuperCollider, 2
*** Dataflow: *Max/MSP*, *Pure Data*
    Represent everything as signal flow
    - Good: Intuitive to wire up interfaces quickly
    - Bad:
      - Relatively weak data structures (hard to represent musical information in an articulate way)
      - Monophonic processes, easy; polyphonic, hard
      - Complexity barrier

** Version history
*** McCartney's work before SuperCollider
    - /Synth-O-Matic/ (1990)
    - /Pyrite/ (scripting language for Max)
*** SuperCollider
    - SC1: Synth-O-Matic + Pyrite
    - SC2: Influence from SmallTalk
      - SC language is nearly complete
      - Notable audio processing inefficiencies
    - SC3 ("SC Server")
      - Audio processing is more efficient, by handling audio in a /server/ process

* SC architecture, usage					   :noexport:
** SC is three applications
*** Really? /Three/ applications?
    Yes. They work together:
    - =scide=: SC Integrated Development Environment
      - Code editor, display, documentation
    - =sclang=: SC language
      - IDE sends code to sclang
      - sclang runs the code, sends printed output back to IDE
    - =scsynth=: SC synthesis server
      - sclang sends Open Sound Control messages to scsynth
      - scsynth sends audio to the hardware
      - May also reply to sclang

** SC appearance
   Linux, here.
   #+begin_center
   #+attr_latex: :width 1.0\textwidth
   [[./img/sc-with-guis.pdf]]
   #+end_center

** Why separate the functions?
*** If one component crashes, the others keep working.
    Especially important: The code window stays intact!
*** They work together like one unit.

** Server/client design
*** *Server/client* design
    - Server does heavier work (e.g., databases)
    - Client makes requests of the server
*** How does this work for audio?
    - *Brain:* The client (SC language) sends messages to the server \\
      /Open Sound Control/ (OSC) protocol
      - "Here's a /synthesis definition/."
      - "Use that definition to make noise."
    - *Brawn:* The server calculates the audio and sends to the hardware.

** Why server/client?
*** Efficiency
    - Synthesis definitions are /reusable/.
*** Networked applications
    - Many clients can use the same server
*** Not limited to SC language
    - Any language that supports OSC can use SC audio!
    - Python, Clojure, Scala, Haskell, Scheme...
    - In free software, /user choice/ is important. Prefer /open/
      designs, rather than closed.

** Usage: IDE
*** The IDE is your main interface.
    IDE elements:
    - *Code panel:* Tabbed view of code documents.
    - *Docklets*
      - /Post window/: Printed results from SC language.
      - /Documents/ panel: List of all open tabs.
      - /Help browser/: Look up just about anything.
    - *Tool panel*: Find/replace, command line, etc.
    - *Status bar*
      - Language and server status
      - Server control (click on the server status)

** Code panel
*** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end \\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
*** Auto-indentation
    The editor will automatically indent the code according to the grouping levels.
    Consistent indentation makes the code easier to read.

** Code panel: Auto-completion
*** Auto-completion
    The editor can help you type certain names and remember parameter lists.
    1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
    2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
    3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
*** Keystrokes for auto completion:
    - Ctrl-space :: Complete a name.
    - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps
** Let's make some noise!
   1. Boot the audio server: \ks{Ctrl-B} \\
      See also /Language/ menu and server status. \\
      *Linux:* Start JACK before doing this.
   2. Type and run some code. \\
      Just run the first line at first.
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

** Tweak it
*** Try changing the numbers.
    On your own---a minute or so to experiment.
    - Run \cd{a.release} before re-running the synth.
    - What happens if you forget?
      - If you forget: press \ks{Ctrl-.} to stop everything.
      - \ks{Ctrl-.} is SC's panic button.
*** Be careful with the third number!			       :B_alertblock:
    :PROPERTIES:
    :BEAMER_env: alertblock
    :END:
    If it's too high, you could hurt your ears.
*** What do you think the numbers mean?

** Easier tweaking: ProxySpace
*** \ci{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \ci{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

** Important idea: /Modular/ design
*** A \te{modular} approach breaks a problem into smaller pieces.
    - For synthesis, it means you can play with the different pieces independently.
#+name: ps2
#+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

** Taking it apart
*** Now we know enough to step back and see what this is made of.
    - This part is a little dry and technical.
    - But, to talk about SC, you need to know some important terms.

** Taking it apart: Functions
*** {1\textwidth}{3in}					      :B_overlayarea:
    :PROPERTIES:
    :BEAMER_env: overlayarea
    :END:
    #+begin_center
    [[./img/take-apart-02-function.pdf]]
    #+end_center
**** A \te{function} is a block of code in curly braces.
     - Functions can take information in through \te{arguments}.
     - They always return one result.
     - \te{Call} a function using \ci{value}.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg x, y; sqrt(x.squared + y.squared) };

f.value(3, 4);  // prints "5"
#+end_src
# **** More about functions later.

** Taking it apart: Variables
*** {1\textwidth}{3in}					      :B_overlayarea:
    :PROPERTIES:
    :BEAMER_env: overlayarea
    :END:
    #+begin_center
    [[./img/take-apart-01-variable.pdf]]
    #+end_center
**** O1								  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 1
     :END:
***** A \te{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \ci{release} the synth. So, save the \ci{Synth} object in a variable.
**** O2								  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 2
     :END:
***** \te{Declared} variables
      - Any function can \te{declare} variable names.
      - Declared variables exist only inside that function! \\
	This is called \te{local} scope.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
**** O3 							  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 3
     :END:
***** \te{Interpreter} variables
      - Single letters \cd{a}--\cd{z}. 
      - \te{Global} scope. Interpreter variables may be used anywhere
        (unless a function declares a single-letter variable).
**** O4								  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 4
     :END:
***** \te{Environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** We will use environment variables for a special purpose.

** Taking it apart: Classes
*** {1\textwidth}{3in}					      :B_overlayarea:
    :PROPERTIES:
    :BEAMER_env: overlayarea
    :END:
    #+begin_center
    [[./img/take-apart-03-class.pdf]]
    #+end_center
**** O1								  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 1
     :END:
***** A \te{class} is an \te{object type}.
      Classes define two things:
      - Data :: Objects remember specific information. \\
       	E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
      - Actions :: Objects know how to do specific things. \\
       	E.g., You can add two \ci{Point}s together: \cd{point1 + point2}. \\
       	The \cd{Point} \te{class} declares how a Point should do \cd{+}.
**** O2								  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: 2
     :END:
***** \ci{SinOsc} is a \te{Unit Generator} class.
      - Unit generators ("UGens") are audio-processing operations in the server.
      - UGen classes in SC language:
	- /Name/ the audio processors.
	- /Connect/ UGens together.

** Taking it apart: Methods
*** {1\textwidth}{3in}					      :B_overlayarea:
    :PROPERTIES:
    :BEAMER_env: overlayarea
    :END:
    #+begin_center
    [[./img/take-apart-04-methods.pdf]]
    #+end_center
**** A \te{method} defines an action that an object can perform.
     It's like a function, but it has a name and belongs to a class.
     - \ci{ar} :: Makes an \te{audio rate} instance of \ci{SinOsc}.
     - \ci{dup} :: Copies the mono signal from \ci{SinOsc} into both left and right channels.
     - \ci{play} :: Makes a \te{synth node} from the function. \\
       \ci{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

** Taking it apart: Arguments
*** {1\textwidth}{3in}					      :B_overlayarea:
    :PROPERTIES:
    :BEAMER_env: overlayarea
    :END:
    #+begin_center
    [[./img/take-apart-05-args.pdf]]
    #+end_center
**** \te{Arguments} pass information into a method or function.
     - In general, UGens take numbers or signals as inputs.
     - They generate signals as output.
     - \ci{SinOsc}'s arguments are:
       - freq :: In Hz.
       - phase :: In radians (0--$2\pi$).
       - mul :: Amplitude.
       - add :: An offset (generally not used for audio).

