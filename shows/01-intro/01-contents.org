#+startup: beamer

# #+TITLE: SuperCollider Week, Day 1 \\ Introductory SC, Synthesis and Sequencing
# #+DATE: \today
# #+AUTHOR: H. James Harkins
# #+EMAIL:

# #+INCLUDE: "../slidehead.org"
# #+INCLUDE: "../printhead.org"

# #+include: "../glossary.org"

# * Temp, just to put it in a frame
# *** Temp, just to put it in a frame
* Workshop introduction
** Workshop introduction
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001).
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou.
     - Subjects: Electronic music production, Film music.
**** Special interests:
     - Danceclub music.
     - Real-time performance with computers.

#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

*** What is SuperCollider?
**** /Programming language/ for audio and composition
     - Created by James McCartney.
     - Conceptual basis: SmallTalk.
       - /Object-oriented/ like Java, but still fun (not like Java).
     - Syntax: More like C.
**** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk.
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
**** Right							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider.
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

*** Workshop goals
**** Teach synthesis techniques by experimentation
     - SC lets us take apart synthesizer components, and put them back together.
     - SC's /Just-In-Time library/ makes it easy to re-patch components interactively.
**** Teach techniques for live control and performance
     - Control by graphic interfaces and external devices.
     - End goal: A group composition, to perform together.
**** *Have fun programming!*
     - Emphasis on /play/ over /correctness/.

*** Start with a modular approach
**** At first: \eGls{modular} synthesis using \egls{JITLib}.
     Advantages:
     - Tiny, easy-to-understand code blocks.
     - Easy ways to connect and reconnect signals.
**** Not the standard approach in SC.
     - The standard approach is more /efficient/ but less /playful/.
     - Later in the workshop, we will learn the standard way.

** Brief, incomplete history of audio programming
*** Music "n" languages
    The *Music \emph{n}* languages (Music I, II etc.), by Max Mathews,
    were the first successful audio programming languages.
**** Structure
     - An \te{orchestra file} defines synthesis "instruments."
     - A \te{score file} lists musical events:\\
       Onset time, instrument, parameters.
     - \te{Compile} the two into an audio file.
     - *Not interactive.*
**** Modern incarnation: /csound/.
     Current versions have some interactive features.

*** Article: prehistory					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** We have it so much easier than they did.
We can run some code on a laptop and to hear the result right now. This is because:
- Your laptop can calculate audio faster than it will play. By
  contrast, Music II took an hour to calculate one minute of
  music.[fn:2]
- You don't have to share computer time with other users. In the
  1960s, there were only mainframes, no PCs. You had to prepare a job,
  submit it for processing when there was enough computer time
  available and wait for the result. If the result was wrong... wait
  until the next day.
- Your laptop has a built-in sound card. Max Mathews developed the
  Music \emph{n} languages at Bell Labs in New Jersey. They had the
  computer, but no DAC ("Digital-to-Analog Converter") to hear the
  results. They had to wait to get the digital audio tapes from the
  mainframe, and then physically drive them up to Columbia University
  in New York City to listen---and all that, just to find out what
  mistakes they made in the program!

*** Dataflow environments
    Dataflow languages include *Max/MSP* and *Pure Data*. They
    represent everything as a flow of signals between graphical
    objects.
    - Good: Intuitive to wire up interfaces quickly.
    - Bad:
      - Relatively weak data structures (hard to represent musical information in an articulate way).
      - Monophonic processes, easy; polyphonic, hard.
      - Complexity barrier.

*** ChucK
    *ChucK* is a programming language for \egls{live coding},
    developed by Ge Wang at Princeton University (2003-2008).
    - Integrated timing: Audio and program control run under the same timing mechanism.
    - The "ChucK operator" \ci{=>} for connecting synthesis units.\\<all>
      E.g., \ci{source => filter} rather than (in SC) \ci{Filter.ar(source)}.
    - Graphical environments for live coding in groups.

*** SuperCollider version history
**** McCartney's work before SuperCollider
     - /Synth-O-Matic/ (1990).
     - /Pyrite/ (scripting language for Max).
**** SuperCollider
     - SC1: Synth-O-Matic + Pyrite.
     - SC2: Influence from SmallTalk.
       - SC language is nearly complete in SC2.
       - One significant audio processing inefficiency.
     - SC3 ("SC Server").
       - Audio processing is more efficient, by handling audio in a /server/ process.

* SC architecture, usage
** SC architecture
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - \egls{scide}: SC Integrated Development Environment.
       - Code editor, display, documentation.
     - \egls{sclang}: SC language.
       - IDE sends code to sclang.
       - sclang runs the code, sends printed output back to IDE.
     - \egls{scsynth}: SC synthesis server.
       - sclang sends \gls{OSC} (Open Sound Control) messages to scsynth.
       - scsynth sends audio to the hardware.
       - May also reply to sclang.

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[./img/sc-with-guis.pdf]]
    #+end_center

*** Server/client design
**** *Server/client* design
     :PROPERTIES:
     :BEAMER_act: presentation
     :END:
     - Server does heavier work (e.g., databases).
     - Client makes requests of the server.
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server.\\
       /Open Sound Control/ (\gls{OSC}) protocol.
       - "Here's a /synthesis definition/ (\clss{SynthDef})."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

*** Why server/client?
**** Efficiency
     - Synthesis definitions are /reusable/.\\
       Optimizing a \clss{SynthDef} is relatively slow. Doing this
       once for thousands of notes is more efficient than once for
       every note.
**** Networked applications
     - Many clients can use the same server.
**** Not limited to SC language
     - Any language that supports OSC can use SC audio!
     - Python, Clojure, Scala, Haskell, Scheme...
     - In free software, /user choice/ is important. Prefer /open/
       designs, rather than closed.

** Using the Integrated Development Environment
*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status.
       - Server control (click on the server status).

*** Asking for help
**** Help system keyboard shortcuts
     - Ctrl-D :: Look up help for the keyword under the cursor.
     - Ctrl-Shift-D :: Pop up a box where you can type the search term.
**** Try it
     - Type \cd{SinOsc} into the code window.
     - Hit \ks{Ctrl-D}.
       - SC reads the help index the first time in the session.
       - It's faster after that.
**** Important help browser features
     - "Search" and "Browse" pages.
     - Table of contents in each help page.

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line.
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end.\\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps
** Making noise
*** Before making noise: Set up audio
**** OSX
     - Can choose the device within SC. See below.
     - Or, choose the device in OSX's audio control panel.
**** Windows
     - You /must/ choose the device within SC.
     - Boot the server, then quit, to get the list of devices.
**** Linux
     - \egls{scsynth} goes through the JACK audio server.
     - All audio configuration, including device, is done in JACK. /qjackctl/ can help.
     - *Start JACK before booting the server!*

*** Setting devices within SC
**** First, get a list of devices.
     - *OSX:* \cd{ServerOptions.devices}
     - *Windows:* Boot the server. Then look for the device list.
**** Set the device in \clss{ServerOptions}.
     - You must quote the device name exactly.
#+begin_src {} -i
s.options.device = "Device Name";
#+end_src
**** Reboot the server.
     - Quit first, if needed.
     - It should use the chosen device now.

*** Windows: ASIO
**** Strongly recommended to use an ASIO sound driver.
     - The default Microsoft MME driver will work, but its \egls{latency} is very high.
       - Latency: the delay between calculating the audio and hearing it.
       - For live use, 30 ms is too much.
       - MME can go as high as 230 ms!
     - If your soundcard installed an ASIO driver, use it.
     - For the built-in soundcard, use ASIO4ALL.

*** Boot the server
**** Boot the audio server.
     - Code: \cd{s.boot}.
     - IDE keyboard shortcut: \ks{Ctrl-B}.
     - See also /Language/ menu and server status.
      
*** "Canonical" SC synthesis
#+name: canonical
#+caption: SuperCollider's "native" style of synthesis.
#+begin_src {} -i
// A synthesis definition
(
SynthDef(\varsaw, { |out = 0, freq = 440, width = 0.5,
   amp = 0.1, gate = 1, pan = 0|
   var sig = VarSaw.ar(freq, 0, width),
   env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
   Out.ar(out, Pan2.ar(sig * env, pan));
}).add;
)

// Playing it: Object style
a = Synth(\varsaw, [freq: exprand(200, 500),
   width: rrand(0.2, 0.5)]);

a.release;  // to stop it

// Playing it: Event style
(instrument: \varsaw, freq: exprand(200, 500),
width: rrand(0.2, 0.5), sustain: 2).play;
#+end_src

*** "Canonical" objects and messages
**** All these commands send \egls{OSC} messages.
#+begin_center
[[./img/server-msg-diagram.pdf]]
#+end_center

*** When to use "canonical" style
**** "Canonical" style is good for finished works.
     - Maximum efficiency with structures that you've worked out in advance.
     - Not good for experimenting with signal flow.
     - Not ideal for learning: Too many details to learn before you
       can use \clsspl{SynthDef} comfortably.
**** My typical composition workflow
     - Begin with loosely-structured code. Play freely with it.
     - When I find sounds and sequences I like, I "freeze" them into more stable structures.

*** \{\}.play shortcut
**** This shortcut makes it faster to experiment.
     It handles both parts for you:
     - Makes the \clss{SynthDef} automatically.
     - Makes the \clss{Synth}.
#+latex: \glsadd{play}\glsadd{release}\glsadd{dup}\glsadd{SinOsc}
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

*** Tweak it
**** Try changing the numbers.
     On your own---a minute or so to experiment.
     @@latex:\glsadd{release}@@
     - Run \cd{a.release} before re-running the synth.
     - What happens if you forget?
       - If you forget: press \ks{Ctrl-.} to stop everything.
       - \ks{Ctrl-.} is SC's panic button.
**** Be careful with the third number!			       :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     If it's too high, you could hurt your ears.
**** What do you think the numbers mean?

*** Easier tweaking: ProxySpace
**** \clss{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \clss{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
      @@latex:\glsadd{ProxySpace}\glsadd{VarSaw}\glsadd{dup}\glsadd{SinOsc}\glsadd{play}\glsadd{stop}@@
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

** SC language syntax
*** Taking it apart
**** Now we know enough to step back and see what this is made of.
     - This part is a little dry and technical.
     - But, to talk about SC, you need to know some important terms.

*** Taking it apart: Functions
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-02-function.pdf]]
     #+end_center
***** A \clss{Function} is a block of code in curly braces.
     - Functions can take information in through \egls{arguments}.
     - \te{Call} a function using \mth{value}.
     - When you call it, SC:
       - Runs all the code inside;
       - Returns the value of the last expression.
     - SC uses Functions for:
       - Synthesis
       - Abstraction (packaging behavior to reuse later)

*** Function example: Hypotenuse
**** Remember right triangles from math class?
     - $a^2 + b^2 = c^2$, so $c = \sqrt{a^2 + b^2}$.
     - In SC: \cd{sqrt(a.squared + b.squared)}.
**** How do we get \ci{a} and \ci{b} in there?
     - That's what the \egls{arguments} are for.
     - \cd{arg a, b;}: \ci{a} and \ci{b} will get their values from the \mth{value} call.
     - \cd{f.value(3, 4)}: \ci{a} is 3, \ci{b} is 4.\\
       So the whole expression is @@latex: \cd{sqrt(3.squared + 4.squared)} $\to$
       \cd{sqrt(9 + 16)} $\to$ \cd{sqrt(25)} $\to$ 5@@.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg a, b; sqrt(a.squared + b.squared) };

f.value(3, 4);   // prints "5"
f.value(5, 12);  // prints "13"
#+end_src

*** Argument defaults
**** What if you leave out an argument value?
     You can specify a \egls{default} value, to use if you don't give another value.
**** Initialize an argument to:
     - Constant :: \cd{name = value}. Must be a \egls{literal} value: \cd{5}, \cd{'abc'}.
     - Expression :: \cd{name(value)}.
#+name: func2
#+caption: Default values for a and b in the hypotenuse function.
#+begin_src {} -i
f = { arg a = 3, b = 4; sqrt(a.squared + b.squared) };

f.value         // prints "5"
f.value(5);     // prints "6.403..."; b is still 4
f.value(b: 5);  // prints "5.830..."; a is still 3
#+end_src

*** Alternate argument syntax
    These are equivalent:
    - \cd{arg a = 3, b = 4;}
    - \cd{|a = 3, b = 4|}
**** Why two ways?
     - \cd{arg...} is traditional from SC2.
     - \cd{|...|} came later, to make looping structures prettier.
#+begin_src {} -i
10.do { arg i; i.postln };

// or

10.do { |i| i.postln };
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** A \egls{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \mth{release} the synth. So, save the \clss{Synth} object in a variable.
***** Access a variable's value by referring to its name.
      After \te{assigning} the Synth to \ci{a}, a reference to \ci{a} gets the Synth.
#+latex: \glsadd{assignment}
      - So \cd{a.release} acts on precisely that Synth.

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Declared} variables
     - Any function can \egls{declare} variable names.
     - Declared variables exist only inside that function!\\
       This is called \egls{local} scope.
     - \eGls{arguments} are variables, but get values from outside.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{interpreter} variables
      - Single letters \cd{a}--\cd{z}.
      - \eGls{global} scope. Interpreter variables may be used anywhere
       	(unless a function declares a single-letter variable).
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** ProxySpace uses environment variables for synth nodes.

*** Variable assignment
**** {1\textwidth}{3in}				     :B_overlayarea:noexport:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
**** The \egls{assignment} operator (\ci{=}) puts an object into a variable.
     Assignment is /not/ the same as $=$ in a math equation.
     - In algebra, $x=x+1$ is simply false: meaningless.
     - In most programming languages, \cd{x = x + 1} means to
       /replace/ the number currently in \ci{x} with that number + 1.
     - To test equality, use \ci{==}.
#+name: varassg1
#+caption: Variable assignment.
#+begin_src {} -i
x = 0;
y = x;
x == y;  // prints true

y = y + 1;  // prints 1
x == y;  // prints false
#+end_src

*** Taking it apart: Classes
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-03-class.pdf]]
     #+end_center
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** A \egls{class} is an \te{object type}.
       Classes define two things:
       - Data :: Objects remember specific information.\\
       	 E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
       - Actions :: Objects know how to do specific things.\\
       	 E.g., You can add two \ci{Point}s together: \cd{point1 + point2}.\\
       	 The \cd{Point} \te{class} declares how a Point should do \cd{+}.
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \ugen{SinOsc} is a \egls{UGen} (Unit Generator) class.
       - Unit generators process signals in the server.
       - UGens /name/ signal processors and /connect/ them.
****** \glspl{UGen} are created by \egls{rate} methods:
       - \mth{ar} :: \Gls{audio rate}; can play to the speakers.
       - \mth{kr} :: \Gls{control rate}; slower rate for control signals.
       - \ci{ir} :: \Gls{initial rate}; once at the synth's start.
*** Taking it apart: Methods
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-04-methods.pdf]]
     #+end_center
***** A \egls{method} defines an action that an object can perform.
      It's like a function, but it has a name and belongs to a class.
      - \mth{ar} :: Makes an \te{audio rate} instance of \ugen{SinOsc}.
      - \mth{dup} :: Copies the mono signal from \ugen{SinOsc} into both left and right channels.
      - \mth{play} :: Makes a \te{synth node} from the function.\\
       	\mth{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

*** Taking it apart: Arguments
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-05-args.pdf]]
     #+end_center
***** \eGls{arguments} pass information into a method or function.
      - In general, UGens take numbers or signals as inputs.
      - They generate signals as output.
      - \ugen{SinOsc}'s arguments are:
       	- freq :: In Hz.
       	- phase :: In radians (0--$2\pi$).
       	- mul :: Amplitude.
       	- add :: An offset (generally not used for audio).

*** Method calls: Most important thing
**** The SC language is all about /calling methods/.
     Everything happens in SC through method calls. *Everything.*\\
     (Except variable \egls{assignment}: \cd{x = 1}.)
     - Function calls? \mth{value} method.
     - Math? \cd{+}, \cd{-} are methods.
     - Flow-of-control mechanisms? \mth{do}, \mth{while}, \mth{if} etc. are methods.
**** If you understand how to use methods, you understand almost all of SC syntax.
     The hard part: Learning which methods do what!

*** Parts of a method call
**** A \gls{method call} consists of three parts:
    - \Gls{receiver} :: The object that will perform the method.
    - \Gls{selector} :: The method's name.
    - \Gls{arguments} :: Additional input (optional).
\\
In \cd{SinOsc.ar(440)}:
    - Receiver = the class \cd{SinOsc}
    - Selector = \cd{ar}
    - Argument = \cd{440}

*** Method call syntax
**** Three ways to call methods in SC.
    - "Dot" style :: \cd{receiver.selector(arguments...)}
    - Function style :: \cd{selector(receiver, arguments...)}
    - Infix style :: \cd{receiver selector: argument}\\
      Infix style allows only one argument.\\
      Binary operators (\cd{+}, \cd{-}, \cd{*}, \cd{/}, \cd{**}) are methods that use infix style.
      In \cd{1 + 2}: Receiver = 1, Selector = '+', Argument = 2
#+Name: callstyles
#+Caption: Three styles of method calls. They all answer with the same result, because the receiver, selector and argument are the same.
#+begin_src {} -i
[2.pow(3), pow(2, 3), 2 pow: 3]
// answers: [ 8, 8, 8 ]
#+end_src

*** Polymorphism
**** \eGls{polymorphism} is a fancy word for "one name, many meanings."
     A \gls{class} can respond to a request in a way that makes sense for it.
     - In Listing [[canonical]], we called \mth{play} on an \clss{Event}.
     - In Listing [[sound1]], we called \mth{play} on a \clss{Function}.
     - The specific actions are different.
     - The results are compatible: Something starts happening (in this case, sound).
**** In all cases, the \egls{receiver} chooses the method definition that's right for the object.
#+name: polymath
#+caption: Polymorphism with math operators. Try these one by one.
#+begin_src {} -i
1 + 2;
Point(3, 4) + 2;
[1, 2, 3, 4, 5] + 10;
[1, 2, 3, 4, 5] + [10, 20, 30];
SinOsc.ar + 1;
#+end_src

*** Audio summary
**** Making sound
     - Synthesis definition (\clss{SynthDef}).
     - A way to play the SynthDef (\clss{Synth}, \clss{Event}).
     - Shortcuts: @@latex:\cd{\{\}.play}@@, \clss{ProxySpace}.
**** SynthDefs connect \eglspl{UGen} (unit generators) together.
     - The language only keeps track of their connections.
     - The server processes them to make sound.

*** Language summary
**** Important SC language concepts
     - \gls{Function} :: A package of instructions, to be executed any time.
     - \gls{variable} :: A placeholder for an object (a reference to it).
     - \gls{arguments} :: Inputs to a function or method.
     - \gls{class} :: An object definition: /Data/ and /actions/.
     - \gls{method} :: An action that an object that knows how to perform.
     - \gls{receiver} :: The object that will answer the method call.
     - \gls{polymorphism} :: Allows objects to respond to requests in appropriate ways.

** Exercises: Math operations
*** Binary math operators
#     :PROPERTIES:
#     :BEAMER_act: presentation
#     :END:
#+name: binops
#+caption: Binary operators: a op: b.
#+attr_latex: :align |p{0.45\textwidth}|p{0.45\textwidth}| :float nil
| \ci{+} Addition                           | \ci{-} Subtraction               |
| \ci{*} Multiplication                     | \ci{/} Division                  |
| \ci{**} Power-of: \cd{a ** b} = $a^b$     | \ci{\%} Remainder                |
| \ci{min} Lower input                      | \ci{max} Higher input            |
| \ci{round} Round $a$ to $b$               | \ci{absdif} Like \ci{abs(a - b)} |
| \ci{trunc} Truncate $a$ to $b$ resolution | \ci{roundUp} Round $a$ up to $b$ |
| \ci{rrand} $a \le$ random $\le b$         |                                  |

*** Unary math operators
#     :PROPERTIES:
#     :BEAMER_act: presentation
#     :END:
# :placement [!h]
#+name: unops
#+caption: Unary operators: a.op or op(a).
#+attr_latex: :align |p{0.45\textwidth}|p{0.45\textwidth}| :float nil
| \ci{neg} Negative              | \ci{reciprocal} $1 \div a$        |
| \ci{midicps} Hz of MIDI note   | \ci{cpsmidi} MIDI note of Hz      |
| \ci{abs} Absolute value        | \ci{sign} -1 or 1 from $a$'s sign |
| \ci{squared} $a^2$             | \ci{sqrt} $\sqrt{a}$              |
| \ci{exp} $e^a$                 | \ci{log} $\ln a$                  |
| \ci{sin} Sine of $a$           | \ci{cos} Cosine of $a$            |
| \ci{rand} 0 $\le$ random < $a$ | \ci{rand2} $-a$ < random < $a$    |

*** Math operators and grouping
**** *IMPORTANT:* Binary math operators go left-to-right!
     - Most languages do them in this order:
       1. Any unary operators.
       2. \ci{**} (exponentiation)
       3. \ci{*} and \ci{/} (multiplication, division)
       4. \ci{+} and \ci{-} (addition, subtraction)
     - SC does them this way:
       1. Unary operators. \\ In \cd{1 + a.abs}, \ci{abs} comes first.
       2. Binary operators.
#+name: opPrecedence
#+caption: The difference between traditional operator grouping and SC's left-to-right precedence.
#+begin_src {} -i
a = 10;
5 + a * 2;  // 30; most languages, 25
(5 + a) * 2;  // 30
5 + (a * 2);  // 25
#+end_src

*** Exercises: Math expressions
**** Write functions (with arguments) for these:
     1. A random multiple of a time duration \ci{t}. \\ Hint: \mth{rand} and \mth{rrand} give you whole numbers if the inputs are whole numbers.
     2. Stop \ci{x} from going below zero. (Hint: \mth{max}.)
     3. Get a \egls{pitch class} (0--11) from a MIDI note number. \\ Hint: \ci{\%}.
     4. Bonus: Half the time, return \ci{x}; the other half, negative \ci{x}.\\
	You can actually (sort of) do this only with these math operators!
**** Answers							   :noexport:
     1. f = { |t = 0.25| rrand(1, 4) * t };
     2. f = { |x| max(x, 0) };
     3. f = { |midi| midi % 12 };
     4. f = { |x| x * sign(1.0.rand2) };

*** Exercises: Math on UGens
**** Using a \clss{ProxySpace}, write \cd{\textasciitilde out = ...} functions for these.
     1. A sinewave oscillator at 300 Hz, amplitude 0.1.
     2. In the same function, multiply this by a sinewave that takes 5 seconds.
	- What is the frequency for 5 seconds?
	- The sinewave is normally -1 to 1. How to make it 0 to 1?
     3. Add another pair doing the same, except:
	- Audio oscillator at 600 Hz;
	- Control oscillator goes 1 to 0.
**** Answers 							   :noexport:
     1. ~out = { SinOsc.ar(300, 0, 0.1) }; ~out.playN(outs: [0, 1]);
     2. ~out = { SinOsc.ar(300, 0, 0.1) * SinOsc.kr(0.2, 0, 0.5, 0.5) };
     3. ~out = {
  	     (SinOsc.ar(300, 0, 0.1) * SinOsc.kr(0.2, 0, 0.5, 0.5))
   	     (SinOsc.ar(600, 0, 0.1) * SinOsc.kr(0.2, 0, -0.5, 0.5))
	};
     4. ~out.stop;

*** Next: Synthesis techniques					   :noexport:
    Now we know enough to start exploring standard synthesis techniques.

* Modular synthesis with JITLib
** What is modular synthesis?
*** Simple components, complex behavior
**** \Gls{modular} synthesis builds complex sounds from simple units.
     - Early hardware synthesizers were modular.
     - Lots of boxes: \eGlspl{oscillator}, \eglspl{filter}, \eglspl{envelope generator} etc.
     - Patch them together using physical cables.
#+begin_center
#+name: catmod
#+caption: A small (!) modular synthesizer, with cat. Image credit: Stephen Drake, http://commons.wikimedia.org/wiki/File:Cat_modular_synthesizer.jpg.
#+attr_latex: :height 1.2in
[[./img/800px-Cat_modular_synthesizer.jpg]]
#+end_center

*** Modular synthesis for teaching
**** Code complexity is a teaching problem.
     - Too much code at once, too hard to understand.
**** In a \gls{modular} approach:
     - Code blocks will be very small: 5--6 lines at most (at first).
     - Make lots of small modules (\clsspl{NodeProxy}).
     - Connect them to get complex results.
**** Flexible patching
     Because they're separate modules, it's easy to reconnect them anytime.

*** Modular example
**** Build a synthesis structure up from modules		   :noexport:
     - We will use this structure for most of the examples today.
     - Tomorrow, we'll learn more about how the audio works.
**** Start with an \egls{oscillator}.
     - The first block just creates the oscillator as a \clss{NodeProxy}.
     - It's not connected to to the output---\mth{play} does that.
     - \ci{gui} makes a control panel, to adjust inputs.
     - \mth{stop} to disconnect (but the module is still there).
#+latex: \glsadd{ProxySpace}\glsadd{Saw}
#+name: mod1
#+caption: Within a ProxySpace, create an oscillator module.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 261.625, amp = 0.1|
   Saw.ar(freq, amp).dup
};

~oscil.play;
p.gui;

~oscil.stop;
#+end_src

*** Modular example: Add a filter
**** Add a filter, for a brightness control.
     - The filter needs an audio input.
     - Provide this by referring to the oscillator: \cd{\textasciitilde oscil.ar}.
     - Now the filter is the desired output, so \mth{play} and \mth{stop} that.
#+latex: \glsadd{LPF}\glsadd{addSpec}
#+name: mod2
#+caption: Within a ProxySpace, create a filter module.
#+begin_src {} -i
~filter = { |ffreq = 2000|
   LPF.ar(~oscil.ar, ffreq)
};
~filter.addSpec(\ffreq, \freq);

~filter.play;

~filter.stop;
#+end_src

*** Common "analog-style" structure
**** This design is a classic.
     - \Gls{oscillator} $\to$ \gls{filter}.
     - Tomorrow, more types of oscillators and filters.
#+begin_center
#+name: analog1
#+caption: Standard analog-style (subtractive) synthesis.
#+attr_latex: :height 1in
[[./img/visualize-proxy-network-no-eg.pdf]]
#+end_center
**** This is enough for today's topics.				   :noexport:
     - Controlling notes with envelopes.
     - Automatically triggering notes by sequences.

** JITLib patching
*** "Just-In-Time" Library (JITLib)
**** JITLib is a system of \eglspl{proxy}.
     - Proxy :: An object that represents another object. A
                \clss{NodeProxy} represents a signal in the server.
**** JITLib lets us play with signals.
     No need to worry about structure too soon, because you can change
     the structure and content independently.
     - Write the /connections/ between signals (and other data) based on the proxies.
     - You can change whatever is in the proxies at any time.
     - This does not change the connections!
     - Proxies can be very small and simple: easy to read and understand.

*** Repatching the oscillator
**** To change the oscillator, assign a new function.
     No change to the relationship between oscillator and filter.
#+latex: \glsadd{Saw}\glsadd{Mix}\glsadd{Pulse}\glsadd{fadeTime}
#+name: mod3
#+caption: Switch between different oscillators.
#+begin_src {} -i
~filter.play;

// Thicker sound
~oscil = { |freq = 220, detun = 1.003, amp = 0.1|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], amp)).dup
};

// Different wave shape
~oscil = { |freq = 220, detun = 1.003, amp = 0.1|
   Mix(Pulse.ar(freq * [1, detun, detun.reciprocal], 0.5, amp)).dup
};

// Back to the sawtooth, with a longer fade
~oscil.fadeTime = 2;
~oscil = { |freq = 220, detun = 1.003, amp = 0.1|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], amp)).dup
};
#+end_src

*** Connect proxies, not signals
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.65
     :END:
     - In Figure [[analog1]], the filter connects back to the \ci{\textasciitilde oscil} \egls{proxy}.
     - Put a new signal in the proxy, and the filter gets the new signal.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.3
     :END:
***** Image, suppress for article				  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: presentation
      :END:
      #+begin_center
      [[./img/visualize-proxy-network-no-eg.pdf]]
      #+end_center
**** Like a magic box with a cat inside.
     - The magic box changes the cat sometimes.
     - Reach into the box any time, and you know you'll pet a cat.
     - But it may be a /different cat/.

*** Exercises: Try other UGens
**** As in Listing [[mod3]], substitute the following oscillators.
     - Find their parameters in the help system.
     - Experiment with different parameter values.\\<all>
       *Be careful with \ci{mul}.* Keep it between 0 and 1.
**** Dummy, switch list style				    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     1. Done before: \ugen{SinOsc}, \ugen{Saw}, \ugen{Pulse}
     2. New: \ugen{VarSaw}, \ugen{Blip}, \ugen{Formant}\\<all>
	Keep \ci{mul} pretty low for \ugen{Blip}. Bad for your ears.

* Note control
** Playing notes by envelopes
*** Playing separate notes
**** What defines a "note"?
     Mainly, it has a beginning and end!
**** How do we give a note a beginning and end?
     Standard way: \eGlspl{envelope}.
     - This is a standard feature of all synthesizers, including VST/AUs.
*** Breakpoint envelopes
**** Usually, envelopes are defined in terms of \eglspl{breakpoint}.
     This funny-shaped envelope has four segments, defined by five breakpoints.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
#+Name: env1
#+Caption: Plotting a breakpoint envelope.
#+Begin_src {} -i
Env(
   levels: [0, 1, 0.2, 0.6, 0],
   times: [0.1, 0.3, 0.8, 0.25],
   curve: [\lin, -4, 5, -2]
).plot;
#+end_src
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
# #+name: env1png
# #+caption:
#+attr_latex: :width 0.4\paperwidth
[[./img/breakpoint-env.png]]
**** Graphic comes from						   :noexport:
w = Window("env", Rect(800, 200, 400, 300)).front;
x = EnvelopeView(w, w.view.bounds.insetBy(2, 2)).setEnv(e);

*** Envelope definition
**** An envelope is made of:
     - A starting value
     - A number of \eglspl{segment} (no practical limit):
       - A target level
       - A time duration
       - A segment shape (curve)
     - A \egls{releaseNode} and \egls{loopNode} (optional)
**** Note the difference between the /starting value/ and the segments' /target values/.
     This will become important later.

*** Writing an envelope definition
**** It's written like this:
#+begin_latex
\cd{Env(\\<all>
\hspace{0.5cm}levels: [start, level$_0$, level$_1$, level$_2$...],\\<all>
\hspace{0.5cm}times: [time$_0$, time$_1$, time$_2$...],\\<all>
\hspace{0.5cm}curve: [curve$_0$, curve$_1$, curve$_2$...],\\<all>
\hspace{0.5cm}releaseNode: nil, loopNode: nil\\<all>
)}
#+end_latex
**** Notes
     - Segment 0 is defined by @@latex:\cd{levels[\textbf{1}]}@@,
       \cd{times[0]} and \cd{curve[0]}.
     - \cd{levels[0]} is the starting value---not part of any segment!
     - \ci{curve} may be an array or a single value (which applies to
       every segment).

*** Add an envelope to the synth
**** Audio synths should have an amplitude envelope.
     - Start from silence, end with silence.
**** Assuming you still have the previous oscillator and filter.
#+latex: \glsadd{EnvGen}\glsadd{Impulse}
#+Name: ampenv1
#+Caption: Apply an evenly-triggered amplitude envelope.
#+Begin_src {} -i
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };

~out = { (~filter.ar * ~eg).dup }; ~out.play;

~out.stop;
#+End_src

*** Envelope generator UGen
# deliberately no caption: Don't want this numbered or collated
#+Begin_src {} -i
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };
#+End_src
**** \clss{Env} defines the envelope. \ugen{EnvGen} plays it.
     - Inputs used here:
       - envelope :: The \clss{Env} definition.
       - gate :: The trigger or gate input. (More about gates later.)
     - Its output is a signal which:
       - Starts at 0;
       - Rises quickly to 1 over 0.01 seconds every time a trigger comes into \ci{gate};
       - Falls back to 0 over 0.6 seconds.

*** Triggers
**** Plot code							   :noexport:
{ var trig = Impulse.ar(300);
   [trig, EnvGen.ar(Env.perc(0.01, 0.6), trig, timeScale: 1/300)]
}.plot;
**** A \egls{trigger} happens when a signal crosses from $\le$ 0 to > 0.
     - Many UGens respond to triggers.
     - Here, the trigger signal consists of \eglspl{impulse}.
     - Common trigger UGens:
       - \ugen{Impulse} :: Impulses at a constant frequency.
       - \ugen{Dust} :: Impulses at random durations, according to an average density.
     - Exercise for you: Try \clss{Dust}.
#+Begin_center
#+attr_latex: :height 1in
[[./img/trigger-and-envgen.png]]
#+End_center

*** Envelope generator as amplifier
**** Amplifier is multiplication (\ci{*}).
#+Begin_src {} -i
~out = { (~filter.ar * ~eg).dup }; ~out.play;
#+End_src
     The envelope's amplifier is usually last in the chain.
     - Here, it's in an \cd{\textasciitilde out} proxy.
     - \cd{\textasciitilde out} is the one that gets played.
#+begin_center
#+attr_latex: :height 1.5in
[[./img/visualize-proxy-network.pdf]]
#+end_center

*** Explore envelope behavior
**** Add two parameters: trigger frequency and decay time.
     Try these settings. Why do they sound like that?
     - Normal decay, high trigger rate > 30.
     - Short decay, high trigger rate.
     - Long decay > 1, medium trigger rate $\approx$ 3.5.
#+Name: ampenv2
#+Caption: Add parameters to the envelope generator.
#+Begin_src {} -i
~eg = { |tfreq = 1, decay = 0.6|
   EnvGen.kr(
      Env([0, 1, 0], [0.01, decay], -4),
      Impulse.kr(tfreq)
   )
};
~eg.addSpec(\tfreq, [0.5, 50, \exp]);
~eg.addSpec(\decay, [0.05, 1.5, 2]);
p.gui;
#+End_src

*** Envelope graphs
**** Plot functions						   :noexport:
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300) }.plot;
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** Initial settings
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope has plenty of time to fall to 0 (silence) between
       notes.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :height 1.5in
       [[./img/eg-normal-d0.6-f1.png]]
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** Same decay, much faster triggers
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope doesn't have enough time to decay, so the sound is
       almost continuous.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :height 1.5in
       [[./img/eg-d0.6-f30.png]]
***** O3 							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
****** Fast triggers, very short decay.
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope decays quickly, so the sound gets much quieter
       between triggers. But the triggers come very quickly---30 Hz is
       within audio range---so we hear a strong \egls{amplitude modulation}
       effect, adding another pitch.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :height 1.5in
       [[./img/eg-d0.05-f30.png]]
***** O4							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
****** Medium triggers, long decay
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       You can hear the envelope decay, but it doesn't go all the way
       to silence. So the effect is more like /legato/ playing.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :height 1.5in
       [[./img/eg-d1.12-f3.png]]

# #+Name: ampenv2
# #+Caption: Add parameters to the envelope generator.
# #+Begin_src {} -i
# {
#    [
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300)
#    ]
# }.plot;
# #+End_src

** Timed and sustaining envelopes
*** Standard envelope shapes: Timed
    - \mth{linen} :: Linear attack and decay, flat sustain.
    - \mth{perc} :: Curved attack and decay, no sustain.
    - \mth{sine} :: Sine-shaped attack and decay, no sustain.
#+name: tryEnv1
#+caption: Try plotting these timed envelope shapes. Modify the example to try the other methods. Use auto-completion to see the parameter names and defaults.
#+begin_src {} -i
Env.linen(0.1, 1, 0.1).plot;
#+end_src

*** Sustaining envelopes (OK with \glspl{gate})
    *Note:* For these two, \ci{sustain} is a level, not a time.
    - \mth{adsr} :: Attack-Decay-Sustain-Release.\\
      This is one of the most standard envelope types, found in
		    almost any synthesizer.
    - \mth{asr} :: Same as \ci{adsr}, but without the decay
		   portion.
#+name: tryEnv2
#+caption: Try plotting these sustaining envelope shapes.
#+begin_src {} -i
Env.adsr(0.1, 0.25, 0.5, 0.2).plot;
#+end_src

*** Sustaining envelopes
**** Why sustaining envelopes?
     - When playing on a MIDI keyboard, you don't know in advance how long to sustain.
     - So you need an envelope that will wait for a signal to release.
**** \egls{releaseNode} creates a sustaining envelope.
     - The release node is the release segment's index.
     - For example, ADSR has:
       - Attack: Segment 0
       - Decay: Segment 1
       - Release: Segment 2
     - So releaseNode is 2.

*** Sustaining envelopes and gates
**** Plot code							   :noexport:
{ var trig = Impulse.ar(30);
	trig = Trig1.ar(trig, TRand.ar(1/120, 1/40, trig));
	[trig, EnvGen.ar(Env.adsr(0.01, 0.1, 0.5, 0.01), trig, timeScale: 1/30)]
}.plot(0.1);

{ var trig = Impulse.kr(1);
    trig = Trig1.kr(trig, TRand.kr(3/12, 3/4, trig));
    [trig, EnvGen.kr(Env.adsr(0.01, 0.1, 0.5, 0.2), trig)]
}.plot(2);
**** The attack/release signal is a \egls{gate}.
     - A gate is > 0 when open, and $\le$ 0 when closed.
     - \ugen{EnvGen} triggers when a gate opens, and releases when it closes.
     Note the effect of the different open/close times.
#+Begin_center
#+attr_latex: :height 1.5in
[[./img/gates-and-env.png]]
#+End_center

*** Sustaining envelope in ProxySpace
**** Replace the timed envelope with a sustaining envelope.
     - Now we need a control input for the gate: \ci{gt}.
       - Normally a \clss{SynthDef} calls the gate input \ci{gate},
         but that's reserved for another use in \clss{ProxySpace}.
     - Use \mth{set} to open and close the gate.
#+name: susEnv
#+caption: Plug a sustaining envelope into the analog-style synth.
#+begin_src {} -i
~eg = { |gt = 0|
   EnvGen.kr(
      envelope: Env.adsr(0.01, 0.15, 0.4, 0.1),
      gate: gt
   )
};

~eg.set(\gt, 1);  // trigger
~eg.set(\gt, 0);  // release
#+end_src

** Events and envelope gates
*** More convenience for gates: Events
**** Sequencing: Inconvenient to close gates by hand.
     Introducing \clss{Event}.
     - We saw an \clss{Event} briefly, in the "canonical" example (Listing [[canonical]]).
     - It both played and released a Synth.
     - We will learn more about events as we go.
**** Events have lots of properties, including timing.
     - \ci{dur} :: Number of beats until the next event.
     - \ci{sustain} :: Number of beats to keep a gate open. (May
		       also be calculated from \cd{dur * legato}.)

*** Events with ProxySpace
    - In \clss{ProxySpace}, a special event type can set parameters globally in the entire space.
      - \mth{setEvent}
    - This event type handles \ci{gt} specially.
      - It automatically closes the gate if you provide a \ci{sustain} time.
      - So, for this usage pattern, get used to using \ci{gt} for gates.
#+name: gateEvent
#+caption: Hold a gate open for a given amount of time using an Event.
#+begin_src {} -i
p.setEvent((gt: 1, sustain: 0.5)).play;
p.setEvent((gt: 1, sustain: 3)).play;
#+end_src

*** Coordinated changes with Events
**** An \clss{Event} can set lots of controls at once.
     - Just list them in the same \cd{name: value} syntax.
     - If the name exists anywhere in the \clss{ProxySpace}, the event will find it and set it.
     - \mth{exprand}: random frequency according to an \egls{exponential} scale.
     - \mth{degree}: interprets \mth{rrand} number as a diatonic scale degree.
# nb: \mth{degree} is actually listed in the main glossary
#+name: multiSetEvent
#+caption: Set both frequency and gate.
#+begin_src {} -i
p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;

p.setEvent((degree: rrand(-14, 0), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
     We are now /centimeters/ away from sequencing!

* Sequencing
** Overview: Routines and Tasks
*** Sequencing: Basic requirements
**** For sequencing, we need:
     - /Musical/ information (pitch, timbre controls, etc.)
     - /Rhythm/ information:
       - How long to hold a note
       - How long to wait until the next note
     - Ways to do things /repeatedly/.
     - A way to /pause/ activity for some time, and resume exactly where it left off.

*** Pausing: Routine
**** In SC, a \clss{Routine} can pause and resume.
     - Routines \mth{yield} values.
     - Call \mth{next} to advance to the next \mth{yield}.
     - The routine will give back the value, and wait at exactly that point.
     - The next \mth{next} call will advance from there.
#+name: routine1
#+caption: A simple routine. Run r.next four times. How would you explain the results?
#+begin_src {} -i
(
r = Routine {
   1.yield;
   3.yield;
   5.yield;
};
)

r.next;
#+end_src

*** Repeated actions: Loops
**** Computer languages use \eglspl{loop} to do things again and again.
     - It's inconvenient to write \mth{yield} again and again.
     - We can use a \egls{loop} to write \mth{yield} once, but run it several times.
**** Loops make it easier to write bigger programs.
     - The last example yielded three values.
     - What if I want to yield 100 values?
     - Using a loop, I can write the values into a \egls{collection},
       and write the action only once.

*** Do loops
**** \mth{do} loops
     - \mth{do} runs a \clss{Function} several times.
     - We'll put the desired values into an \clss{Array}, then \mth{do} over it.
     - If \ci{func} is the function, this loop calls:
       - \cd{func.value(1, 0)}---1 is the item; 0 is its index
       - \cd{func.value(3, 1)}
       - \cd{func.value(5, 2)}
     - The array could be 100 items, but the \mth{do} function can stay the same.
#+name: do1
#+caption: A do loop.
#+begin_src {} -i
[1, 3, 5].do { |item|
   item.postln;
};
#+end_src

*** Do loop output
**** Let's look at the printed output from Listing [[do1]].
     - 1, 3 and 5 are easy enough to understand.
#+begin_src {} -i
1
3
5
[ 1, 3, 5 ]
#+end_src
**** Why is the \clss{Array} repeated at the end?
     - Every code block returns something as its result.
     - \mth{do} returns its \egls{receiver}, which is the array.
     - So: 1, 3 and 5 are printed inside the \mth{do} loop.
     - \cd{[ 1, 3, 5 ]} is returned by \mth{do} itself, and printed as
       the result of the whole code block.

*** Loops: When to stop
**** Without a \clss{Routine}, a \gls{loop} must stop somehow.
     - In Listing [[do1]], it stops at the end of the array.
     - \cd{5.do...} would run the function five times and stop.
     - \cd{inf.do...} will hang SC language. *Don't do that.*
       - \Gls{infinite loop} :: A loop with no end. Locks up the
            interpreter until you force-quit.
**** Use /Language/ menu $\to$ /Quit interpreter/ to regain control. :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     Once the interpreter is locked, you can't run any code. Killing
     it is the only option.

*** Routines and yielding within loops
**** You may \mth{yield} inside a \mth{do} loop.
     Or any other kind of loop.
#+name: routine2_do
#+caption: A simple routine with a do loop. Run r.next four times.
#+begin_src {} -i
r = Routine {
   [1, 3, 5].do { |item|
      item.yield;
   };
};

r.next;
#+end_src
     - Same behavior as the earlier routine, but now easier to expand
       (just write a longer array).

*** Infinite loops in Routines
**** You /can/ write an \gls{infinite loop}, if it \mth{yield}s from a \clss{Routine}.
     - \mth{yield} means that the routine temporarily gives up control: No lockup.
     - The routine can produce an infinite number of values.\\
       Of course, you can never /ask for/ an infinite number!
**** Shortcut for an infinite loop: \ci{loop}.
     - *Never* use this without \mth{yield}!
#+latex: \glsadd{rrand}
#+name: routine2_do
#+caption: A simple routine with a infinite loop. Run r.next as many times as you like.
#+begin_src {} -i
r = Routine {
   loop {
      rrand(1, 10).yield;
   }
};

r.next;
#+end_src

*** Routines: Sequences of values
**** Now we know how to make sequences of values.
     - \mth{yield} values from a \clss{Routine}.
     - Any length sequence---even infinite!
     - Get values one by one using \mth{next}.
**** \clss{Routine} is a type of \clss{Stream}.
     - A \clss{Stream} responds to \mth{next} with its sequence's next value.
     - For example, a \clss{File} is a kind of stream, returning the
       file's characters one by one for \mth{next}.

** Time control: Clocks and scheduling
*** Timing
**** To play musical sequences, we need rhythm.
     Two key concepts:
     - \eGlspl{scheduler} :: An object that handles timing. Schedule
          actions to take place at a given time. The scheduler will
          "awaken" the action at the right time.
     - \eGlspl{delta} :: The amount of time between successive
                         events. Formally called "inter-onset
                         interval" or \egls{IOI} for short.

*** Scheduling
**** \eGlspl{scheduler} make something happen at a specific time in the future.
     - A scheduler is a \clss{Clock}. Most commonly used:
       - \clss{TempoClock} :: Adjustable tempo, given in beats per second (bps). Time is measured in \eglspl{beat}. Normally used for musical sequencing.
**** Scheduling methods
     - \mth{sched} :: Time is given as a number of beats later than "now."
     - \mth{schedAbs} :: Time is given as an absolute time point.

*** Scheduler usage
     Note that the order of the statements doesn't matter to the
     scheduler. The functions run at the /scheduled/ time, no matter
     which one went into the scheduler first.
#+name: sched1
#+caption: Scheduling simple actions. Run the blocks and watch the post window.
#+begin_src {} -i
(
"Right now".postln;
TempoClock.sched(1, { "one".postln });
TempoClock.sched(2, { "two".postln });
)

(
TempoClock.sched(2, { "two".postln });
"Right now".postln;
TempoClock.sched(1, { "one".postln });
)
#+end_src

*** Automatic rescheduling
**** Returning a number will /reschedule/ the action.
     - The number is a \egls{delta} time into the future.
**** *IMPORTANT:* Do not return delta $\le$ 0 accidentally!    :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     - If the return value is always $\le$ 0, it will lock up the interpreter.
     - To be safe, when scheduling a function, write \cd{nil} as the
       last expression.
#+name: resched1
#+caption: Automatic rescheduling. You'll have to use ctrl-. to stop it.
#+begin_src {} -i
(
var x = 0;
TempoClock.sched(1, {
   x = x + 1;
   x.postln;
   0.5  // this is the delta time
});
)
#+end_src

*** Rescheduling routines
**** A \clss{Routine}'s return value is \mth{yield}ed.
     - So, \mth{yield} the \gls{delta} time.
     - You can also write \mth{wait}.
     - You can \mth{stop} a Routine without \ks{Ctrl-.}: \cd{r.stop}.
#+name: resched2
#+caption: Automatic rescheduling of a Routine with ``wait.''
#+begin_src {} -i
(
r = Routine {
   var x = 0;
   loop {
      x = x + 1;
      x.postln;
      0.5.wait;
   }
};
TempoClock.sched(1, r);
)

r.stop;
#+end_src

*** Routines: Any kind of rhythm
    The key point from the last example is:
**** You can do /anything/ before the \mth{wait}!
     - Calculation
     - Audio sequencing
     - Graphics updates
**** Structure for timed activities in Routines
     - \clss{Routine}
       - Initialization (optional)
       - \mth{loop} (or \mth{do} or \mth{while})
         - Action
         - \cd{time.wait}

** Sequencing of notes
*** Note sequencing
**** To play notes, do it before \mth{wait}.
     - \cd{\textasciitilde out.set}: Trigger the envelope and set a new pitch.
     - Note \mth{play} here: More convenient than \cd{TempoClock.sched}.
#+name: noteseq1
#+caption: Note sequencing in a Routine.
#+begin_src {} -i
p.clear;  // or p = ProxySpace.new; p.push;

~out = { |freq = 440, width = 0.5, t_trig = 1|
   var eg = EnvGen.kr(Env.perc(0.01, 0.5), t_trig);
   (VarSaw.ar(freq, 0, width) * eg * 0.1).dup
};
~out.play;

r = Routine {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
}.play;

r.stop;
#+end_src

*** Task and Tdef
**** \clss{Task} is like \clss{Routine}, with one advantage:
     - \mth{stop}ping a \clss{Routine} stops it permanently. You can
       only \mth{reset} back to the beginning.
     - After \mth{stop}ping a \clss{Task}, you can re-\mth{play} it
       and it will continue from the middle.
**** \clss{Tdef} is global storage for Tasks.
     - \mth{play} and \mth{stop} it just like a \clss{Task} or \clss{Routine}.
     - Get a play/stop control panel from \clss{TdefAllGui}.
     - You can switch the \clss{Tdef} function at any time.
       - This is like switching a synthesis function in a \clss{NodeProxy}.
**** Storage will become important later.

*** Graphical control of Tdef
#+name: tdef1
#+caption: Using Tdef for graphical control and replacing sequencing functions on-the-fly.
#+begin_src {} -i
Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
});

TdefAllGui.new;

// Replace the Task function.
// You should hear the effect immediately.
Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(440, 1760));
      0.125.wait;
   };
});
#+end_src

*** Using ProxySpace-set Events					   :noexport:
**** Remember the \clss{Event} type from "Events with ProxySpace"?
     - You can use \cd{p.setEvent((...))} in a \clss{Task} as well.
     - This is much easier than setting the controls individually on
       specific \clss{NodeProxy} objects.
# #+name: tdefEvent
# #+caption: Replace out.set with Events.
#+begin_src {} -i
Tdef(\player, {
   loop {
      p.setEvent((t_trig: 1, freq: exprand(110, 440))).play;
      0.5.wait;
   };
});
#+end_src
**** There is another really good reason to use Events: \eGlspl{pattern}.
     Details tomorrow.
*** Non-random sequences
**** Random sequences are easy.
     Just write the randomized math expression for each parameter.
**** Non-random melodies take a little more care.
     - Store the note data: \clss{Array}.
     - Retrieve them one by one: \mth{at} method.

*** Non-random example: One array
    In very simple cases, this is pretty easy.
    - Use the \ci{\textasciitilde out} synth in Listing [[noteseq1]].
    - Remember, \mth{do} over the \clss{Array} reads out the array's items one by one.
#+name: noteseq2
#+caption: Get a deterministic sequence of pitches from an array.
#+begin_src {} -i
(
var midi = [59, 61, 66, 68, 69, 61, 59, 68, 66, 61, 69, 68];

Tdef(\reich, {
   loop {
      midi.do { |note|
         ~out.set(\t_trig, 1, \freq, note.midicps);
         0.15.wait;
      }
   }
}).play;
)

Tdef(\reich).stop;  // if you want
#+end_src

*** More arrays?
    A bit inconvenient with more arrays.
    - We can't \mth{do} over both arrays at once.
    - Instead, like before, \cd{midi.do} passes the note numbers into the function.
    - It also passes the array index (second argument): \cd{|note, i|}.
    - We can use the index to get the corresponding item from the other array(s).

*** Non-random example: Two arrays
#+name: noteseq3
#+caption: Get deterministic sequences of note information from multiple arrays.
#+begin_src {} -i
(
var midi = [59, 61, 66, 68, 69, 61, 59, 68, 66, 61, 69, 68],
sawWidth = [0.1, 0.5, 0.2, 0.5, 0.5, 0.5,
   0.1, 0.5, 0.5, 0.1, 0.5, 0.5];

Tdef(\reich, {
   loop {
      midi.do { |note, i|
         ~out.set(
            \t_trig, 1,
            \freq, note.midicps,
            \width, sawWidth[i]
         );
         0.15.wait;
      }
   }
}).play;
)

Tdef(\reich).stop;  // if you want
#+end_src

*** That's... a bit painful
**** Not only painful, but also limiting.
     Here are some ideas that are hard to express in arrays.
     - Partially random sequences:
       - 10 sequenced notes
       - 5 or 6 random notes
     - Phrase structures: Choose one phrase, then another.
# *** Non-random sequences with memory
**** \clsspl{Stream} handle these.
     - Streams have memory.
     - You need memory to keep track of your place in a more complex structure.

** Data streams for note information
*** From Array to Stream
**** Turning an array into a stream
     - Wrap a \mth{do} loop in a \clss{Routine}.
     - If you want the array to repeat, wrap that in a \mth{loop}.
**** Inconvenient to rewrite for every array
     - Write a function that converts it for you.
     - *Very common strategy:* Make a function for code you need to reuse.
#+name: seqfunc
#+caption: A function that converts an array into a stream.
#+begin_src {} -i
f = { |array|
   Routine {
      loop {
         array.do { |item| item.yield };
      };
   };
};
#+end_src

*** Piano Phase, with streams
    - No longer necessary to deal with array indexing.
    - The \clss{Tdef} function is a lot simpler.
#+name: noteseq4
#+caption: Use the array-stream function in the sequence.
#+begin_src {} -i
(
var midi = f.value([59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68]),
sawWidth = f.value([0.1, 0.5, 0.2, 0.5, 0.5, 0.5,
   0.1, 0.5, 0.5, 0.1, 0.5, 0.5]);

Tdef(\reich, {
   loop {
      ~out.set(
         \t_trig, 1,
         \freq, midi.next.midicps,
         \width, sawWidth.next
      );
      0.15.wait;
   }
}).play;
)
#+end_src

*** But isn't there an easier way?
**** There is: \eGlspl{pattern}.
     - Patterns make up a large library of predefined streaming behaviors.
     - The entire function from Listing [[seqfunc]] can be written /in one line/ using patterns:\\<all>
       \cd{Pseq(array, inf).asStream}
**** We will look at some basic patterns next.			   :noexport:
     These should help you with today's final exercises.

*** Patterns for existing data
**** For more details, look up the pattern's help file.
     - \clss{Pseq}\cd{(list, repeats)}: Read out a list in order.
     - Read out a list in random order:
       - \clss{Pshuf}\cd{(list, repeats)}: "Shuffle" (use all items exactly once).
       - \clss{Prand}\cd{(list, repeats)}: Choose an item randomly each time, allowing repeats.
       - \clss{Pxrand}\cd{(list, repeats)}: Like \clss{Prand}, but will not repeat the same item twice in a row.
       - \clss{Pwrand}\cd{(list, weights, repeats)}: Weighted random choice. Each item has a different probability.

*** Patterns to generate data
    - \clss{Pwhite}\cd{(lo, hi, length)}: Generate random numbers between low and high boundaries, with a linear distribution.
    - \clss{Pexprand}\cd{(lo, hi, length)}: Generate random numbers with an exponential distribution.
    - \clss{Pseries}\cd{(start, step, length)}: Yield an arithmetic series. Each value is the previous value plus a given step size.
    - \clss{Pgeom}\cd{(start, grow, length)}: Yield a geometric series. Each value is the previous value times a given growth factor.
**** You can do math on patterns.
     E.g., \cd{Pwhite(1, 50, inf) * 2} will make /even/ random numbers between 2 and 100.

*** Piano Phase, with patterns
    - Not much different from Listing [[noteseq4]].
    - But, \clss{Pseq} is more descriptive than \cd{f.value}.
#+name: noteseq5
#+caption: Use patterns to make the streams in the sequence.
#+begin_src {} -i
(
var midi = Pseq([59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68], inf).asStream,
sawWidth = Pseq([0.1, 0.5, 0.2, 0.5, 0.5, 0.5,
   0.1, 0.5, 0.5, 0.1, 0.5, 0.5], inf).asStream;

Tdef(\reich, {
   loop {
      ~out.set(
         \t_trig, 1,
         \freq, midi.next.midicps,
         \width, sawWidth.next
      );
      0.15.wait;
   }
}).play;
)
#+end_src

*** Pattern proxies
    - We used \clsspl{NodeProxy} as a fixed reference point for synthesis, while changing the content.
    - \clss{Tdef} does this for Tasks.
    - Pattern proxies do the same for patterns.
**** We'll use \clss{Pdefn} for the exercises.
     - \clss{Pdef} is a \clss{Tdef} for /event patterns/ (tomorrow...).
     - \clss{Pdefn} is for number patterns, like we're using.

*** Piano Phase, with pattern proxies
**** You can change the notes/widths by changing the \clsspl{Pdefn}!
#+name: noteseq6
#+caption: Use pattern proxies to make the streams in the sequence.
#+begin_src {} -i
(
Pdefn(\midi, Pseq([59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68], inf));
Pdefn(\sawWidth, Pseq([0.1, 0.5, 0.2, 0.5, 0.5, 0.5,
   0.1, 0.5, 0.5, 0.1, 0.5, 0.5], inf));

Tdef(\reich, {
   var midi = Pdefn(\midi).asStream,
   sawWidth = Pdefn(\sawWidth).asStream;
   loop {
      ~out.set(
         \t_trig, 1,
         \freq, midi.next.midicps,
         \width, sawWidth.next
      );
      0.15.wait;
   }
}).play;
)
#+end_src

*** Routine summary
**** \clss{Routine}, \clss{Task}: Pausable operations
     - Do work, then \mth{yield} something.
**** \eGlspl{loop}: Write code once, do it many times.
     - \cd{number.do}: Do it $n$ times.
     - \cd{array.do}: Do it once for every item in the array.
     - Loops should always have a way to stop. Avoid \eglspl{infinite loop}.

*** Note sequencing summary
**** Note sequencing with \clss{Routine} and \clss{Task}
     1. Calculate new musical values (pitch, rhythm etc.).
     2. Set controls within the \clss{ProxySpace}. Use \mth{setEvent} for convenience.
     3. Yield the time until the next event: \cd{time.wait}. \glsadd{wait}
**** Storage and GUI control with \clss{Tdef}
     - Also allows you to replace the function without breaking the flow.

*** Pattern summary
**** \eGlspl{pattern} are useful shortcuts for common types of streams.
     - List patterns for arrays (original or random order).
     - Generator patterns for math.
**** \mth{asStream} to turn a pattern into a stream.
     - Use anywhere you could use a \clss{Routine}.
**** Pattern proxies for free experimentation.
     - For now, \clss{Pdefn} handles value patterns.
     - Tomorrow, we'll look at event patterns and \clss{Pdef}.

*** Sequencing exercises
    1. Edit Listing [[noteseq6]]:
       - Add another \clss{Pdefn} for \ci{\textbackslash dur}.\\
	 For a constant value, it's enough to write \cd{Pdefn(\textbackslash dur, value)}.
       - In the \clss{Tdef}, make another variable for its stream and use it to control the wait time.
    2. Plug the basic pattern types into the three \clsspl{Pdefn}.
       - What is the effect of each one?
    3. Experiment, and compose a sequence that you like.
       - The sequence may involve randomness.
**** Be careful with \ci{\textbackslash dur}.
     Make sure it's always > 0. Otherwise, you might lock up the interpreter.

* Glossary							   :noexport:
# #+LaTeX: \glsaddall
# http://www.latex-community.org/forum/viewtopic.php?f=5&t=16833
#+LaTeX: \renewcommand{\glossarysection}[2][]{}
** Concepts
#+LaTeX: \printglossary[type=main]
** UGens
#+LaTeX: \printglossary[type=ugen]
** Other classes
#+LaTeX: \printglossary[type=class]
** Methods
#+LaTeX: \printglossary[type=mth]
* Removed (always noexport!!) 					   :noexport:
*** Canonical explanation
#      1. \mth{add} a \clss{SynthDef} into the server.\\<all>
# 	\clss{SynthDef}: A /synthesis definition/.
#      2. Play it, using \clsspl{Synth} or \clsspl{Event}.
# 
#      - 
#      - \clsspl{SynthDef} usually include everything for one note.
#      - Bigger code blocks are harder to understand at the beginning.
*** Important idea: /Modular/ design
**** A \te{modular} approach breaks a problem into smaller pieces.
     - For synthesis, it means you can play with the different pieces independently.
     - For example, replace the \ci{\textasciitilde freq} module.
     - It changes immediately to a changing frequency.
# #+name: ps2
# #+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

*** SuperCollider's standard synthesis model
**** The normal way to make sound in SC:
     - Write a \clss{SynthDef}: A /synthesis definition/.\\
       Compiled once and sent to the server in a binary format.
     - Play many copies of the \clss{SynthDef} using \clsspl{Synth} or \clsspl{Event}.
**** Problems for learning:
     - \clsspl{SynthDef} usually include everything for one note.
     - Bigger code blocks are harder to understand at the beginning.
     - Then people complain, "SuperCollider is too hard."

*** Syntax
**** \te{Syntax}: Rules defining "legal" expressions.
     E.g., \cd{x + y} is legal, while \cd{x y + 3} is not. You can't have \cd{x} and \cd{y} next to each other with only a space in between.
*** Usage summary
**** Write audio processing into a \clss{Function}.
     - These functions should create \eglspl{UGen}: \cd{SinOsc.ar} or \cd{.kr}.
     - \cd{aFunction.play} /adds/ new synthesis into the server.
**** \clss{ProxySpace} for plug-and-play.
     - Automatically turns functions into synthesis.
     - Reassigning an environment variable /replaces/ synthesis.
**** \te{Modular} style of writing.
     - Use /small/ synthesis functions.
     - Connect them by using the environment variable in another UGen's inputs.
**** \eglspl{UGen} (Unit Generators)				   :noexport:
     - Input signals \to UGen \to Output signal
     - Connections: UGen A's output \to UGen B's input


UGens are created by the \ci{ar} and \ci{kr} methods; here is where you write the input signals.

*** EnvGen, not used yet					   :noexport:
#+begin_example
~eg = { |gt|
	EnvGen.kr(
		envelope: Env.adsr(0.01, 0.1, 0.4, 0.25),
		gate: gt
	)
};

~out = { ~filter.ar * ~eg };
~out.play;

~eg.set(\gt, 1);
~eg.set(\gt, 0);

p.setEvent((freq: exprand(200, 600), gt: 1, sustain: 2)).play;

~out.stop;  // We'll use these proxies some more
#+end_example

* Footnotes

# [fn:1] Events with ProxySpace: [[Events with ProxySpace]].

[fn:1] Online copy at [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_01_Introduction.html][doc.sccode.org]].

[fn:2] "A Short History of Computer Music." Author
unattributed. http://artsites.ucsc.edu/EMS/music/equipment/computers/history/history.html. Accessed
24 January 2014.

