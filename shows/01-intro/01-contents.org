#+startup: beamer

#+TITLE: SuperCollider Week, Day 1 \\ Introductory SC, Synthesis and Sequencing
#+DATE: \today
#+AUTHOR: H. James Harkins
#+EMAIL:

#+INCLUDE: "../slidehead.org"
# #+INCLUDE: "../printhead.org"

#+include: "../glossary.org"

* Temp, just to put it in a frame
*** Temp, just to put it in a frame
#+call: makegloss
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :results value latex
#+results: mthgloss

#+call: ugengloss
#+results: ugengloss

* Workshop introduction						   :noexport:
** Workshop introduction
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001).
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou.
     - Subjects: Electronic music production, Film music.
**** Special interests:
     - Danceclub music.
     - Real-time performance with computers.

*** What is SuperCollider?
**** /Programming language/ for audio and composition
     - Created by James McCartney.
     - Conceptual basis: SmallTalk.
       - /Object-oriented/ like Java, but still fun (not like Java).
     - Syntax: More like C.
**** Left							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: smalltalk
#+caption: 25% coin toss in SmallTalk.
#+begin_src {} -i
(1 to: 100) atRandom <= 25
   ifTrue:
      [Transcript show: "heads"]
  ifFalse:
      [Transcript show: "tails"]
#+end_src
**** Right							      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
#+name: sccoin
#+caption: 25% coin toss in SuperCollider.
#+begin_src {} -i
if(0.25.coin) {
   "heads".postln
} {
   "tails".postln
};
#+end_src

*** Workshop goals
**** Teach synthesis techniques by experimentation
     - SC lets us take apart synthesizer components, and put them back together.
     - SC's /Just-In-Time library/ makes it easy to re-patch components interactively.
**** Teach techniques for live control and performance
     - Control by graphic interfaces and external devices.
     - End goal: A group composition, to perform together.
**** *Have fun programming!*
     - Emphasis on /play/ over /correctness/.

*** Start with a modular approach
**** At first: \eGls{modular} synthesis using \egls{JITLib}.
     Advantages:
     - Tiny, easy-to-understand code blocks.
     - Easy ways to connect and reconnect signals.
**** Not the standard approach in SC.
     - The standard approach is more /efficient/ but less /playful/.
     - Later in the workshop, we will learn the standard way.

** Brief, incomplete history of audio programming
*** Music "n" languages
    The *Music \emph{n}* languages (Music I, II etc.), by Max Mathews,
    were the first successful audio programming languages.
**** Structure
     - An \te{orchestra file} defines synthesis "instruments."
     - A \te{score file} lists musical events:\\
       Onset time, instrument, parameters.
     - \te{Compile} the two into an audio file.
     - *Not interactive.*
**** Modern incarnation: /csound/.
     Current versions have some interactive features.

*** Article: prehistory					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** We have it so much easier than they did.
We can run some code on a laptop and to hear the result right now. This is because:
- Your laptop can calculate audio faster than it will play. By
  contrast, Music II took an hour to calculate one minute of
  music.[fn:2]
- You don't have to share computer time with other users. In the
  1960s, there were only mainframes, no PCs. You had to prepare a job,
  submit it for processing when there was enough computer time
  available and wait for the result. If the result was wrong... wait
  until the next day.
- Your laptop has a built-in sound card. Max Mathews developed the
  Music \emph{n} languages at Bell Labs in New Jersey. They had the
  computer, but no DAC ("Digital-to-Analog Converter") to hear the
  results. They had to wait to get the digital audio tapes from the
  mainframe, and then physically drive them up to Columbia University
  in New York City to listen---and all that, just to find out what
  mistakes they made in the program!

*** Dataflow environments
    Dataflow languages include *Max/MSP* and *Pure Data*. They
    represent everything as a flow of signals between graphical
    objects.
    - Good: Intuitive to wire up interfaces quickly.
    - Bad:
      - Relatively weak data structures (hard to represent musical information in an articulate way).
      - Monophonic processes, easy; polyphonic, hard.
      - Complexity barrier.

*** ChucK
    /ChucK/ is a programming language for \egls{live coding},
    developed by Ge Wang at Princeton University (2003-2008).
    - Integrated timing: Audio and program control run under the same timing mechanism.
    - The "ChucK operator" \ci{=>} for connecting synthesis units.\\
      E.g., \ci{source => filter} rather than (in SC) \ci{Filter.ar(source)}.
    - Graphical environments for live coding in groups.

*** SuperCollider version history
**** McCartney's work before SuperCollider
     - /Synth-O-Matic/ (1990).
     - /Pyrite/ (scripting language for Max).
**** SuperCollider
     - SC1: Synth-O-Matic + Pyrite.
     - SC2: Influence from SmallTalk.
       - SC language is nearly complete.
       - One significant audio processing inefficiency.
     - SC3 ("SC Server").
       - Audio processing is more efficient, by handling audio in a /server/ process.

* SC architecture, usage					   :noexport:
** SC architecture
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - \egls{scide}: SC Integrated Development Environment.
       - Code editor, display, documentation.
     - \egls{sclang}: SC language.
       - IDE sends code to sclang.
       - sclang runs the code, sends printed output back to IDE.
     - \egls{scsynth}: SC synthesis server.
       - sclang sends \gls{OSC} (Open Sound Control) messages to scsynth.
       - scsynth sends audio to the hardware.
       - May also reply to sclang.

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[./img/sc-with-guis.pdf]]
    #+end_center

*** Server/client design
**** *Server/client* design
     :PROPERTIES:
     :BEAMER_act: presentation
     :END:
     - Server does heavier work (e.g., databases).
     - Client makes requests of the server.
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server.\\
       /Open Sound Control/ (\gls{OSC}) protocol.
       - "Here's a /synthesis definition/ (\clss{SynthDef})."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

*** Why server/client?
**** Efficiency
     - Synthesis definitions are /reusable/.\\
       Optimizing a \clss{SynthDef} is relatively slow. Doing this
       once for thousands of notes is more efficient than once for
       every note.
**** Networked applications
     - Many clients can use the same server.
**** Not limited to SC language
     - Any language that supports OSC can use SC audio!
     - Python, Clojure, Scala, Haskell, Scheme...
     - In free software, /user choice/ is important. Prefer /open/
       designs, rather than closed.

** Using the Integrated Development Environment
*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status.
       - Server control (click on the server status).

*** Asking for help
**** Help system keyboard shortcuts
     - Ctrl-D :: Look up help for the keyword under the cursor.
     - Ctrl-Shift-D :: Pop up a box where you can type the search term.
**** Try it
     - Type \cd{SinOsc} into the code window.
     - Hit \ks{Ctrl-D}.
       - SC reads the help index the first time in the session.
       - It's faster after that.
**** Important help browser features
     - "Search" and "Browse" pages.
     - Table of contents in each help page.

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line.
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end.\\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+Begin_src {} -i
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

* SC language: Beginning steps					   :noexport:
** Making noise
*** Before making noise: Set up audio
**** OSX
     - Can choose the device within SC. See below.
     - Or, choose the device in OSX's audio control panel.
**** Windows
     - You /must/ choose the device within SC.
     - Boot the server, then quit, to get the list of devices.
**** Linux
     - \egls{scsynth} goes through the JACK audio server.
     - All audio configuration, including device, is done in JACK. /qjackctl/ can help.
     - *Start JACK before booting the server!*

*** Setting devices within SC
**** First, get a list of devices.
     - *OSX:* \cd{ServerOptions.devices}
     - *Windows:* Boot the server. Then look for the device list.
**** Set the device in \clss{ServerOptions}.
     - You must quote the device name exactly.
#+begin_src {} -i
s.options.device = "Device Name";
#+end_src
**** Reboot the server.
     - Quit first, if needed.
     - It should use the chosen device now.

*** Windows: ASIO
**** Strongly recommended to use an ASIO sound driver.
     - The default Microsoft MME driver will work, but its \egls{latency} is very high.
       - Latency: the delay between calculating the audio and hearing it.
       - For live use, 30 ms is too much.
       - MME can go as high as 230 ms!
     - If your soundcard installed an ASIO driver, use it.
     - For the built-in soundcard, use ASIO4ALL.

*** Boot the server
**** Boot the audio server.
     - Code: \cd{s.boot}.
     - IDE keyboard shortcut: \ks{Ctrl-B}.
     - See also /Language/ menu and server status.
      
*** "Canonical" SC synthesis
#+name: canonical
#+caption: SuperCollider's "native" style of synthesis.
#+begin_src {} -i
// A synthesis definition
(
SynthDef(\varsaw, { |out = 0, freq = 440, width = 0.5,
   amp = 0.1, gate = 1, pan = 0|
   var sig = VarSaw.ar(freq, 0, width),
   env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
   Out.ar(out, Pan2.ar(sig * env, pan));
}).add;
)

// Playing it: Object style
a = Synth(\varsaw, [freq: exprand(200, 500),
   width: rrand(0.2, 0.5)]);

a.release;  // to stop it

// Playing it: Event style
(instrument: \varsaw, freq: exprand(200, 500),
width: rrand(0.2, 0.5), sustain: 2).play;
#+end_src

*** "Canonical" objects and messages
**** All these commands send \egls{OSC} messages.
#+begin_center
[[./img/server-msg-diagram.pdf]]
#+end_center

*** When to use "canonical" style
**** "Canonical" style is good for finished works.
     - Maximum efficiency with structures that you've worked out in advance.
     - Not good for experimenting with signal flow.
     - Not ideal for learning: Too many details to learn before you
       can use \clsspl{SynthDef} comfortably.
**** Typical workflow
     - Begin with loosely-structured code. Play freely with it.
     - When you find sounds and sequences you like, "freeze" them into more stable structures.

*** \{\}.play shortcut
**** This shortcut makes it faster to experiment.
     It handles both parts for you:
     - Makes the \clss{SynthDef} automatically.
     - Makes the \clss{Synth}.
#+latex: \glsadd{play}\glsadd{release}\glsadd{dup}\glsadd{SinOsc}
#+name: sound1
#+Caption: A very simple synth.
#+Begin_src {} -i
a = { SinOsc.ar(440, 0, 0.1).dup }.play;

// To make it stop:
a.release;
#+End_src

*** Tweak it
**** Try changing the numbers.
     On your own---a minute or so to experiment.
     @@latex:\glsadd{release}@@
     - Run \cd{a.release} before re-running the synth.
     - What happens if you forget?
       - If you forget: press \ks{Ctrl-.} to stop everything.
       - \ks{Ctrl-.} is SC's panic button.
**** Be careful with the third number!			       :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     If it's too high, you could hurt your ears.
**** What do you think the numbers mean?

*** Easier tweaking: ProxySpace
**** \clss{ProxySpace} makes it safer to play around.
    - Too easy to forget \cd{a.release}.
    - \clss{ProxySpace} automatically replaces the synth, instead of adding.
    - It does a lot more. We'll use it for most of the workshop.
      @@latex:\glsadd{ProxySpace}\glsadd{VarSaw}\glsadd{dup}\glsadd{SinOsc}\glsadd{play}\glsadd{stop}@@
#+name: ps1
#+caption: Basic use of ProxySpace.
#+begin_src {} -i
p = ProxySpace.new;
p.push;

// run these one by one
~out = { SinOsc.ar(440, 0, 0.1).dup };
~out.play;

~out = { SinOsc.ar(220, 0, 0.1).dup };
~out = { VarSaw.ar(110, 0, 0.1, 0.1).dup };

~out.stop;
#+end_src

** SC language syntax
*** Taking it apart
**** Now we know enough to step back and see what this is made of.
     - This part is a little dry and technical.
     - But, to talk about SC, you need to know some important terms.

*** Taking it apart: Functions
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-02-function.pdf]]
     #+end_center
***** A \clss{Function} is a block of code in curly braces.
     - Functions can take information in through \egls{arguments}.
     - \te{Call} a function using \mth{value}.
     - When you call it, SC:
       - Runs all the code inside;
       - Returns the value of the last expression.
     - SC uses Functions for:
       - Synthesis
       - Abstraction (packaging behavior to reuse later)

*** Function example: Hypotenuse
**** Remember right triangles from math class?
     - $a^2 + b^2 = c^2$, so $c = \sqrt{a^2 + b^2}$.
     - In SC: \cd{sqrt(a.squared + b.squared)}.
**** How do we get \ci{a} and \ci{b} in there?
     - That's what the \egls{arguments} are for.
     - \cd{arg a, b;}: \ci{a} and \ci{b} will get their values from the \mth{value} call.
     - \cd{f.value(3, 4)}: \ci{a} is 3, \ci{b} is 4.\\
       So the whole expression is @@latex: \cd{sqrt(3.squared + 4.squared)} $\to$
       \cd{sqrt(9 + 16)} $\to$ \cd{sqrt(25)} $\to$ 5@@.
#+name: func1
#+caption: A function to calculate a hypotenuse.
#+begin_src {} -i
f = { arg a, b; sqrt(a.squared + b.squared) };

f.value(3, 4);   // prints "5"
f.value(5, 12);  // prints "13"
#+end_src

*** Argument defaults
**** What if you leave out an argument value?
     You can specify a \egls{default} value, to use if you don't give another value.
**** Initialize an argument to:
     - Constant :: \cd{name = value}. Must be a \egls{literal} value: \cd{5}, \cd{'abc'}.
     - Expression :: \cd{name(value)}.
#+name: func2
#+caption: Default values for a and b in the hypotenuse function.
#+begin_src {} -i
f = { arg a = 3, b = 4; sqrt(a.squared + b.squared) };

f.value         // prints "5"
f.value(5);     // prints "6.403..."; b is still 4
f.value(b: 5);  // prints "5.830..."; a is still 3
#+end_src

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** A \egls{variable} holds an object.
      - You must put an object in a variable if you want to address it later.
      - We need to \mth{release} the synth. So, save the \clss{Synth} object in a variable.
***** Access a variable's value by referring to its name.
#+latex: \glsadd{assignment}
      After \te{assigning} the Synth to \ci{a}, a reference to \ci{a} gets the Synth.
      - So \cd{a.release} acts on precisely that Synth.

*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \te{Declared} variables
     - Any function can \egls{declare} variable names.
     - Declared variables exist only inside that function!\\
       This is called \egls{local} scope.
     - \eGls{arguments} are variables, but get values from outside.
#+name: declarevars
#+caption: A function that declares a variable.
#+begin_src {} -i
f = {
   var random;
   random = 10.rand;
   random + random
};
#+end_src
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{interpreter} variables
      - Single letters \cd{a}--\cd{z}.
      - \eGls{global} scope. Interpreter variables may be used anywhere
       	(unless a function declares a single-letter variable).
*** Taking it apart: Variables
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
***** \eGls{environment} variables
      - Start with \cd{\textasciitilde}, e.g. \cd{\textasciitilde environmentVar}.
      - Full names, like declared variables.
      - You don't have to declare them.
      - "Quasi-global" scope.
***** ProxySpace uses environment variables for synth nodes.

*** Variable assignment
**** {1\textwidth}{3in}				     :B_overlayarea:noexport:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-01-variable.pdf]]
     #+end_center
**** The \egls{assignment} operator (\ci{=}) puts an object into a variable.
     Assignment is /not/ the same as $=$ in a math equation.
     - In algebra, $x=x+1$ is simply false: meaningless.
     - In most programming languages, \cd{x = x + 1} means to
       /replace/ the number currently in \ci{x} with that number + 1.
     - To test equality, use \ci{==}.
#+name: varassg1
#+caption: Variable assignment.
#+begin_src {} -i
x = 0;
y = x;
x == y;  // prints true

y = y + 1;  // prints 1
x == y;  // prints false
#+end_src

*** Taking it apart: Classes
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-03-class.pdf]]
     #+end_center
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** A \egls{class} is an \te{object type}.
       Classes define two things:
       - Data :: Objects remember specific information.\\
       	 E.g., a \cd{Point} knows its /x/ and /y/ coordinates.
       - Actions :: Objects know how to do specific things.\\
       	 E.g., You can add two \ci{Point}s together: \cd{point1 + point2}.\\
       	 The \cd{Point} \te{class} declares how a Point should do \cd{+}.
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \ugen{SinOsc} is a \egls{UGen} (Unit Generator) class.
       - Unit generators are audio-processing operations in the server.
       - UGen classes in SC language:
	 - /Name/ the audio processors.
	 - /Connect/ UGens together.

*** Taking it apart: Methods
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-04-methods.pdf]]
     #+end_center
***** A \egls{method} defines an action that an object can perform.
      It's like a function, but it has a name and belongs to a class.
      - \mth{ar} :: Makes an \te{audio rate} instance of \ugen{SinOsc}.
      - \mth{dup} :: Copies the mono signal from \ugen{SinOsc} into both left and right channels.
      - \mth{play} :: Makes a \te{synth node} from the function.\\
       	\mth{play} is one of the most important methods. Lots of things in SC know how to \ci{play}!

*** Taking it apart: Arguments
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
     #+begin_center
     [[./img/take-apart-05-args.pdf]]
     #+end_center
***** \eGls{arguments} pass information into a method or function.
      - In general, UGens take numbers or signals as inputs.
      - They generate signals as output.
      - \ugen{SinOsc}'s arguments are:
       	- freq :: In Hz.
       	- phase :: In radians (0--$2\pi$).
       	- mul :: Amplitude.
       	- add :: An offset (generally not used for audio).

*** Method calls: Most important thing
**** The SC language is all about /calling methods/.
     Everything happens in SC through method calls. *Everything.*\\
     (Except variable \egls{assignment}: \cd{x = 1}.)
     - Function calls? \mth{value} method.
     - Math? \cd{+}, \cd{-} are methods.
     - Flow-of-control mechanisms? \ci{do}, \ci{while}, \ci{if} etc. are methods.
**** If you understand how to use methods, you understand almost all of SC syntax.
     The hard part: Learning which methods do what!

*** Parts of a method call
**** A \gls{method call} consists of three parts:
    - \Gls{receiver} :: The object that will perform the method.
    - \Gls{selector} :: The method's name.
    - \Gls{arguments} :: Additional input (optional).
\\
In \cd{SinOsc.ar(440)}:
    - Receiver = the class \cd{SinOsc}
    - Selector = \cd{ar}
    - Argument = \cd{440}

*** Method call syntax
**** Three ways to call methods in SC.
    - "Dot" style :: \cd{receiver.selector(arguments...)}
    - Function style :: \cd{selector(receiver, arguments...)}
    - Infix style :: \cd{receiver selector: argument}\\
      Infix style allows only one argument.\\
      Binary operators (\cd{+}, \cd{-}, \cd{*}, \cd{/}, \cd{**}) are methods that use infix style.
      In \cd{1 + 2}: Receiver = 1, Selector = '+', Argument = 2
#+Name: callstyles
#+Caption: Three styles of method calls. They all answer with the same result, because the receiver, selector and argument are the same.
#+begin_src {} -i
[2.pow(3), pow(2, 3), 2 pow: 3]
// answers: [ 8, 8, 8 ]
#+end_src

*** Polymorphism
**** \eGls{polymorphism} is a fancy word for "one name, many meanings."
     A \gls{class} can respond to a request in a way that makes sense for it.
     - In Listing [[canonical]], we called \mth{play} on an \clss{Event}.
     - In Listing [[sound1]], we called \mth{play} on a \clss{Function}.
     - The specific actions are different.
     - The results are compatible: Something starts happening (in this case, sound).
**** In all cases, the \egls{receiver} chooses the method definition that's right for the object.
#+name: polymath
#+caption: Polymorphism with math operators. Try these one by one.
#+begin_src {} -i
1 + 2;
Point(3, 4) + 2;
[1, 2, 3, 4, 5] + 10;
[1, 2, 3, 4, 5] + [10, 20, 30];
SinOsc.ar + 1;
#+end_src

*** Audio summary
**** Making sound
     - Synthesis definition (\clss{SynthDef}).
     - A way to play the SynthDef (\clss{Synth}, \clss{Event}).
     - Shortcuts: @@latex:\cd{\{\}.play}@@, \clss{ProxySpace}.
**** SynthDefs connect \eglspl{UGen} (unit generators) together.
     - The language only keeps track of their connections.
     - The server processes them to make sound.

*** Language summary
**** Important SC language concepts
     - \gls{Function} :: A package of instructions, to be executed any time.
     - \gls{variable} :: A placeholder for an object (a reference to it).
     - \gls{arguments} :: Inputs to a function or method.
     - \gls{class} :: An object definition: /Data/ and /actions/.
     - \gls{method} :: An action that an object that knows how to perform.
     - \gls{receiver} :: The object that will answer the method call.
     - \gls{polymorphism} :: Allows objects to respond to requests in appropriate ways.

*** Next: Synthesis techniques					   :noexport:
    Now we know enough to start exploring standard synthesis techniques.

* Modular synthesis with JITLib
** What is modular synthesis?
*** Simple components, complex behavior
**** \Gls{modular} synthesis builds complex sounds from simple units.
     - Early hardware synthesizers were modular.
     - Lots of boxes: \eGlspl{oscillator}, \eglspl{filter}, \eglspl{envelope generator} etc.
     - Patch them together using physical cables.
#+begin_center
#+name: catmod
#+caption: A small (!) modular synthesizer, with cat. Image credit: Stephen Drake, http://commons.wikimedia.org/wiki/File:Cat_modular_synthesizer.jpg.
#+attr_latex: :height 1.2in
[[./img/800px-Cat_modular_synthesizer.jpg]]
#+end_center

*** Modular synthesis for teaching
**** Code complexity is a teaching problem.
     - Too much code at once, too hard to understand.
**** In a \gls{modular} approach:
     - Code blocks will be very small: 5--6 lines at most (at first).
     - Make lots of small modules (\clsspl{NodeProxy}).
     - Connect them to get complex results.
**** Flexible patching
     Because they're separate modules, it's easy to reconnect them anytime.

*** Example

*** "Just-In-Time" Library (JITLib)
**** JITLib is a system of \eglspl{proxy}.
     - Write the /connections/ between signals (and other data) based on the proxies.
     - You can change whatever is in the proxies at any time.
     - This does not change the connections!
     - Proxies can be very small and simple: easy to read and understand.
**** JITLib lets us play with signals.
     No need to worry about structure too soon, because you can change
     the structure and content independently.

*** Proxies: Cats and signals
    - A proxy is like a magic box.
    - If I give you a cat, you have the cat.
    - If I give you the magic box, you have whatever cat is inside the box.
    - You can reach into the box any time, and you know you'll pet a cat.
    - But the /specific cat/ can change.
**** Proxies and signals
     - Tell a filter to operate on whatever signal is in the box.
     - Change the signal in the box at any time.
     - The filter is still looking in the box!


** Playing notes by envelopes					   :noexport:
*** Playing separate notes
**** What defines a "note"?
     Mainly, it has a beginning and end!
**** How do we give a note a beginning and end?
     Standard way: \eGlspl{envelope}.
     - This is a standard feature of all synthesizers, including VST/AUs.
*** Breakpoint envelopes
**** Usually, envelopes are defined in terms of \eglspl{breakpoint}.
     This funny-shaped envelope has four segments, defined by five breakpoints.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
#+Name: env1
#+Caption: Plotting a breakpoint envelope.
#+Begin_src {} -i
Env(
   levels: [0, 1, 0.2, 0.6, 0],
   times: [0.1, 0.3, 0.8, 0.25],
   curve: [\lin, -4, 5, -2]
).plot;
#+end_src
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:
# #+name: env1png
# #+caption:
#+attr_latex: :width 0.4\paperwidth
[[./img/breakpoint-env.png]]
**** Graphic comes from						   :noexport:
w = Window("env", Rect(800, 200, 400, 300)).front;
x = EnvelopeView(w, w.view.bounds.insetBy(2, 2)).setEnv(e);

*** Envelope definition
**** An envelope is made of:
     - A starting value
     - A number of \eglspl{segment} (no practical limit):
       - A target level
       - A time duration
       - A segment shape (curve)
     - A \egls{releaseNode} and \egls{loopNode} (optional)
**** Note the difference between the /starting value/ and the segments' /target values/.
     This will become important later.

*** Writing an envelope definition
**** It's written like this:
#+begin_latex
\cd{Env(\\<all>
\hspace{0.5cm}levels: [start, level$_0$, level$_1$, level$_2$...],\\<all>
\hspace{0.5cm}times: [time$_0$, time$_1$, time$_2$...],\\<all>
\hspace{0.5cm}curve: [curve$_0$, curve$_1$, curve$_2$...],\\<all>
\hspace{0.5cm}releaseNode: nil, loopNode: nil\\<all>
)}
#+end_latex
**** Notes
     - Segment 0 is defined by @@latex:\cd{levels[\textbf{1}]}@@,
       \cd{times[0]} and \cd{curve[0]}.
     - \cd{levels[0]} is the starting value---not part of any segment!
     - \ci{curve} may be an array or a single value (which applies to
       every segment).

*** Add an envelope to the synth
**** Audio synths should have an amplitude envelope.
     - Start from silence, end with silence.
#+latex: \glsadd{EnvGen}\glsadd{Impulse}
#+Name: ampenv1
#+Caption: Apply an evenly-triggered amplitude envelope.
#+Begin_src {} -i
p = ProxySpace.new; p.push;

~oscil = { |freq = 220, detun = 1.003|
   Mix(Saw.ar(freq * [1, detun, detun.reciprocal], 0.1))
};
~filter = { |ffreq = 2000| LPF.ar(~oscil.ar, ffreq) };
~filter.addSpec(\ffreq, \freq);
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };

~out = { (~filter.ar * ~eg).dup }; ~out.play;

~out.stop;  // We'll use these proxies some more
#+End_src

*** Envelope generator UGen
# deliberately no caption: Don't want this numbered or collated
#+Begin_src {} -i
~eg = { EnvGen.kr(
   envelope: Env([0, 1, 0], [0.01, 0.6], -4),
   gate: Impulse.kr(1)
) };
#+End_src
**** \clss{Env} defines the envelope. \ugen{EnvGen} plays it.
     - Inputs used here:
       - envelope :: The \clss{Env} definition.
       - gate :: The trigger or gate input. (More about gates later.)
     - Its output is a signal which:
       - Starts at 0;
       - Rises quickly to 1 over 0.01 seconds every time a trigger comes into \ci{gate};
       - Falls back to 0 over 0.6 seconds.

*** Triggers
**** Plot code							   :noexport:
{ var trig = Impulse.ar(300);
   [trig, EnvGen.ar(Env.perc(0.01, 0.6), trig, timeScale: 1/300)]
}.plot;
**** A \egls{trigger} happens when a signal crosses from $\le$ 0 to > 0.
     - Many UGens respond to triggers.
     - Here, the trigger signal consists of \eglspl{impulse}.
     - Common trigger UGens:
       - \ugen{Impulse} :: Impulses at a constant frequency.
       - \ugen{Dust} :: Impulses at random durations, according to an average density.
#+Begin_center
#+attr_latex: :height 1in
[[./img/trigger-and-envgen.png]]
#+End_center

*** Envelope generator as amplifier
**** Amplifier is multiplication (\ci{*}).
#+Begin_src {} -i
~out = { (~filter.ar * ~eg).dup }; ~out.play;
#+End_src
     Amplitude envelope is usually last in the chain.
     - Here, it's in an \cd{\textasciitilde out} proxy.
     - \cd{\textasciitilde out} is the one that gets played.
#+begin_center
#+attr_latex: :height 1.5in
[[./img/visualize-proxy-network.pdf]]
#+end_center

*** Explore envelope behavior
**** Add two parameters: trigger frequency and decay time.
     Try these settings. Why do they sound like that?
     - Normal decay, high trigger rate > 30.
     - Short decay, high trigger rate.
     - Long decay > 1, medium trigger rate $\approx$ 3.5.
#+Name: ampenv2
#+Caption: Add parameters to the envelope generator.
#+Begin_src {} -i
~eg = { |tfreq = 1, decay = 0.6|
   EnvGen.kr(
      Env([0, 1, 0], [0.01, decay], -4),
      Impulse.kr(tfreq)
   )
};
~eg.addSpec(\tfreq, [0.5, 50, \exp]);
~eg.addSpec(\decay, [0.05, 1.5, 2]);
p.gui;
#+End_src

*** Envelope graphs
**** Plot functions						   :noexport:
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300) }.plot;
{ EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300) }.plot;
**** {1\textwidth}{3in}					      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** Initial settings
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope has plenty of time to fall to 0 (silence) between
       notes.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-normal-d0.6-f1.png]]
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** Same decay, much faster triggers
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope doesn't have enough time to decay, so the sound is
       almost continuous.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.6-f30.png]]
***** O3 							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
****** Fast triggers, very short decay.
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       The envelope decays quickly, so the sound gets much quieter
       between triggers. But the triggers come very quickly---30 Hz is
       within audio range---so we hear a strong \egls{amplitude modulation}
       effect, adding another pitch.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d0.05-f30.png]]
***** O4							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
****** Medium triggers, long decay
****** left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       You can hear the envelope decay, but it doesn't go all the way
       to silence. So the effect is more like /legato/ playing.
****** right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.5
       :END:
       #+attr_latex: :width 0.4\paperwidth
       [[./img/eg-d1.12-f3.png]]

# #+Name: ampenv2
# #+Caption: Add parameters to the envelope generator.
# #+Begin_src {} -i
# {
#    [
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.6), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 0.05), Impulse.ar(300*30), timeScale: 1/300),
#       EnvGen.ar(Env.perc(0.01, 1.12), Impulse.ar(300*3), timeScale: 1/300)
#    ]
# }.plot;
# #+End_src

** Timed and sustaining envelopes				   :noexport:
*** Standard envelope shapes: Timed
    - \mth{linen} :: Linear attack and decay, flat sustain.
    - \mth{perc} :: Curved attack and decay, no sustain.
    - \mth{sine} :: Sine-shaped attack and decay, no sustain.
#+name: tryEnv1
#+caption: Try plotting these timed envelope shapes. Modify the example to try the other methods. Use auto-completion to see the parameter names and defaults.
#+begin_src {} -i
Env.linen(0.1, 1, 0.1).plot;
#+end_src

*** Sustaining envelopes (OK with \glspl{gate})
    *Note:* For these two, \ci{sustain} is a level, not a time.
    - \mth{adsr} :: Attack-Decay-Sustain-Release.\\
      This is one of the most standard envelope types, found in
		    almost any synthesizer.
    - \mth{asr} :: Same as \ci{adsr}, but without the decay
		   portion.
#+name: tryEnv2
#+caption: Try plotting these sustaining envelope shapes.
#+begin_src {} -i
Env.adsr(0.1, 0.25, 0.5, 0.2).plot;
#+end_src

*** Sustaining envelopes
**** Why sustaining envelopes?
     - When playing on a MIDI keyboard, you don't know in advance how long to sustain.
     - So you need an envelope that will wait for a signal to release.
**** \egls{releaseNode} creates a sustaining envelope.
     - The release node is the release segment's index.
     - For example, ADSR has:
       - Attack: Segment 0
       - Decay: Segment 1
       - Release: Segment 2
     - So releaseNode is 2.

*** Sustaining envelopes and gates
**** Plot code							   :noexport:
{ var trig = Impulse.ar(30);
	trig = Trig1.ar(trig, TRand.ar(1/120, 1/40, trig));
	[trig, EnvGen.ar(Env.adsr(0.01, 0.1, 0.5, 0.01), trig, timeScale: 1/30)]
}.plot(0.1);

{ var trig = Impulse.kr(1);
    trig = Trig1.kr(trig, TRand.kr(3/12, 3/4, trig));
    [trig, EnvGen.kr(Env.adsr(0.01, 0.1, 0.5, 0.2), trig)]
}.plot(2);
**** That signal is a \egls{gate}.
     - A gate is > 0 when open, and $\le$ 0 when closed.
     - \ugen{EnvGen} triggers when a gate opens, and releases when it closes.
     Note the effect of the different open/close times.
#+Begin_center
#+attr_latex: :height 1.5in
[[./img/gates-and-env.png]]
#+End_center

*** Sustaining envelope in ProxySpace
**** Replace the timed envelope with a sustaining envelope.
     - No longer a trigger, so change \ci{t\textunderscore trig} to \ci{gt}.
       - Normally a \clss{SynthDef} calls the gate input \ci{gate},
         but that's reserved for another use in \clss{ProxySpace}.
     - Use \mth{set} to open and close the gate.
#+name: susEnv
#+caption: Plug a sustaining envelope into the analog-style synth.
#+begin_src {} -i
~eg = { |gt = 0|
   EnvGen.kr(
      envelope: Env.adsr(0.01, 0.15, 0.4, 0.1),
      gate: gt
   )
};

~eg.set(\gt, 1);  // trigger
~eg.set(\gt, 0);  // release
#+end_src

** Events and envelope gates					   :noexport:
*** More convenience for gates: Events
**** Sequencing: inconvenient to close gates by hand.
     Introducing \clss{Event}.
     - We will learn more about events as we go.
     - Events have lots of pryoperties, including timing.
       - \ci{dur} :: Number of beats until the next event.
       - \ci{sustain} :: Number of beats to keep a gate open. (May
                         also be calculated from \cd{dur * legato}.)

*** Events with ProxySpace
    - In \clss{ProxySpace}, a special event type can set parameters globally in the entire space.
      - \mth{setEvent}
    - This event type handles \ci{gt} specially.
      - It automatically closes the gate if you provide a \ci{sustain} time.
      - So, for this usage pattern, get used to using \ci{gt} for gates.
#+name: gateEvent
#+caption: Hold a gate open for a given amount of time using an Event.
#+begin_src {} -i
p.setEvent((gt: 1, sustain: 0.5)).play;
p.setEvent((gt: 1, sustain: 3)).play;
#+end_src

*** Coordinated changes with Events
**** An \clss{Event} can set lots of controls at once.
     - Just list them in the same \cd{name: value} syntax.
     - If the name exists anywhere in the \clss{ProxySpace}, the event will find it and set it.
     - \mth{exprand}: random frequency according to an \egls{exponential} scale.
     - \mth{degree}: interprets \mth{rrand} number as a diatonic scale degree.
# nb: \mth{degree} is actually listed in the main glossary
#+name: multiSetEvent
#+caption: Set both frequency and gate.
#+begin_src {} -i
p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;

p.setEvent((degree: rrand(-14, 0), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
     We are now /centimeters/ away from sequencing!

** Another envelope use: Articulation				   :noexport:
*** Envelopes for articulation
**** Envelopes can control any parameter.
     /Very/ common: control the filter frequency, for articulation.
     - Create a new \ugen{EnvGen}, as a multiplier for \ci{ffreq}.
     - Use it in the \ci{\textasciitilde filter} module.
#+latex: \glsadd{clip}
#+name: filterEg
#+caption: Apply an envelope to the filter frequency.
#+begin_src {} -i
~feg = { |gt = 0|
   EnvGen.kr(Env([1, 4, 1], [0.01, 0.15], -4), gt)
};

~filter = { |ffreq = 2000, rq = 0.2|
   RLPF.ar(~oscil.ar,
      clip(ffreq * ~feg, 20, 20000),
      rq
   )
};

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src

*** Notes on that example
**** Filter envelope as a multiplier.
     - The envelope /modulates/ the set filter frequency. You get
       articulation /and/ independent timbre control.
     - \cd{ffreq * \textasciitilde feg} may go outside the valid
       frequency range. \mth{clip} it for safety.
       - \mth{clip} moves out-of-range values to the nearest boundary.
       - Filters tend to blow up if the frequency goes out of range.
**** \cd{p.setEvent} treats the control inputs globally.
     - \cd{gt: 1} in the event sets \ci{gt} in both envelope modules
       simultaneously.

*** Articulation: Noise oscillator with envelope
**** With envelopes, we can use a noise generator.
     - A classic analog synthesizer trick for a "chff" in the attack.
     - Add a short, percussive (\cd{Env.perc}) burst of noise.
     - Usually use a \clss{BPF} to color the noise.
**** Typical noise generators
     - \ugen{WhiteNoise} :: Very bright, harsh noise.
     - \ugen{PinkNoise} :: Still bright, but more pleasant than white noise.
     - \ugen{BrownNoise} :: Darker sound. Named after \egls{Brownian motion}, not the color.

*** Add a noise attack to the previous example
    Based on Listing [[filterEg]].
#+name: noiseAtk
#+caption: Create a noise generator, and an envelope and filter for it.
#+begin_src {} -i
~noiseEg = { |gt, noiseDur = 0.08|
   EnvGen.kr(Env.perc(0.01, noiseDur), gt)
};
~noise = { |noiseAmp = 0.8|
   PinkNoise.ar(noiseAmp * ~noiseEg)
};
~noiseFilt = { |ffreq = 11000, rq = 0.34|
   BPF.ar(~noise.ar, ffreq, rq).dup
};
~noiseFilt.play;

p.setEvent((freq: exprand(100, 400), gt: 1,
   sustain: rrand(0.2, 0.8))).play;
#+end_src
**** You can also add an envelope to the \ugen{BPF} frequency.
     Exercise for you.
**** Settings for a BPF frequency envelope			   :noexport:
ffreq = 2300
~noiseFeg = { |gt|
   EnvGen.kr(Env.perc(0.01, 0.2), gt)
   .linexp(0, 1, 1, 4)
};

*** Note control summary: Envelopes
**** \eGls{breakpoint} \eglspl{envelope}
     - Idea: Start level, list of segments
     - Written in \clss{Env} using three arrays: \ci{levels}, \ci{times}, \ci{curve}
**** \eGls{envelope generator}
     - Renders the segments into a signal.
     - Responds to \eglspl{trigger} and \eglspl{gate}.
**** Triggers and gates: signal > 0
     - A \te{trigger} is instantaneous, when the signal becomes > 0.
     - A \te{gate} is open when > 0, closed otherwise.

*** Note control summary: Gates and Events
**** \eGlspl{gate} must be opened and closed.
     - By hand, using \cd{\textasciitilde something.set(\textbackslash gt, 1)} or \cd{0}.
     - An \clss{Event} can close the gate for you, after a given \ci{sustain} time.
       - \ci{sustain} can be given directly, or you can provide \ci{dur} and \ci{legato}.
**** Events can set many parameters at once.
     Very useful for sequencing: The start of a note can change pitch,
     amplitude, timbre controls all at once.

* Sequencing							   :noexport:
** Overview: Routines and Tasks
*** Sequencing: Basic requirements
**** For sequencing, we need:
     - /Musical/ information (pitch, timbre controls, etc.)
     - /Rhythm/ information:
       - How long to hold a note
       - How long to wait until the next note
     - Ways to do things /repeatedly/.
     - A way to /pause/ activity for some time, and resume exactly where it left off.

*** Pausing: Routine
**** In SC, a \clss{Routine} can pause and resume.
     - Routines \mth{yield} values.
     - Call \mth{next} to advance to the next \mth{yield}.
     - The routine will give back the value, and wait at exactly that point.
     - The next \mth{next} call will advance from there.
#+name: routine1
#+caption: A simple routine. Run r.next four times. How would you explain the results?
#+begin_src {} -i
r = Routine {
   1.yield;
   3.yield;
   5.yield;
};

r.next;
#+end_src

*** Repeated actions: Loops
**** Computer languages use \eglspl{loop} to do things again and again.
     - It's inconvenient to write \mth{yield} again and again.
     - We can use a \egls{loop} to write \mth{yield} once, but run it several times.
**** Loops make it easier to write bigger programs.
     - The last example yielded three values.
     - What if I want to yield 100 values?
     - Using a loop, I can write the values into a \egls{collection},
       and write the action only once.

*** Do loops
**** \mth{do} loops
     - \mth{do} runs a \clss{Function} several times.
     - We'll put the desired values into an \clss{Array}, then \mth{do} over it.
     - If \ci{func} is the function, this loop calls:
       - \cd{func.value(1, 0)}---1 is the item; 0 is its index
       - \cd{func.value(3, 1)}
       - \cd{func.value(5, 2)}
     - The array could be 100 items, but the \mth{do} function can stay the same.
#+name: do1
#+caption: A do loop.
#+begin_src {} -i
[1, 3, 5].do { |item|
   item.postln;
};
#+end_src

*** Do loop output
**** Let's look at the printed output from Listing [[do1]].
     - 1, 3 and 5 are easy enough to understand.
#+begin_src {} -i
1
3
5
[ 1, 3, 5 ]
#+end_src
**** Why is the \clss{Array} repeated at the end?
     - Every code block returns something as its result.
     - \mth{do} returns its \egls{receiver}, which is the array.
     - So: 1, 3 and 5 are printed inside the \mth{do} loop.
     - \cd{[ 1, 3, 5 ]} is returned by \mth{do} itself, and printed as
       the result of the whole code block.

*** Loops: When to stop
**** Without a \clss{Routine}, a \gls{loop} must stop somehow.
     - In Listing [[do1]], it stops at the end of the array.
     - \cd{5.do...} would run the function five times and stop.
     - \cd{inf.do...} will hang SC language. *Don't do that.*
       - \Gls{infinite loop} :: A loop with no end. Locks up the
            interpreter until you force-quit.
**** Use the /Language/ menu $\to$ /Quit interpreter/ to regain control. :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     Once the interpreter is locked, you can't run any code. Killing
     it is the only option.

*** Routines and yielding within loops
**** You may \mth{yield} inside a \mth{do} loop.
     Or any other kind of loop.
#+name: routine2_do
#+caption: A simple routine with a do loop. Run r.next four times.
#+begin_src {} -i
r = Routine {
   [1, 3, 5].do { |item|
      item.yield;
   };
};

r.next;
#+end_src
     - Same behavior as the earlier routine, but now easier to expand
       (just write a longer array).

*** Infinite loops in Routines
**** You /can/ write an \gls{infinite loop}, if it \mth{yield}s from a \clss{Routine}.
     - \mth{yield} means that the routine temporarily gives up control: No lockup.
     - The routine can produce an infinite number of values.\\
       Of course, you can never /ask for/ an infinite number!
**** Shortcut for an infinite loop: \ci{loop}.
     - *Never* use this without \mth{yield}!
#+latex: \glsadd{rrand}
#+name: routine2_do
#+caption: A simple routine with a infinite loop. Run r.next as many times as you like.
#+begin_src {} -i
r = Routine {
   loop {
      rrand(1, 10).yield;
   }
};

r.next;
#+end_src

*** Routines: Sequences of values
**** Now we know how to make sequences of values.
     - \mth{yield} values from a \clss{Routine}.
     - Any length sequence---even infinite!
     - Get values one by one using \mth{next}.
**** \clss{Routine} is a type of \clss{Stream}.
     - A \clss{Stream} responds to \mth{next} with its sequence's next value.
     - For example, a \clss{File} is a kind of stream, returning the
       file's characters one by one for \mth{next}.

** Time control: Clocks and scheduling
*** Timing
**** To play musical sequences, we need rhythm.
     Two key concepts:
     - \eGlspl{scheduler} :: An object that handles timing. Schedule
          actions to take place at a given time. The scheduler will
          "awaken" the action at the right time.
     - \eGlspl{delta} :: The amount of time between successive
                         events. Formally called "inter-onset
                         interval" or \egls{IOI} for short.

*** Scheduling
**** \eGlspl{scheduler} make something happen at a specific time in the future.
     - A scheduler is a \clss{Clock}. Most commonly used:
       - \clss{TempoClock} :: Adjustable tempo, given in beats per second (bps). Time is measured in \eglspl{beat}. Normally used for musical sequencing.
**** Scheduling methods
     - \mth{sched} :: Time is given as a number of beats later than "now."
     - \mth{schedAbs} :: Time is given as an absolute time point.

*** Scheduler usage
     Note that the order of the statements doesn't matter to the
     scheduler. The functions run at the /scheduled/ time, no matter
     which one went into the scheduler first.
#+name: sched1
#+caption: Scheduling simple actions. Run the blocks and watch the post window.
#+begin_src {} -i
(
"Right now".postln;
TempoClock.sched(1, { "one".postln });
TempoClock.sched(2, { "two".postln });
)

(
TempoClock.sched(2, { "two".postln });
"Right now".postln;
TempoClock.sched(1, { "one".postln });
)
#+end_src

*** Automatic rescheduling
**** Returning a number will /reschedule/ the action.
     - The number is a \egls{delta} time into the future.
**** *IMPORTANT:* Do not return delta $\le$ 0 accidentally!    :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     - If the return value is always $\le$ 0, it will lock up the interpreter.
     - To be safe, when scheduling a function, write \cd{nil} as the
       last expression.
#+name: resched1
#+caption: Automatic rescheduling. You'll have to use ctrl-. to stop it.
#+begin_src {} -i
(
var x = 0;
TempoClock.sched(1, {
   x = x + 1;
   x.postln;
   0.5  // this is the delta time
});
)
#+end_src

*** Rescheduling routines
**** A \clss{Routine}'s return value is \mth{yield}ed.
     - So, \mth{yield} the \gls{delta} time.
     - You can also write \mth{wait}.
**** Because it's a Routine, you can \mth{stop} it.
#+name: resched2
#+caption: Automatic rescheduling of a Routine with ``wait.''
#+begin_src {} -i
(
r = Routine {
   var x = 0;
   loop {
      x = x + 1;
      x.postln;
      0.5.wait;
   }
};

TempoClock.sched(1, r);
)

r.stop;
#+end_src

** Sequencing of notes
*** Note sequencing
**** To play notes, do it before \mth{wait}.
     - \cd{\textasciitilde out.set}: Trigger the envelope and set a new pitch.
     - Note \mth{play} here: More convenient than \cd{TempoClock.sched}.
#+name: noteseq1
#+caption: Note sequencing in a Routine.
#+begin_src {} -i
p = ProxySpace.new; p.push;

~out = { |freq = 440, t_trig = 1|
   var eg = EnvGen.kr(Env.perc(0.01, 0.5), t_trig);
   (VarSaw.ar(freq) * eg * 0.1).dup
};
~out.play;

r = Routine {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
}.play;

r.stop;
#+end_src

*** Task and Tdef
**** \clss{Task} is like \clss{Routine}, with one advantage:
     - \mth{stop}ping a \clss{Routine} stops it permanently. You can
       only \mth{reset} back to the beginning.
     - After \mth{stop}ping a \clss{Task}, you can re-\mth{play} it
       and it will continue from the middle.
**** \clss{Tdef} is global storage for Tasks.
     - \mth{play} and \mth{stop} it just like a \clss{Task} or \clss{Routine}.
     - Get a play/stop control panel from \clss{TdefAllGui}.
     - You can switch the \clss{Tdef} function at any time.
       - This is like switching a synthesis function in a \clss{NodeProxy}.
**** Storage will become important later.

*** Graphical control of Tdef
#+name: tdef1
#+caption: Using Tdef for graphical control and replacing sequencing functions on-the-fly.
#+begin_src {} -i
Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(110, 440));
      0.5.wait;
   };
});

TdefAllGui.new;

// Replace the Task function.
// You should hear the effect immediately.
Tdef(\player, {
   loop {
      ~out.set(\t_trig, 1, \freq, exprand(440, 1760));
      0.125.wait;
   };
});
#+end_src

*** Using ProxySpace-set Events
**** Remember the \clss{Event} type from "Events with ProxySpace"?
     - You can use \cd{p.setEvent((...))} in a \clss{Task} as well.
     - This is much easier than setting the controls individually on
       specific \clss{NodeProxy} objects.
#+name: tdefEvent
#+caption: Replace out.set with Events.
#+begin_src {} -i
Tdef(\player, {
   loop {
      p.setEvent((t_trig: 1, freq: exprand(110, 440))).play;
      0.5.wait;
   };
});
#+end_src
**** There is another really good reason to use Events: \eGlspl{pattern}.

*** Routine summary
**** \clss{Routine}, \clss{Task}: Pausable operations
     - Do work, then \mth{yield} something.
**** \eGlspl{loop}: Write code once, do it many times.
     - \cd{number.do}: Do it $n$ times.
     - \cd{array.do}: Do it once for every item in the array.
     - Loops should always have a way to stop. Avoid \eglspl{infinite loop}.

*** Note sequencing summary
**** Note sequencing with \clss{Routine} and \clss{Task}
     1. Calculate new musical values (pitch, rhythm etc.).
     2. Set controls within the \clss{ProxySpace}. Use \mth{setEvent} for convenience.
     3. Yield the time until the next event: \cd{time.wait}. \glsadd{wait}
**** Storage and GUI control with \clss{Tdef}
     - Also allows you to replace the function without breaking the flow.

* Introducing Patterns						   :noexport:
** Patterns and Streams
*** Patterns describe Streams
**** Streams (\clss{Routine}s) return sequences of values.
     - *Plus:* They remember what they were doing before  pausing, and resume at exactly that point.
     - *Minus:* You have to write all the calculation logic.\\
       Some sequencing operations are complicated, and frequently needed.
**** \eGlspl{pattern} "describe" sequencing behaviors that you can reuse.
     No need to rewrite the logic---just use the pattern.

*** Example: A counter
**** Compare a \clss{Routine} and a Pattern to count upward from 0.
     Why 0?
     - Most programming languages start counting with 0... get used to it.
       (E.g., the index of the first item in an \clss{Array} is 0.)
#+latex: \glsadd{Pseries}
#+name: patt1
#+caption: Two counters: a Routine and a Pattern. r and p have the same result.
#+begin_src {} -i
r = Routine {
   var x = 0;
   loop {
      x.yield;
      x = x + 1;
   };
};

p = Pseries(0, 1, inf).asStream;

// Run this several times
[r.next, p.next];
#+end_src

*** Compare the two
**** The \clss{Routine} shows a lot of detail.
     - *Good:* You can see everything that's going on.
     - *Bad:* You /have to/ see everything...
       - 6 lines for a simple counter. (Could be 4 by using \cd{inf.do}.)
       - Hard to see at a glance what all the details mean.
       - Easy to make a mistake while rewriting the counter logic.
**** The \clss{Pseries} is more compact and convenient.
     - *Good:* It shows the /purpose/, not the implementation.
     - *Bad:* Sometimes you need to know the implementation details.
**** For me, the good /far/ outweighs the bad.

*** asStream
**** \Glspl{pattern} by themselves don't calculate anything.
     - They only /specify/ what should happen.
     - To do it, you need a \gls{Stream}.
     - The \mth{asStream} method produces a stream from a pattern.
**** Like making a building:
     - The pattern is the /blueprint/.
     - The stream is the construction crew. They follow the blueprint to make the building.
     - Similarly, a SC stream follows the pattern's blueprint to produce the output values.
**** Multiple, independent streams from the same pattern.
     - Just like you can build many houses from one blueprint.

*** asStream example
#+name: asStream1
#+caption: An illustration of why we need asStream for patterns.
#+begin_src {} -i
p = Pseries(0, 1, inf);

// 'next' on a Pattern returns the pattern itself
p.next;  // "a Pseries"

q = p.asStream;  // a Routine
q.next;  // run a few times

r = p.asStream;
r.next;
#+end_src
**** \ci{q} and \ci{r}: Same pattern, independent behavior
     It doesn't matter how many values you pull from \ci{q}. \ci{r}
     will count on its own, as if \ci{q} didn't exist.

*** Basic list patterns
    - \clss{Pseq} :: Return values from an array, one by one.
    - \clss{Prand} :: Choose values randomly from an array.
    - \clss{Pxrand} :: Choose values randomly from an array, without repeating the same one twice in a row.
    - \clss{Pwrand} :: Choose values randomly from an array, with a different probability for each item.

*** Basic math generator patterns
    - \clss{Pwhite} :: Generate random numbers between low and high boundaries, with a linear distribution.
    - \clss{Pexprand} :: Generate random numbers with an exponential distribution.
    - \clss{Pseries} :: Yield an arithmetic series. Each value is the previous value plus a given step size.
    - \clss{Pgeom} :: Yield a geometric series. Each value is the previous value times a given growth factor.
**** You can get interesting results using just these.
     For more patterns, see the /Practical Guide to Patterns/ help file series.[fn:1]

** Patterns and Events
*** Patterns make Events very easily
**** An \clss{Event} is a set of named values.
     - Each value's name says how the value will be used for synthesis.
     - To use the values, call \mth{play} on the event.
**** A pattern called \clss{Pbind} is a list of /named patterns/.
     - Every \mth{next} value collects one value from each child pattern.
     - \mth{next} needs an empty \clss{Event} as a container for the new values.
#+name: pbind1
#+caption: Pbind collects child patterns' return values under given names.
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;

p.next(Event.new);
#+end_src

*** What does Pbind actually do?
#+begin_src {} -i
p = Pbind(
   \freq, Pexprand(100, 400, inf),
   \dur, Pwhite(1, 4, inf) * 0.125
).asStream;
#+end_src
    1. Associate names with patterns:
       - \ci{\textbackslash freq} will be random between 100 and 400.
       - \ci{\textbackslash dur} will be a random multiple of 0.125.
    2. Automatically make streams from those patterns.
    3. Go through the pairs /in order/:
       - Get a value from that name's stream.
       - Add the value into the input \clss{Event}.

*** DebugPbind: Watch the event get filled
**** In Listing [[pbind1]], change \clss{Pbind} to \clss{DebugPbind}.
     Now you can read exactly what's going on.
     1. Start with an empty event.
     2. \ci{\textbackslash freq} gets the value 133.25.
     3. The empty event becomes \cd{(freq: 133.25)}.
     4. \ci{\textbackslash dur} gets 0.125.
     5. The final event has both values, with the right names.
#+begin_src {} -i
Source event: (  )
stream ID: freq
Event going in: (  )
streamout: 133.24577125341
stream ID: dur
Event going in: ( 'freq': 133.24577125341 )
streamout: 0.125
Result event: ( 'dur': 0.125, 'freq': 133.24577125341 )
#+end_src

*** Events and timing
**** In a \clss{Routine}/\clss{Task}, you could \mth{wait} until the next event.
     This happens automatically in an Event Pattern.
     - Events can calculate a \gls{delta} time.
     - Then, we just need something that will play the event and wait
       the right amount of time.
**** This is \clss{EventStreamPlayer}.
     - If you call \mth{play} on a pattern, it makes an \clss{EventStreamPlayer}.
     - This plays the events and waits for the event's delta.
     - The \egls{delta} may be given directly, or calculated from \cd{\textasciitilde dur}.
       - \cd{delta = \textasciitilde dur * \textasciitilde stretch}

*** Event patterns: One-stop shopping
    Let's be clear about the implications:
**** Event patterns handle everything for sequencing
     - Parameter setting
       - New parameter values are saved in the event
     - Timing
       - Every event has a \egls{delta}

*** Compare: Pattern vs. Routine to play notes
    - We've seen a \clss{Routine} that plays notes, using \mth{set}.
    - Let's see how the same is done with a \egls{pattern}.
#+name: rVsPbind
#+caption: A Pbind, expressing the same as the earlier Routine.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \t_trig, 1,
   \freq, Pexprand(110, 440, inf),
   \dur, 0.5
);

~player.clear;
#+end_src

**** \mth{psSet}						   :noexport:
     This modifier tells the pattern's events to operate on existing
     \clsspl{NodeProxy} within the \clss{ProxySpace}.

*** Patterns: "Declarative" programming
**** \eGlspl{Routine} are \egls{imperative}-style programming.
     - Listing [[noteseq1]] said: "Do this, then that."
       - Set the trigger and the frequency.
       - Wait 0.5 beats.
**** \eGlspl{pattern} are more like \egls{declarative}-style.
     - Listing [[rVsPbind]] says:
       - I want \ci{\textbackslash freq} to be like this.
       - I want \ci{\textbackslash dur} to be like that.
       - Go do it.
**** The two examples /do/ the same thing, but write it differently.

*** What is \textbackslash psSet?
**** \ci{\textbackslash psSet} says how the pattern's events should be used.
     - \clss{Pbind} doesn't say /what to do/.\\
       It only says what information to use.
     - The \clss{Event} interprets the data and takes action, based on the \egls{event type}.
**** \ci{\textbackslash psSet} is an event type.
     - It tells the pattern's events to operate on existing \clsspl{NodeProxy} within the \clss{ProxySpace}.
     - Actually a bit more: It connects the events to the current \clss{ProxySpace}.

*** Event types
**** Common \glspl{event type}:
     - \ci{\textbackslash note} :: Play a new \clss{Synth}.
     - \ci{\textbackslash set} :: Set controls in an existing \clss{Synth}.
     - \ci{\textbackslash off} :: Release an existing \clss{Synth}.
     - \ci{\textbackslash midi} :: Send note or control data to a hardware MIDI device.
**** Event types let you change the action without changing the data.
     - You can write a \ci{\textbackslash note} pattern, and hear the notes in scsynth.
     - Or, change to the \ci{\textbackslash midi} type and hear the notes from a hardware synth.

*** Why not use \textbackslash note?
**** If \ci{\textbackslash note} is the normal \gls{event type}, why not use it?
     - We will, later.
     - We are beginning with a \egls{modular} approach, for reasons noted earlier.
     - This approach needs a different event type.

** Special event keys: Pitch and Time
*** Pitch and time in events
**** Many levels to write pitch and time.
     You can organize pitch and time in different ways, appropriate to different musical ideas.
**** "Physical" level
     Ultimately, SC uses specific event keys for the final result. These can be calculated from higher levels.
     - Time :: \ci{delta} and \ci{sustain}
     - Pitch :: \ci{freq}

*** Time model
**** Physical level: \ci{delta} and \ci{sustain}.
     - \ci{delta} :: How many beats until the next event.
     - \ci{sustain} :: How many beats before releasing the envelope.
**** Higher level: \ci{dur}, \ci{legato}, \ci{stretch}
     - Larger \ci{stretch} makes things go slower.
     - Smaller \ci{legato} makes the notes shorter.
     - \cd{delta = dur * stretch}
     - \cd{sustain = dur * stretch * legato}

*** Example: Articulation using \textbackslash legato
    First a synth.
#+name: legato1
#+caption: A modular synth, with amplitude and filter frequency envelopes for articulation.
#+begin_src {} -i
~oscil = { |freq = 440|
   Mix(Pulse.ar(
      Lag.kr(freq, 0.08) * { exprand(1/1.005, 1.005) }.dup(5),
      { rrand(0.4, 0.5) }.dup(5)
   ))
};
~ampEg = { |gt|
   EnvGen.kr(Env.adsr(0.01, 0.1, 0.6, 0.15), gt)
};
~feg = { |gt, width = 3|
   EnvGen.kr(Env.perc(0.01, 0.14, width), gt) + 1
};
~filter = { |ffreq = 1800, rq = 0.2, amp = 0.05|
   (RLPF.ar(~oscil.ar, clip(ffreq * ~feg, 20, 20000), rq)
      * amp * ~ampEg).dup
};
~filter.play;
#+end_src

*** The \textbackslash legato pattern
    Play it with a \mth{psSet} pattern.
    - Two possible \ci{\textbackslash legato} values:
      - 0.5: Half the note's duration---staccato
      - 1.05: Longer than the note's duration---legato\\
        This makes a sliding pitch, like a classic mono synth.
    - \ci{\textbackslash legato} is easier than calculating
      \ci{sustain} by hand.
#+name: legato2
#+caption: A pattern, to play the previous synth like a mono synth with fingered glides.
#+begin_src {} -i
~player = \psSet -> Pbind(
   \freq, Pwhite(36, 48, inf),
   \dur, Pwhite(1, 3, inf) * 0.125,
   \legato, Prand(#[0.5, 1.05], inf),
   \gt, 1
);

~player.clear;
#+end_src

* Glossary							   :noexport:
# #+LaTeX: \glsaddall
# http://www.latex-community.org/forum/viewtopic.php?f=5&t=16833
#+LaTeX: \renewcommand{\glossarysection}[2][]{}
** Concepts
#+LaTeX: \printglossary[type=main]
** UGens
#+LaTeX: \printglossary[type=ugen]
** Other classes
#+LaTeX: \printglossary[type=class]
** Methods
#+LaTeX: \printglossary[type=mth]
* Removed (always noexport!!) 					   :noexport:
*** Canonical explanation
#      1. \mth{add} a \clss{SynthDef} into the server.\\<all>
# 	\clss{SynthDef}: A /synthesis definition/.
#      2. Play it, using \clsspl{Synth} or \clsspl{Event}.
# 
#      - 
#      - \clsspl{SynthDef} usually include everything for one note.
#      - Bigger code blocks are harder to understand at the beginning.
*** Important idea: /Modular/ design
**** A \te{modular} approach breaks a problem into smaller pieces.
     - For synthesis, it means you can play with the different pieces independently.
     - For example, replace the \ci{\textasciitilde freq} module.
     - It changes immediately to a changing frequency.
#+name: ps2
#+caption: Modularity in ProxySpace.
#+begin_src {} -i
~freq = 110;
~width = 0.5;

~out = { VarSaw.ar(~freq, 0, ~width, 0.1).dup };
~out.play;

~width = 0.1;
~freq = { LFNoise1.kr(12).exprange(110, 220) };

~out.stop;
#+end_src

*** SuperCollider's standard synthesis model
**** The normal way to make sound in SC:
     - Write a \clss{SynthDef}: A /synthesis definition/.\\
       Compiled once and sent to the server in a binary format.
     - Play many copies of the \clss{SynthDef} using \clsspl{Synth} or \clsspl{Event}.
**** Problems for learning:
     - \clsspl{SynthDef} usually include everything for one note.
     - Bigger code blocks are harder to understand at the beginning.
     - Then people complain, "SuperCollider is too hard."

*** Syntax
**** \te{Syntax}: Rules defining "legal" expressions.
     E.g., \cd{x + y} is legal, while \cd{x y + 3} is not. You can't have \cd{x} and \cd{y} next to each other with only a space in between.
*** Usage summary
**** Write audio processing into a \clss{Function}.
     - These functions should create \eglspl{UGen}: \cd{SinOsc.ar} or \cd{.kr}.
     - \cd{aFunction.play} /adds/ new synthesis into the server.
**** \clss{ProxySpace} for plug-and-play.
     - Automatically turns functions into synthesis.
     - Reassigning an environment variable /replaces/ synthesis.
**** \te{Modular} style of writing.
     - Use /small/ synthesis functions.
     - Connect them by using the environment variable in another UGen's inputs.
**** \eglspl{UGen} (Unit Generators)				   :noexport:
     - Input signals \to UGen \to Output signal
     - Connections: UGen A's output \to UGen B's input


UGens are created by the \ci{ar} and \ci{kr} methods; here is where you write the input signals.

* Footnotes

# [fn:1] Events with ProxySpace: [[Events with ProxySpace]].

[fn:1] Online copy at [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_01_Introduction.html][doc.sccode.org]].

[fn:2] "A Short History of Computer Music." Author
unattributed. http://artsites.ucsc.edu/EMS/music/equipment/computers/history/history.html. Accessed
24 January 2014.

