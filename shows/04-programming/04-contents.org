#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Programming concepts for composition
** Composition: Data structures
*** Data storage: Collections
**** Data storage is key.
     - SC has a number of \egls{collection} classes.
     - The different collection types save information differently.
     - Each one supports different ways of working.
**** Choosing the right collection makes the task easier.

*** Ordered vs. unordered collections
**** We've seen two collection types already:
     - \clss{Array} :: Items are saved /in order/ and accessed by /number/.
     - \clss{Event} :: Order doesn't matter. Items are accessed by /name/.
**** These reflect the main division among collections:
     - \Gls{ordered} :: You can count on getting items out in the same order you put them in. Good for sequences of information.
     - Unordered :: Very fast to get information by name or check whether an item is already in the collection. But, the order is lost.

*** Note on order					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Wouldn't it make sense to have the order, always?
Actually, no. Certain tasks are faster if the computer can decide the
order of information. In particular, looking up an item by name, and
testing "membership"---seeing if the collection contains a given
item---benefit from the computer choosing the order.

Suppose you have an \clss{Array} of arbitrary names. To find out if
the array contains a particular name, you have to scan all the array
items. If you find the given name, you can stop early, but if you
don't find it---the worst case---you have to touch every array
element. If the array has several thousand items, this could be slow.

SC's unordered collections use a technique called /hash lookup/ to
speed up the process. It's beyond the scope of this workshop to
explain how hash lookup works. But, it means that SC needs to scan
only part of the unordered storage, which is more efficient.

So:
- Use ordered collections when you need to know the sequence.
- Use unordered collections when you need to know that something is
  there, but the order doesn't matter.

*** Doing things with collections
**** What can you do with collections?
     And why would you want to do them?
     - /Transforming/ data is as important as collecting it in the first place.
     - This is how computers can /generate/ musical details.

*** Example: Phrase separation
**** For example: Split a list of pitches into phrases.
     - Suppose, to make it easy, that phrases go up.
     - Split at every downward jump larger than, oh, a third.\\
       A third, in scale degrees, is 2. /Why?/ \pause
     - How do you get a number for the interval between \ci{a} and \ci{b}?\\ \pause
       \cd{b - a} \pause
     - What's the condition for a downward jump more than a third?\\ \pause
       \cd{(b - a) < -2}

*** Array magic for separation
**** \clss{Array} already has a method for this: \mth{separate}.
     - Give it a \clss{Function} for the condition.
     - The function gets two items as \glspl{argument}.\\
       The items are next to each other in the array.
     - The function returns \ci{true} if a split should happen between those items.
#+name: coll1
#+caption: A sequence of rising phrases, split by the separate method.
#+begin_src {SuperCollider} -i
x = [0, 2, 4, 6, 7, 1, 2, 3, 4, 5, 2,
   3, 5, 6, 7, 8, 10, 3, 5, 6, 8,
   9, 10, 4, 5, 6, 7, 8, 9
];

y = x.separate { |a, b| b - a < -2 };
#+end_src

*** So what?
**** What is that good for?
     - Before, we could:
       - Play the notes in the original order (\clss{Pseq});
       - Or play them in random order, breaking phrases:\\
	 \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}.
     - Now, we can play the /phrases/ in any order, but keep each phrase intact.
**** The point:
     /Doing something to the array created a new \textbf{musical} possibility./

*** Choosing the phrases at random
     Note \ci{z}: We can make a \clss{Pseq} for each phrase in advance.
#+name: coll2
#+caption: Play the phrases in random order. Pxrand makes sure the same phrase will not play twice in a row.
#+begin_src {SuperCollider} -i
z = y.collect { |array| Pseq(array, 1) };

~player = Pbind(
   \degree, Pxrand(z, inf),
   \dur, 0.15
);
~player.play;

~player.clear;
#+end_src

*** Things you can do with any collection
**** All collections can do these basic things:
     - \mth{size} :: How many items?
     - \mth{add} :: Add a new item (if ordered, to the end).
     - \mth{remove} :: Remove an item.
     - \mth{removeAll} :: Remove all the given items.
     - \mth{includes} :: Membership test (\ci{true} if the collection has the exact \egls{identical} item).
     - \mth{includesEqual} :: Slightly relaxed membership test (OK if the matching item is \egls{equivalent}, not identical).

*** Note on identity					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the difference between \egls{identical} vs. \egls{equivalent}, and why does it matter?
\eGls{identical} refers to the same exact object, while
\egls{equivalent} refers to separate objects that happen to have the
same value, or the same contents.

It might seem strange to speak of objects being "identical." If there
can be only one object with a particular identity, how could you
compare it to something else? Wouldn't the comparison always end up
\ci{false}?

Checking identity is meaningful because you can have several
/references/ to the same object: one object, held in several variables
or several collection items. Here, we put an array into \ci{x}, and
then assign the same array into \ci{y}. The \ci{===} test shows that
they are identical. They are not /separate/ arrays with the same
contents. Both variables refer to one and the same array. Because both
variables point to the same place, a change to \ci{x} will also appear
in \ci{y}---because, as far as the array is concerned, it doesn't
matter whether you call it \ci{x} or \ci{y} or \ci{stupidArray}. Its
contents have changed, and /any/ variable referring to that array will
see the change.

#+begin_src {SuperCollider} -i
x = [0, 1, 2];
y = x;

y === x;  // identical

x.put(1, 10);
y;  // prints: [ 0, 10, 2 ]
#+end_src

This is, in fact, a common mistake when creating arrays of arrays
(that is, rows and columns). In this example, all three "rows" are
identical arrays---so, you can't modify any row's contents without
also changing /every/ row.

#+begin_src {SuperCollider} -i
x = Array.fill(3, [0, 1, 2]);

x[0] === x[1];  // identical
#+end_src

The solution is to use a function with \cd{Array.fill}. /Get in the
habit \textbf{now} of using functions here!/ Forgetting the function
@@latex:\cd{\{ \}}@@ is one of /the/ most common mistakes.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x[0] === x[1];  // NOT identical
x[0] == x[1];  // equivalent
#+end_src

Why not simplify, and just test equivalence for everything? The reason
is that checking identity is faster. Speed is important when looking
up items by name in an \clss{Event}, \clss{IdentityDictionary} or
\clss{ProxySpace}, because /many/ comparisons are needed.

For membership testing:

- If the items are \clsspl{Symbol} or \cd{Integers}, you can use
  \mth{includes}. Also, \clss{IdentitySet} is faster for lookup, and
  these types are valid keys in an \clss{IdentityDictionary}.
- Any other types within a collection---\clss{String}, \cd{Float},
  other collections---should check membership by
  \mth{includesEqual}. Use \clss{Set} or \clss{Dictionary}.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x.includes([0, 1, 2]);  // FALSE b/c not identical
x.includesEqual([0, 1, 2]);  // TRUE
#+end_src

*** Looping operations on collections
     All these take a function with arguments \cd{|item, index|}.
     - \mth{do} :: Do something to each item; don't keep results.
     - \mth{collect} :: Do something to each item; keep the results in a new collection.
     - \mth{select} :: Make a new collection, with the items that satisfy the condition in the function.
     - \mth{reject} :: Like \mth{select}, but keeps the items that fail the condition.
     - \mth{count} :: How many items satisfy a condition?
     - \mth{sum} :: Add up the items; the optional function can calculate new values.

*** Collection looping examples
**** Can you imagine musical uses for these?
     Try them one by one, and try to explain the results.
#+name: coll2
#+caption: Examples of looping operations on collections.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
(
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
)
x.select { |item| item > 4 };
x.reject { |item| item > 4 };
x.maxItem;

x = ["An", "array", "of", "strings"];
x.count { |item| item.size > 3 };
x.sum { |item| item.size };
x.maxItem { |item| item.size };
#+end_src

*** Musical uses						   :noexport:

*** Things you can do with ordered collections
**** \Gls{ordered} collections can address items by number.
     - \mth{at} :: Get the item at a given number. Shortcut: \cd{array[1]} $\to$ \cd{array.at(1)}.
     - \mth{put} :: Put a new item into the numbered slot. Shortcut: \cd{array[1] = 5} $\to$ \cd{array.put(1, 5)}.
     - \mth{removeAt} :: Remove the item at the given index.
     - \mth{insert} :: Insert a new item at the index, pushing the other items to the right.
     - \mth{++} :: Join two arrays into one.
     - \mth{pairsDo} :: Like \mth{do}, but takes the items in groups of two.
     - \mth{doAdjacentPairs} :: See the example.
     - \mth{sort} :: Arrange the items in ascending or descending order. *In-place:* modifies the array.

*** Ordered collection examples
#+name: coll3
#+caption: Examples of useful array operations.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
x[3]
x[3] = 22;
x.removeAt(3); x
x = x.insert(3, 22);
x ++ [55, 48, 60];
x.pairsDo { |a, b| "%: %\n".postf(a, b) };
(
x.doAdjacentPairs { |a, b|
   "% - % = %\n".postf(b, a, b - a)
};
)

x.sort;  // restores 0 .. 9 order

// sort in descending order:
// literally, so that an earlier item is bigger
x.sort { |a, b| a > b };
#+end_src

*** Unordered collections: Dictionaries
**** \clsspl{Dictionary} store \clsspl{Association}.
     - Association: \cd{key -> value}.
       - The \egls{key} is the identifier, used to access the items.
       - Very often, the key is a name, written as a \clss{Symbol}: \cd{\textbackslash name}.
**** Array-indexing methods work with dictionaries.
     The \mth{at}, \mth{put} and \mth{removeAt} methods take the
     \egls{key} as the argument, instead of a number.

*** Dictionary types
    - \clss{Dictionary} :: Looks up \egls{equivalent} keys. \clsspl{String} and \clsspl{Array} are valid keys.
    - \clss{IdentityDictionary} :: Looks up \egls{identical} keys. \clsspl{Symbol} and \ci{Integers} are valid keys.
    - \clss{Environment} :: The current environment provides storage for \ci{\textasciitilde environmentVars}.
    - \clss{Event} :: An \clss{Environment} that can be \mth{play}ed.
**** You'll probably use \clss{Event} most often.
     Nice shortcut syntax: \cd{(key: value, key1: value1...)}.

*** Dictionary methods
**** Key-value storage calls for some other methods.
     - \mth{keys} :: All the unique keys in this dictionary.
     - \mth{values} :: An array of the values, without keys.
     - \mth{keysValuesDo} :: Like \mth{do}, but the function arguments are \cd{|key, value, counter|}.
**** Minor difference in filtering methods.
     - \mth{collect}, \mth{select}, \mth{reject}.
     - Arguments passed to the function are \cd{|value, key|}.
     - Why the value first?\\
       To be consistent. The value comes first in all the other \mth{collect} variants.

*** Dictionary examples

    Note the use of \clss{Pdict}, to embed patterns by name.
#+name: coll4
#+caption: A useful Dictionary trick: Naming subpatterns for sequencing.
#+begin_src {SuperCollider} -i
d = (
   mel1: [0, 7, 3, 4, 6, 7],
   mel2: [9, 7, 6, 4, 3],
   mel3: [3.9, 4, 6, 3, 2]
);

// preserves the keys
e = d.collect { |array| Pseq(array, 1) };

e.keysValuesDo { |key, value| [key, value].postcs }; ""

q = Pbind(
   \degree, Pdict(e, Pxrand([\mel1, \mel2, \mel3], inf)),
   \dur, Pwhite(1, 3, inf) * 0.15,
   \scale, Scale.aeolian,
   \root, 11, \octave, 3
).play;

q.stop;
#+end_src
*** Unordered collections: Sets
**** Sets may not contain any duplicated items.
     - \clss{Set}: No \egls{equivalent} items.
     - \clss{IdentitySet}: No \egls{identical} items.
**** \clss{Set} and \clss{IdentitySet} are good for:
     - Checking membership: Does the set have this item?\\
       \clsspl{Set} can search quickly.
     - Avoiding duplicates:
       - What are the unique \glspl{pitch class} in a group of notes?
       - What items are in common between two sets?
       - What items exist in only one of the two sets?

*** Unordered collections: Set methods
    \mth{add}, \mth{remove}, \mth{do} etc. work as in other collections.
    - \mth{sect} :: Intersection (common items: items in setA /and/ setB). Shortcut: \cd{setA \& setB}.
    - \mth{union} :: Union: items in setA /or/ setB, or both. Shortcut: \cd{setA | setB}.
    - \mth{difference} :: Items in setA that are /not/ in setB. Shortcut: \cd{setA - setB}.
    - \mth{symmetricDifference} :: Items in only one of the two, but not both. Shortcut: \cd{setA -- setB}.

*** Unordered collections: Set examples
#+name: coll5
#+caption: Examples of useful Set operations.
#+begin_src {SuperCollider} -i
x = [59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68];

// unique pitch classes
y = IdentitySet.new;  // OK b/c Integers
x.do { |item| y.add(item % 12) };
y;  // 5 items only: duplicates ignored
z = IdentitySet[11, 1, 2, 4, 6, 7, 9];  // b minor

// which notes in y belong to a b minor scale?
y & z;

// which notes in y are *not* in b minor?
y - z;

// which notes are in either y or z, not both?
y -- z;
#+end_src

*** Summary: Collections
**** Any collection:
     - Loop: \mth{do}, \mth{collect}.
     - Filter: \mth{select}, \mth{reject}.
**** Store and recall items /in order/ (\clss{Array}).
     - Split (\mth{separate}, \mth{clump}) and join (\mth{++}) items.
     - \mth{sort} in order, and randomize the order (\mth{scramble}).
**** Store and recall items /by name/ (\clss{Dictionary}).
     - Looping: \mth{keysValuesDo}.

*** Collections: Musical memory
**** Composers and improvisers /manipulate/ musical material.
     - Create variations on a basic idea.
     - Cut material support, rearrange, splice, transpose, otherwise alter.
**** Collections let you store musical ideas and change them.
     - One week is not enough to go very far.
     - Keep these classes in mind. You /will/ need them later.

** Composition: Control structures
*** Control structures: Branching and Looping
**** Running code straight through is boring and limiting.
     Two things are very important in computing:
     - Making decisions: Which one of several things to do?\\
       This is \egls{branching}.
     - Doing the same thing many times, with different information.\\
       This is \egls{looping}.

*** Branching
**** \Gls{branching}'s basic question:
     I have two or more branches I can take. Which one?
**** Branching structures in SuperCollider:
     - \mth{if} :: *If* (condition), *then* do this; *else* do that.
     - \mth{case} :: Check several conditions; do the action for the first "true."
     - \mth{switch} :: Look up an action by value.

*** Boolean values
**** Branching depends on \egls{Boolean} expressions.
     - A \egls{Boolean} is either true or false, no middle ground.
     - Boolean expressions are often called "conditions":\\
       \cd{x < 10} is a condition: Either \ci{x} is, or it isn't.
     - Most conditions are based on comparison operators:
       - \ci{==}, \ci{===}: Are two items \egls{equivalent} or \egls{identical}?\\
	 \ci{!=} and \ci{!==}: Not equal, or not identical.
       - \ci{<}, \ci{<=}, \ci{>}, \ci{>=}: Less than or greater than?
       - Also useful: \mth{inclusivelyBetween}\cd{(lo, hi)}.

*** Basic branching: If
**** \mth{if} is the basic decision maker.
     - Remember it this way: *If -- then -- else*.
     - Can you predict what the \cd{10.rand} example will do?
#+name: if1
#+caption: Outline of the ``if'' structure.
#+begin_src {SuperCollider} -i
if(condition) {
   (then... true branch)
} {
   (else... false branch)
};

x = 10.rand;
if(x < 5) {
   "low random number: %\n".postf(x);  // then
} {
   "high random number: %\n".postf(x);  // else
};
#+end_src

*** Note on branch returns				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
You might have noticed that the \cd{10.rand} example displays the
string twice. Why?

The \ci{postf} method formats a string (substituting \ci{x} where the
\ci{\%} appears) and then prints it. This accounts for the first
display.

The second display is because SC always prints the result of the last
expression in the code block that was just executed. The last
expression is the \mth{if}. So, if the string printed again, then the
\mth{if} statement itself must have returned the string as a result
value.

This is a big difference between SuperCollider and languages like C or
Java. In C, \mth{if} is a "statement," and statements have no
value. The statement says what to do, but when the statement finishes,
its only effect is that it did something to something else.

By contrast, in SC, /everything/ is an expression. /Every/ statement
produces a return value. You can choose to ignore the return value,
but the value will be returned anyway. For example, look back at the
\mth{collect} example in Listing [[coll2]].

#+begin_src {SuperCollider} -i
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
#+end_src

\cd{item * 10} is not really an /action/---it doesn't change a
variable or tell an object to do something---but it does produce a new
value. If the incoming item is an odd number, the \mth{if} says to
multiply that item by 10 /and return the result/. This returned result
goes back to \mth{collect}, which puts the new value into the result
array.

This is a very powerful idea, and it may take some time to
understand. Put it in the back of your mind for now, and come back to
it later when you need it.

*** What to do with "if"?
**** Just about anything...
     - Play a note on 75\% of 16th-notes in a bar.\\<all>
       *If* a 75% coin toss is true, keep the event; else make it a rest.
     - Avoid reloading something that's already loaded.\\<all>
       *If* the variable is nil, load it; else do nothing.\\
       (Note: You can just leave out the /else/ branch.)
     - On/off buttons.\\<all>
       *If* the user turned it on, do something; else, do something different.

*** "If" examples
#+name: if2
#+caption: Practical uses of "if."
#+begin_src {SuperCollider} -i
a = Pbind(  // canonical style
   \degree, Pn(Pseries(0, 1, 8), inf),
   \dur, 0.125.asPattern.collect { |dur|
      if(0.75.coin) { dur } { Rest(dur) }
   }
).play;

a.stop;

if(b.isNil) { b = Buffer.alloc(s, 44100*5, 1) };

o = Button(nil, Rect(600, 100, 100, 20))
.states_([["off"], ["on"]])
.action_({ |button|
   if(button.value == 1) {
      "on".postln;
   } {
      "off".postln;
   };
}).front;
#+end_src

*** Note: New stuff 					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** New elements
     - \mth{asPattern}: We need \ci{0.125} to act like a pattern, so
       that \mth{collect}'s function will run once for every
       event. Here, it's an easier-to-read alternative to
       \cd{Pn(0.125, inf)}.\glsadd{Pn}
     - \clss{Button}: Makes a clickable GUI button. We'll cover GUI basics later. For now:
       - \ci{nil} means the button has no parent window. It will make
         its own window automatically.
       - \clss{Rect} gives the position (600 and 100 are at the left
         and top coordinates) and size (100 and 20 are the width and
         height).
       - The button has two states, labeled as shown. Each state has
         its own sub-array, so that you can assign different colors.
       - \mth{front} brings the window to the front, so you can see it.

*** Compound conditions 
**** Often, you need to put several conditions together.
     E.g., if x is odd, and more than 100.
**** Logical operators:
     - \ci{and} :: True, if /both/ are true.
     - \ci{or} :: True, if /either/ is true, or both.
     - \ci{xor} :: True, if one or the other is true, but not both.
**** dummy						    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     The above would be written: \cd{x.odd and: (x > 100)}.
     - You must put \ci{()} around the second condition.

*** Short-circuiting conditions
**** Sometimes you don't have to test all the conditions.
     \cd{x.odd and: (x > 100)}:
     - If \ci{x} is even, the first condition is false.
     - False \ci{and} anything is false: so \ci{x > 100} doesn't matter!
**** Good to get in the habit of writing conditions this way:
     @@latex:\cd{x.odd and: \{ x > 100 \}}@@.
     - Writing the second condition as a function means SC can skip it if possible.
     - This can improve speed by avoiding wasted expressions.

*** Short-circuiting and type safety
**** Some conditions are valid only for some types of objects.
     - Short-circuited conditions make it easy:\\
       @@latex:\cd{if(typecheck and: \{ condition \}) ...}@@
     - SC will try the condition the only if the type check is OK.
     - Often the result of an expression is \ci{nil} (empty result).\\
       Handle it this way:\\
       @@latex:\cd{if(object.notNil and: \{ condition \}) ...}@@

*** Other branching methods
    \mth{case} and \mth{switch} make some kinds of branching easier.\\
    We won't cover them in detail here. Look them up the help system for more.
    - Case: [[http://doc.sccode.org/Classes/Function.html\#-case][Web link]]
    - Switch: [[http://doc.sccode.org/Classes/Object.html\#-switch][Web link]]
    - Control structures in general: [[http://doc.sccode.org/Reference/Control-Structures.html][Web link]]

*** Looping
**** We have seen loops over collections.
     \mth{do}, \mth{keysValuesDo}, \mth{collect}, \mth{select}, \mth{reject}.
**** Other useful loops:
     - \ci{number.do}: Counts 0 to (number--1).
     - \ci{Array.fill}: Counts 0 to (number--1), adds function results to a new array.
     - \cd{(start .. end).do}: Counts \ci{start} to \ci{end}.\\
       Shortcut for \mth{for}: @@latex:\cd{for(start, end) \{ body \}}@@.
     - \cd{(start, second .. end).do}: Counts \ci{start} to \ci{end}, with a skip of \cd{second - start}.\\
       Shortcut for \mth{forSeries}: @@latex:\cd{forSeries(start, second, end) \{ body \}}@@.

