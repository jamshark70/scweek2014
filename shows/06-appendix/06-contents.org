#+startup: beamer

* Test
** Test
*** Test

* Modal synthesis
** Ringing filters
*** What's a \egls{ringing filter}?
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

    Let's compare a bandpass filter (\ugen{BPF}) against a ringing filter (\ugen{Ringz}).
    - \cd{10.dbamp} in the filter: \ugen{BPF} is a quiet UGen, needs to be boosted.
#+name: ringz1a
#+caption: Noise into a bandpass filter: sounds like filtered noise.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~exciter = { |freq = 440, amp = 1|
   PinkNoise.ar(amp)
   * EnvGen.kr(Env.perc(0.01, 0.3), Impulse.kr(2))
};
~filter = { |ffreq = 2000, rq = 0.1|
   BPF.ar(~exciter.ar, ffreq, rq, 10.dbamp).dup
};
~filter.play;
~filter.addSpec(\ffreq, \freq).addSpec(\rq, [1, 0.05, \exp]);
p.gui;
)
#+end_src

*** Substitute the ringing filter
    - *Note:* \ugen{Ringz} can be /very/ loud!\\
      0.01 = --40 dB.
    - Also, we control the \gls{ring time}, not \ci{rq}.
**** Switch back and forth between \ugen{BPF} and \ugen{Ringz}.
#+name: ringz1b
#+caption: Noise into a ringing filter: pitch is much stronger.
#+begin_src {SuperCollider} -i
~filter.addSpec(\ringtime, [0.01, 2, \exp]);
~filter = { |ffreq = 2000, ringtime = 0.5|
   Ringz.ar(~exciter.ar, ffreq, ringtime, 0.01).dup
};
#+end_src

*** Impulse response
**** What if we use impulses?
#+name: ringz1c
#+caption: Impulse into a ringing filter.
#+begin_src {SuperCollider} -i
~exciter = { Impulse.ar(2) };
#+end_src
     - Suddenly much quieter. (Change 0.01 to 0.1 in the filter.)
     - Now you're hearing the filter's \egls{impulse response}.
     - What does it sound like?\\
       Use the oscilloscope (/Language/ menu) for more detail.

*** Ringz impulse response, plotted
**** Plot code							   :noexport:
{ Ringz.ar(Impulse.ar(0.025.reciprocal), 440, 0.05) }.plot(0.05, minval: -1.2, maxval: 1.2);
**** This is a \ugen{Ringz}'s response to two impulses.
     - Note especially the spike when the second impulse comes in.
     - This will make a slight click in the output---not clean.
#+begin_center
#+attr_latex: :height 1.5in
[[../06-appendix/img/ringz-impulse-responses.png]]
#+end_center

*** Modal synthesis, in a nutshell
**** Simplest explanation of \egls{modal synthesis}:
     - \Gls{exciter} :: A short burst of noise, like a hammer striking a bell.
     - Filter :: A ringing filter simulates one vibrational \egls{mode}.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.6
     :END:
***** Vibrational modes
      - When you hit an object---``excite'' it---it starts to vibrate.
      - It vibrates in many different ways at the same time.
      - Each one of these consistent patterns is a \egls{mode}.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.35
     :END:
#+begin_center
#+name: modejpg
#+caption: Vibrational modes in a cup of coffee. Image credit: Natural Philo, http://en.wikipedia.org/wiki/File:A_cup_of_black_coffee_vibrating_in_normal_modes.jpeg.
#+attr_latex: :height 1in
[[../06-appendix/img/A_cup_of_black_coffee_vibrating_in_normal_modes.jpeg]]
#+end_center

** Banks of ringing filters
*** More modes: Klank
**** \ugen{Klank} is an easy way to get lots of ringing filters.
     The example shows how to write it.
     - Wrap the filter parameters inside @@latex:\textcolor{codecolor}{$^{\backprime}$}\cd{[...]}@@.\\
       The backtick @@latex:\textcolor{codecolor}{$^{\backprime}$}@@ is important!
     - This should contain three arrays:
       - Filter frequencies;
       - Amplitudes;
       - Ring times.
#+name: klank1
#+caption: Klank gives you several vibrating modes. Integer multiples sound like a synthetic oscillator. Randomized frequencies produce various percussive sounds.
#+begin_src {SuperCollider} -i
~filter = {
   Klank.ar(`[
      [220, 440, 660, 880, 1100],
      [0.1, 0.1, 0.1, 0.1, 0.1],
      Array.fill(5, { rrand(0.25, 0.75) })
   ], ~exciter.ar).dup
};
#+end_src

*** Array.fill
**** Note \cd{Array.fill(size, item)}.\glsadd{fill}\glsadd{Array}
     - In the example, it makes five random ring times.
     - For random numbers, the expression should be in a function (curly braces).
**** Exercise for you:
     - Write \cd{Array.fill} expressions for frequency and amplitude.
     - Experiment with different random boundaries.
     - (Remember, frequency is exponential: \mth{exprand}.)

*** Exciters
**** The \gls{exciter} is usually a noise generator, with a short envelope.
     - Remember three noise types: \ugen{WhiteNoise}, \ugen{PinkNoise}, \ugen{BrownNoise}.
     - \cd{Env.perc}\glsadd{perc} is a good envelope choice.
**** Exercises for you:
    - Rewrite \cd{\textasciitilde exciter} to use a noise generator.
    - Multiply by a percussive envelope.
    - Also add a trigger \ci{t\textunderscore trig} argument.
    - Drive the trigger argument with a \ci{\textbackslash psSet} pattern.
**** These exercises prepare for the next topic.

*** Klank, Ringz, DynKlank
**** \ugen{Klank}'s filter parameters are the same as in \ugen{Ringz}.
     - \ugen{Klank} sounds like one \ugen{Ringz} per array item, mixed.
     - *Good:* \ugen{Klank} is more efficient.
     - *Bad:* You can't change the filters after starting the Synth.\\
       This is a big problem for this style of modular synthesis.
**** \ugen{DynKlank} takes the same kind of input.
     - But it makes lots of \ugen{Ringz} filters.
     - So you /can/ change the filter parameters (but, higher CPU cost).

*** DynKlank to play pitches
**** Both \ugen{Klank} and \ugen{DynKlank} have /scaling/ inputs.
     - The actual filter frequencies are \cd{freqArray * freqscale}.
     - So, to play a specific pitch:
       - Write the frequency array so that 1.0 is the fundamental pitch.
       - Plug the desired frequency into \ci{freqscale}.
     - (Read the help file for details on \ci{freqoffset} and \ci{decayscale}.)
**** In modular style, you have to use \ugen{DynKlank} for this.
     Otherwise, the pitch can't change.

*** Pitched DynKlank example
#+name: dkpitch1
#+caption: Using DynKlank in modular style to play pitches by modal synthesis.
#+begin_src {SuperCollider} -i
~filter = { |freq = 440|
   DynKlank.ar(`[
      Array.fill(5, { |i| (i+1) * rrand(0.97, 1.03) }),
      Array.fill(5, 0.1),
      Array.fill(5, { rrand(0.25, 0.75) })
   ], ~oscil.ar, freqscale: freq).dup
};
#+end_src
**** Exercise for you:
     - Change the pattern to play other pitches.\\
       You can use \ci{degree}, \ci{midinote} or \ci{freq}.

*** Graphical editor for ringing filters
**** SC includes a graphical way to play with \ugen{Ringz} filters.
     - It's "hidden" in the code examples directory.
     - When finished, it will print an Array to use directly in \ugen{Klank}.
     - This code snippet will access the editor, in any OS.
       - \clss{Platform} contains many file paths that are different depending on the OS.
       - \mth{resourceDir} points to examples and sounds, among other things.
#+name: klankEditor
#+caption: Open, or run, the GUI example of editing up to 10 Ringz filters.
#+begin_src {SuperCollider} -i :var extract='t
(Platform.resourceDir +/+
   "examples/GUI examples/analog-drum-tuner.scd").openDocument;

(Platform.resourceDir +/+
   "examples/GUI examples/analog-drum-tuner.scd").load;
#+end_src

** Formant synthesis
*** What are formants?
**** \eGlspl{formant} are the way sounds resonate in the vocal cavity.
     - The formants change for different vowels and voice types.
**** FOF (/fonctions d'ondes formantiques/) (X. Rodet, 1979/1984).
     - One FOF is a decaying sine wave, triggered by impulses at the desired pitch.
     - Decaying sine wave... isn't that the \ugen{Ringz} impulse response?
**** We can use ringing filters to do this!
     But, the impulse response also had a nasty click in it.

*** Controlling the "click"
**** What if we subtract a shorter \ugen{Ringz} from a longer one?
#+begin_center
#+attr_latex: :height 1.8in
[[../06-appendix/img/ringz-minus-ringz.png]]
#+end_center
**** This changes the impulse response's envelope.
     - Smoother at the beginning.

*** Formant synthesis
**** \ugen{Formlet} does this for you.
     - It's the same as @@latex:\cd{Ringz.ar(in, freq, decay) - Ringz.ar(in, freq, attack)}@@.
**** This is one way to do \egls{formant} synthesis.
     - The \gls{exciter} gives the main pitch.
     - The \ugen{Formlet} resonates at another frequency.
     - In the GUI, move \ci{ringtime} down to 0.02 or 0.03.
     - Then move \ci{ffreq} around in the midrange.
#+name: fmlet1
#+caption: Create one formant around a train of impulses, using Formlet.
#+begin_src {SuperCollider} -i
~filter = { |ffreq = 2000, ringtime = 0.5|
   Formlet.ar(~exciter.ar, ffreq, ringtime * 0.1, ringtime, 0.1).dup
};

~exciter = { |freq = 220| Impulse.ar(freq) };
#+end_src

*** Producing vowels
**** Real vowels have two or three main formants.
     Plus a couple of others that are weaker.
**** So, we need a bank of \ugen{Formlet}s.
     - \ugen{Formlet} = \cd{Ringz(decay) - Ringz(attack)}.
     - \ugen{Klank} or \ugen{DynKlank} = bank of \ugen{Ringz}.
     - So, a bank of \ugen{Formlet}s = \cd{Klank(decay) - Klank(attack)}!

*** Filter parameters for specific vowels
**** Where do you get the numbers for the filters?
     \clss{FormantTable}, from /sc3-plugins/, can help.
     - A \clss{Dictionary} of filter settings, organized by:
       - Voice type (soprano, alto, tenor, bass, countertenor);
       - Vowel (A, E, I, O, U).
     - \mth{keys}: List all the vowel identifiers.
     - \mth{at}: Get filter parameters, suitable for use with \ci{BBandPass}.
     - \mth{atKlank}: Filter parameters, for \ugen{Ringz}, \ugen{Klank} or \ugen{Formlet}.
     - We will use \mth{atKlank}.

*** Example: FormantTable and Klank
    - The result of \mth{atKlank} is used directly where the filter array should appear.
    - One \ugen{Klank} minus another (like \ugen{Formlet}).
      - The second one uses \ci{decayscale} to make the attack shorter than the real ring time.
**** Turn down the volume before running this!
     It may be very loud.
#+name: formants1
#+caption: Formant synthesis with FormantTable and Klank
#+begin_src {SuperCollider} -i
~filter = {
   var in = ~exciter.ar,
   formant = FormantTable.atKlank(\tenorU);
   (Klank.ar(`formant, in)
      - Klank.ar(`formant, in, decayscale: 0.1)).dup
};
#+end_src

*** Exercises for you
**** On your own:
     - With \ugen{Impulse} as the exciter, it could be too buzzy.
       - Add a lowpass filter to the \ci{\textasciitilde filter} module.
       - Also add a \ci{ffreq} argument, with spec, so that you can find a good cutoff frequency in the GUI.
     - Try other voice types and vowels.
     - Try detuning the exciter.

*** Changing vowels by arguments: Filter
**** Up to now, we can't slide from one vowel to another.
     - \ugen{Klank} can't change parameters!
     - Change to another filter.\\
       \ugen{DynKlank} works, but each one makes five \ugen{Ringz}.\\
       10 filters for five formants!
     - We could get the same with just five \ugen{Formlet}s.
#+begin_src {SuperCollider} -i
sig = DynKlank.ar(`formant, in) -
   DynKlank.ar(`formant, in, decayscale: 0.1);

// or
Mix(Formlet.ar(in, formant[0],
   formant[2] * 0.1, formant[2], formant[1]));
#+end_src

*** Notes (filter)					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's \cd{formant[0]}?
It happens that \mth{atKlank} returns exactly the array that
\ugen{Klank} expects: @@latex:\cd{[[frequencies], [amplitudes], [ring
times]]}@@. \cd{formant[0]} accesses the first item: the array of
frequencies. When we put this into the frequency input of
\ugen{Formlet}, we have multichannel expansion. The five frequencies,
five amplitudes and five ring times cause \ugen{Formlet} to expand
into an array of five \ugen{Formlet}s. Then, all we have to do is
\ugen{Mix} them together.

*** Changing vowels by arguments 2: Arrayed controls
**** We also need a way to send arrays to an argument.
     - Regular arguments have some limitations for this.
     - Remember that arguments turn into \eglspl{control input}.
     - We can make control inputs explicitly, using \ugen{NamedControl}.
     - An array for the default value makes an \egls{arrayed control}.
#+begin_src {SuperCollider} -i
formant = NamedControl.kr(\formant,
   FormantTable.atKlank(\tenorE).flat);
#+end_src
**** This is often used to send envelope definitions.

*** Arrayed control example
    Not related to formant synthesis; just to show \glspl{arrayed control}.
    - Also note the \ci{\textbackslash dur} pattern.\\
      Can you figure out why it makes the rhythm you hear?
#+name: arrayctl1
#+caption: An arrayed control, to make three pitches from one oscillator module. Assumes you are already in a ProxySpace.
#+begin_src {SuperCollider} -i :var extract='t
~arrayarg = { |amp = 0.1|
   var freq = NamedControl.kr(\freq, 55 * [4, 5, 6]);
   (Mix(SinOsc.ar(freq)) * amp).dup
};
~arrayarg.play;

~arrayarg.set(\freq, 82.5 * [4, 5, 6]);

~player = \psSet -> Pbind(
   \degree, Pwhite(-7, 7, inf) + [0, 2, 4],
   \dur, Pseq([
      Pn(0.15, { rrand(3, 8) }),
      0.15 * Pwhite(3, 6, 1)
   ], inf)
);

~player.clear; ~arrayarg.clear;
#+end_src

*** Changing vowels by arguments 3: Array geometry
**** Small complication: Array dimensions
     - \clss{FormantTable} gives a two-dimensional array (5x3).
     - The filters expect a two-dimensional array (5x3).
     - The \ugen{NamedControl} must be one-dimensional!
**** Solution:
     - One-dimensional array for messaging: use \mth{flat}.
     - Two dimensions in the synth function: use \mth{clump}.
       - \mth{clump}'s argument is a number, saying how big each row should be.
       - \clss{FormantTable} gives five filters, so \cd{clump(5)}.
#+name: flat1
#+caption: Try these to see the effect of flat and clump.
#+begin_src {SuperCollider} -i
a = FormantTable.atKlank(\tenorE).flat;

a.clump(5);
#+end_src

*** Changing vowels: Put it all together
**** Also note the \ugen{Lag}.
     - We want the vowels to slide, not jump.
#+name: formant2
#+caption: All the pieces of the "changing vowels" puzzle: Formlet rather than DynKlank, the arrayed control (NamedControl), fixing the array geometry (flat, clump).
#+begin_src {SuperCollider} -i
~filter = { |ffreq = 6000|
   var sig, in = ~exciter.ar,
   formant = NamedControl.kr(\formant,
      FormantTable.atKlank(\tenorE).flat);
   formant = Lag.kr(formant, 1).clump(5);
   sig = Mix(Formlet.ar(in, formant[0],
      formant[2] * 0.1, formant[2], formant[1]));
   LPF.ar(sig, ffreq).dup;
};

~filter.set(\formant, FormantTable.atKlank(\tenorO).flat);

~filter.set(\formant, FormantTable.atKlank(\tenorU).flat);
#+end_src

*** Exercise for you
    Write a \ci{\textbackslash psSet} pattern to play different
    pitches, and send a different vowel for each note.
    - Look back at the list patterns. Which ones let you choose
      randomly from a list?
    - If this random pattern returns the names from
      \clss{FormantTable}, how to get the filter specs?
      - \mth{collect} can run a function on every one of the names.
      - @@latex:\cd{.collect \{ |name| FormantTable.atKlank(name).flat \}}@@.

*** Notes (arrays in SynthDef)				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Array geometry in synthesis functions
One of the hardest things to understand in SuperCollider is:

- What is the server's responsibility?
- What is the language's responsibility?

The server runs the UGens, and passes signals between them based on
the kinds of connections we have already discussed. That's all it
does. It doesn't know anything about language structures. Functions,
patterns, loops, arrays---all are completely unknown to the server.

\mth{clump}, therefore, is the language's job. But what is it actually
doing in this case?

1. We're initializing the \ugen{NamedControl} with an array of 15
   items. The language needs to have 15 objects, so that it can keep
   track of UGen connections. These 15 objects are
   \clsspl{OutputProxy}. Using "op" as an abbreviation for
   \clss{OutputProxy}:

   #+latex: \cd{[op$_0$, op$_1$, op$_2$, ... op$_{14}$]}

2. \mth{clump} separates the \clsspl{OutputProxy} into groups of five.

   - \cd{[op$_0$, op$_1$, ... op$_4$]},
   - \cd{[op$_5$, op$_6$, ... op$_9$]},
   - @@latex:\cd{[op$_{10}$, op$_{11}$, ... op$_{14}$]}@@.

3. Then, \cd{formant[0]} allows any other UGen (here, \ugen{Formlet})
   to connect back to the first five items from the
   \ugen{NamedControl}. \cd{formant[1]} connects to the second five,
   and so on.

The language can do whatever you need to these array structures while
building a \clss{SynthDef}. But this is only working on the
arrangement of the /signal placeholders/. The language produces the
arrangement while creating the \clss{SynthDef} only once. Then, the
server works only with the UGens, placeholders and their connections,
without worrying about /how/ the connections were arranged in the
first place.

** Karplus-Strong
*** Karplus-Strong
**** Related to modal synthesis:
     - An \egls{exciter} feeds into a filter.
     - The exciter is noisy.
     - The filter shapes it into pitch.
**** Different type of filter.
     - Modal synthesis uses ringing filters.
     - Karplus-Strong uses feedback-delay filters.

*** Feedback-delay filters
**** \eGlspl{feedback-delay filter} include:
     - \eGlspl{comb filter} :: Uses a simple delay line. The spectrum looks like teeth of a comb.
     - \eGlspl{allpass filter} :: Passes all input frequencies at the original volume (hence "allpass"), but changes the phases.
#+latex: \glsadd{CombL}\glsadd{AllpassL}
#+name: fbdelay1
#+caption: Compare the effects of the two types of feedback-delay filters.
#+begin_src {SuperCollider} -i
(
~noise = { WhiteNoise.ar(0.1) };
~filter = {
   CombL.ar(~noise.ar, 0.1, 1/220, 1).dup
};
~filter.play;
)

~filter = {
   AllpassL.ar(~noise.ar, 0.1, 1/220, 1).dup
};
#+end_src

*** Allpass filters and phases
**** The \gls{allpass filter} didn't sound like it was doing much.
     - It doesn't change the frequencies' strengths.\\
       So, the output sounds like the original.
     - It does affect the frequencies' phases.\\
       You don't hear the phase shifts until you the original and filtered signals.
     - The result is like a \gls{comb filter}, but with a softer edge.
#+name: fbdelay2
#+caption: Mix the original with the allpass-filtered signal.
#+begin_src {SuperCollider} -i
~filter = {
   var sig = ~noise.ar;
   sig + AllpassL.ar(sig, 0.1, 1/220, 1).dup
};
#+end_src

*** Short exciter
**** We can excite feedback filters with short noise bursts.
     Just like \gls{modal synthesis}.
**** Exercise for you
     - Add a percussive envelope to the \ci{\textasciitilde noise} module.
     - What does it sound like?
**** Code :noexport:
~noise = {
   WhiteNoise.ar(0.1)
   * EnvGen.ar(Env.perc(0.01, 0.08), Impulse.ar(2))
};

*** Karplus-Strong plucked string synthesis
**** This sounds a lot like a plucked string! Except...
     - In a real string, energy leaks away from the high frequencies first.
     - To model this: Put a lowpass filter in the middle of the feedback loop.
     - The \ugen{Pluck} UGen does this automatically.

*** Pluck.ar example
#+name: pluck1
#+caption: The Pluck UGen. Experiment with the parameters in p.gui.
#+begin_src {SuperCollider} -i
~pluck = { |freq = 220, decay = 1, coef = 0.5|
   Pluck.ar(
      in: WhiteNoise.ar(0.3),
      trig: Impulse.ar(2),
      maxdelaytime: 0.2,
      delaytime: freq.reciprocal,
      decaytime: decay,
      coef: coef
   ).dup
};
~pluck.addSpec(\decay, [0.1, 2, \exp]);
~pluck.addSpec(\coef, [0, 1]);
~pluck.play;

~pluck.clear;
#+end_src

*** Custom feedback
**** \ugen{Pluck} includes only a very simple filter.
     - Doesn't control the cutoff frequency directly.
     - The control is just the amount of damping.
**** For different filters, write the feedback loop explicitly.
     This introduces a number of new server concepts.
     - Feedback with \ugen{LocalIn} and \ugen{LocalOut}.
     - Server \eglspl{control cycle}, delay and frequency.

*** Feedback within a synth
**** Signal flow is always UGen /input/ $\to$ /output/.
     - UGens are ordered. Input UGens must calculate first.
     - For feedback, an earlier UGen needs to get a signal from a later UGen.
     - The normal mechanism cannot do this.
**** \ugen{LocalIn} and \ugen{LocalOut} /can/ do it.
     - Early in the synth: \ugen{LocalIn} says how many channels.
     - Later: \ugen{LocalOut} receives that many channels as input.
     - \ugen{LocalOut} passes the signal back to \ugen{LocalIn}.

*** LocalIn/LocalOut example
    - For now, concentrate on the \ugen{LocalIn} and \ugen{LocalOut}.
    - On your own, puzzle out what the \ugen{SinOsc} is doing.
#+latex: \glsadd{DelayL}\glsadd{TExpRand}\glsadd{Dust}
#+name: localfb1
#+caption: An echo delay, implemented by a LocalIn/LocalOut pair.
#+begin_src {SuperCollider} -i
~feedback = {
   var delay, trig = Dust.kr(0.75),
   sig = SinOsc.ar(TExpRand.kr(300, 600, trig), 0, 0.15)
      * EnvGen.kr(Env.perc(0.01, 0.1), trig),
   feedback = LocalIn.ar(1) * 0.9;  // decay
   sig = sig + feedback;
   delay = DelayL.ar(sig, 0.5, 0.5);
   LocalOut.ar(delay);
   sig.dup
};
~feedback.play;

~feedback.clear;
#+end_src

*** Simplified signal flow
    - This graphic removes the envelope and random frequencies.
    - Imagine a connection from \ugen{LocalOut} to \ugen{LocalIn}.
#+begin_center
#+attr_latex: :height 2.1in
[[../06-appendix/img/localin-out-dot.png]]
#+end_center

*** Insert filtering
**** This exposes a place to insert filtering.
     - You need to filter before feeding back.
     - \ugen{LocalOut} supplies the signal being fed back.
     - So, filter before \ugen{LocalOut}.\\
       (Or any other kind of processing.)
#+begin_src {SuperCollider} -i
   feedback = LocalIn.ar(1) * 0.9;  // decay
   sig = sig + feedback;
   delay = DelayL.ar(sig, 0.5, 0.5);
   delay = LPF.ar(sig, 2000);  // <-- NEW
   LocalOut.ar(delay);
#+end_src
**** Also try substituting \ugen{HPF}.

*** Feedback and pitch
**** If the delay time is short enough, you hear pitch.
     - $f = \frac{1}{t}$ and $t = \frac{1}{f}$
     - So you can set the delay time to \cd{1 / freq}.
**** Change the \ci{\textasciitilde feedback} example for a pitch of 110 Hz.
     - You might not hear much pitch at first. Why? \pause
     - Try changing back to \ugen{LPF}.
     - What should you change to make the pitch sustain longer?

*** Feedback and tuning
**** But... the pitch sounds too low.
     - If the pitch is too low, the delay time must be too long.
     - What would add extra delay time? \pause
**** \eGls{block calculation} in the server.
     - To save CPU time, the server calculates several audio samples in one block.
     - It must finish the whole block before feeding back into \ugen{LocalIn}.
     - \ugen{LocalIn}'s output is one block's duration late.

*** Notes (blocks)					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** How does block calculation save CPU time?
UGens process their signals in C++ functions. When the server needs
the output from a particular UGen, it must call into the appropriate
\ci{\textunderscore next} function. Every function call and return
takes a little CPU time. This time is extremely short, but if hundreds
or thousands of UGens are active, the time multiplies dramatically.

Without block calculation, you would need a function call and return
for every UGen, /every audio sample/. That ends up being a lot of time
spent only on flow of control, in addition to the actual signal
processing.

Block calculation reduces the UGen function calls to happen only once
per block. By default, the block size is 64 samples. The server calls
into an audio rate UGen and gets 64 samples instead of just one, and
it can issue the function calls $\frac{1}{64}$ as often. Signal
processing still takes the same amount of time, but CPU time for flow
of control goes down.

*** Frequency limit from block size
**** The control duration sets the upper limit on frequency.
     - When using \ugen{LocalIn}/\ugen{LocalOut} to make pitch, the shortest possible delay is \ugen{ControlDur}.
     - Maximum frequency is $\frac{1}{t} = \frac{samplerate}{blocksize}$.
     - With default settings, $\frac{44100}{64}$ = 689.0625 Hz $\approx$ MIDI note 76 (E).
     - That's not a very high note.

*** Higher frequencies
**** How to raise the frequency limit?
     - Start the server with a smaller block size.
       - Must be a power of two: 1, 2, 4, 8, 16, 32, 64...
       - \cd{s.options.blockSize = 16} before booting the server, to get two more octaves.
       - The server will start using more CPU.
     - Or, use a trick for single-sample feedback.
       - No time to discuss the details. See the example files.
#+name: ssfeedback1
#+caption: Code snippet to open the single-sample feedback example files.
#+begin_src {SuperCollider} -i :var extract='t
(Platform.resourceDir +/+
   "examples/demonstrations/single_sample_feedback.scd"
).openDocument;
(Platform.resourceDir +/+
   "examples/demonstrations/single_sample_feedback_02.scd"
).openDocument;
#+end_src

*** Karplus-Strong exercises
    1. Start with a feedback-delay plucked string synth.\\
       - You may model it after Listing [[localfb1]].
       - Replace the \ci{SinOsc} with a noise generator, and use a \ci{t\textunderscore trig} argument.
       - Add a filter into the chain.
    2. Run a \ci{\textbackslash psSet} pattern to play notes.
    3. Try different noise generators. How does it change the sound?
    4. Try different envelopes on the noise generator.
       - Shorter and longer.

* Programming concepts for composition
** Composition: Data structures
*** Data storage: Collections
**** Data storage is key.
     - SC has a number of \egls{collection} classes.
     - The different collection types save information differently.
     - Each one supports different ways of working.
**** Choosing the right collection makes the task easier.

*** Ordered vs. unordered collections
**** We've seen two collection types already:
     - \clss{Array} :: Items are saved /in order/ and accessed by /number/.
     - \clss{Event} :: Order doesn't matter. Items are accessed by /name/.
**** These reflect the main division among collections:
     - \Gls{ordered} :: You can count on getting items out in the same order you put them in. Good for sequences of information.
     - Unordered :: Very fast to get information by name or check whether an item is already in the collection. But, the order is lost.

*** Note on order					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Wouldn't it make sense to have the order, always?
Actually, no. Certain tasks are faster if the computer can decide the
order of information. In particular, looking up an item by name, and
testing "membership"---seeing if the collection contains a given
item---benefit from the computer choosing the order.

Suppose you have an \clss{Array} of arbitrary names. To find out if
the array contains a particular name, you have to scan all the array
items. If you find the given name, you can stop early, but if you
don't find it---the worst case---you have to touch every array
element. If the array has several thousand items, this could be slow.

SC's unordered collections use a technique called /hash lookup/ to
speed up the process. It's beyond the scope of this workshop to
explain how hash lookup works. But, it means that SC needs to scan
only part of the unordered storage, which is more efficient.

So:
- Use ordered collections when you need to know the sequence.
- Use unordered collections when you need to know that something is
  there, but the order doesn't matter.

*** Doing things with collections
**** What can you do with collections?
     And why would you want to do them?
     - /Transforming/ data is as important as collecting it in the first place.
     - This is how computers can /generate/ musical details.

*** Example: Phrase separation
**** For example: Split a list of pitches into phrases.
     - Suppose, to make it easy, that phrases go up.
     - Split at every downward jump larger than, oh, a third.\\
       A third, in scale degrees, is 2. /Why?/ \pause
     - How do you get a number for the interval between \ci{a} and \ci{b}?\\ \pause
       \cd{b - a} \pause
     - What's the condition for a downward jump more than a third?\\ \pause
       \cd{(b - a) < -2}

*** Array magic for separation
**** \clss{Array} already has a method for this: \mth{separate}.
     - Give it a \clss{Function} for the condition.
     - The function gets two items as \glspl{argument}.\\
       The items are next to each other in the array.
     - The function returns \ci{true} if a split should happen between those items.
#+name: coll1
#+caption: A sequence of rising phrases, split by the separate method.
#+begin_src {SuperCollider} -i
x = [0, 2, 4, 6, 7, 1, 2, 3, 4, 5, 2,
   3, 5, 6, 7, 8, 10, 3, 5, 6, 8,
   9, 10, 4, 5, 6, 7, 8, 9
];

y = x.separate { |a, b| b - a < -2 };
#+end_src

*** So what?
**** What is that good for?
     - Before, we could:
       - Play the notes in the original order (\clss{Pseq});
       - Or play them in random order, breaking phrases:\\
	 \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}.
     - Now, we can play the /phrases/ in any order, but keep each phrase intact.
**** The point:
     /Doing something to the array created a new \textbf{musical} possibility./

*** Choosing the phrases at random
     Note \ci{z}: We can make a \clss{Pseq} for each phrase in advance.
#+name: coll2
#+caption: Play the phrases in random order. Pxrand makes sure the same phrase will not play twice in a row.
#+begin_src {SuperCollider} -i
z = y.collect { |array| Pseq(array, 1) };

~player = Pbind(
   \degree, Pxrand(z, inf),
   \dur, 0.15
);
~player.play;

~player.clear;
#+end_src

*** Things you can do with any collection
**** All collections can do these basic things:
     - \mth{size} :: How many items?
     - \mth{add} :: Add a new item (if ordered, to the end).
     - \mth{remove} :: Remove an item.
     - \mth{removeAll} :: Remove all the given items.
     - \mth{includes} :: Membership test (\ci{true} if the collection has the exact \egls{identical} item).
     - \mth{includesEqual} :: Slightly relaxed membership test (OK if the matching item is \egls{equivalent}, not identical).

*** Note on identity					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the difference between \egls{identical} vs. \egls{equivalent}, and why does it matter?
\eGls{identical} refers to the same exact object, while
\egls{equivalent} refers to separate objects that happen to have the
same value, or the same contents.

It might seem strange to speak of objects being "identical." If there
can be only one object with a particular identity, how could you
compare it to something else? Wouldn't the comparison always end up
\ci{false}?

Checking identity is meaningful because you can have several
/references/ to the same object: one object, held in several variables
or several collection items. Here, we put an array into \ci{x}, and
then assign the same array into \ci{y}. The \ci{===} test shows that
they are identical. They are not /separate/ arrays with the same
contents. Both variables refer to one and the same array. Because both
variables point to the same place, a change to \ci{x} will also appear
in \ci{y}---because, as far as the array is concerned, it doesn't
matter whether you call it \ci{x} or \ci{y} or \ci{stupidArray}. Its
contents have changed, and /any/ variable referring to that array will
see the change.

#+begin_src {SuperCollider} -i
x = [0, 1, 2];
y = x;

y === x;  // identical

x.put(1, 10);
y;  // prints: [ 0, 10, 2 ]
#+end_src

This is, in fact, a common mistake when creating arrays of arrays
(that is, rows and columns). In this example, all three "rows" are
identical arrays---so, you can't modify any row's contents without
also changing /every/ row.

#+begin_src {SuperCollider} -i
x = Array.fill(3, [0, 1, 2]);

x[0] === x[1];  // identical
#+end_src

The solution is to use a function with \cd{Array.fill}. /Get in the
habit \textbf{now} of using functions here!/ Forgetting the function
@@latex:\cd{\{ \}}@@ is one of /the/ most common mistakes.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x[0] === x[1];  // NOT identical
x[0] == x[1];  // equivalent
#+end_src

Why not simplify, and just test equivalence for everything? The reason
is that checking identity is faster. Speed is important when looking
up items by name in an \clss{Event}, \clss{IdentityDictionary} or
\clss{ProxySpace}, because /many/ comparisons are needed.

For membership testing:

- If the items are \clsspl{Symbol} or \cd{Integers}, you can use
  \mth{includes}. Also, \clss{IdentitySet} is faster for lookup, and
  these types are valid keys in an \clss{IdentityDictionary}.
- Any other types within a collection---\clss{String}, \cd{Float},
  other collections---should check membership by
  \mth{includesEqual}. Use \clss{Set} or \clss{Dictionary}.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x.includes([0, 1, 2]);  // FALSE b/c not identical
x.includesEqual([0, 1, 2]);  // TRUE
#+end_src

*** Looping operations on collections
     All these take a function with arguments \cd{|item, index|}.
     - \mth{do} :: Do something to each item; don't keep results.
     - \mth{collect} :: Do something to each item; keep the results in a new collection.
     - \mth{select} :: Make a new collection, with the items that satisfy the condition in the function.
     - \mth{reject} :: Like \mth{select}, but keeps the items that fail the condition.
     - \mth{count} :: How many items satisfy a condition?
     - \mth{sum} :: Add up the items; the optional function can calculate new values.

*** Collection looping examples
**** Can you imagine musical uses for these?
     Try them one by one, and try to explain the results.
#+name: coll2
#+caption: Examples of looping operations on collections.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
(
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
)
x.select { |item| item > 4 };
x.reject { |item| item > 4 };
x.maxItem;

x = ["An", "array", "of", "strings"];
x.count { |item| item.size > 3 };
x.sum { |item| item.size };
x.maxItem { |item| item.size };
#+end_src

*** Musical uses						   :noexport:

*** Things you can do with ordered collections
**** \Gls{ordered} collections can address items by number.
     - \mth{at} :: Get the item at a given number. Shortcut: \cd{array[1]} $\to$ \cd{array.at(1)}.
     - \mth{put} :: Put a new item into the numbered slot. Shortcut: \cd{array[1] = 5} $\to$ \cd{array.put(1, 5)}.
     - \mth{removeAt} :: Remove the item at the given index.
     - \mth{insert} :: Insert a new item at the index, pushing the other items to the right.
     - \mth{++} :: Join two arrays into one.
     - \mth{pairsDo} :: Like \mth{do}, but takes the items in groups of two.
     - \mth{doAdjacentPairs} :: See the example.
     - \mth{sort} :: Arrange the items in ascending or descending order. *In-place:* modifies the array.

*** Ordered collection examples
#+name: coll3
#+caption: Examples of useful array operations.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
x[3]
x[3] = 22;
x.removeAt(3); x
x = x.insert(3, 22);
x ++ [55, 48, 60];
x.pairsDo { |a, b| "%: %\n".postf(a, b) };
(
x.doAdjacentPairs { |a, b|
   "% - % = %\n".postf(b, a, b - a)
};
)

x.sort;  // restores 0 .. 9 order

// sort in descending order:
// literally, so that an earlier item is bigger
x.sort { |a, b| a > b };
#+end_src

*** Unordered collections: Dictionaries
**** \clsspl{Dictionary} store \clsspl{Association}.
     - Association: \cd{key -> value}.
       - The \egls{key} is the identifier, used to access the items.
       - Very often, the key is a name, written as a \clss{Symbol}: \cd{\textbackslash name}.
**** Array-indexing methods work with dictionaries.
     The \mth{at}, \mth{put} and \mth{removeAt} methods take the
     \egls{key} as the argument, instead of a number.

*** Dictionary types
    - \clss{Dictionary} :: Looks up \egls{equivalent} keys. \clsspl{String} and \clsspl{Array} are valid keys.
    - \clss{IdentityDictionary} :: Looks up \egls{identical} keys. \clsspl{Symbol} and \ci{Integers} are valid keys.
    - \clss{Environment} :: The current environment provides storage for \ci{\textasciitilde environmentVars}.
    - \clss{Event} :: An \clss{Environment} that can be \mth{play}ed.
**** You'll probably use \clss{Event} most often.
     Nice shortcut syntax: \cd{(key: value, key1: value1...)}.

*** Dictionary methods
**** Key-value storage calls for some other methods.
     - \mth{keys} :: All the unique keys in this dictionary.
     - \mth{values} :: An array of the values, without keys.
     - \mth{keysValuesDo} :: Like \mth{do}, but the function arguments are \cd{|key, value, counter|}.
**** Minor difference in filtering methods.
     - \mth{collect}, \mth{select}, \mth{reject}.
     - Arguments passed to the function are \cd{|value, key|}.
     - Why the value first?\\
       To be consistent. The value comes first in all the other \mth{collect} variants.

*** Dictionary examples

    Note the use of \clss{Pdict}, to embed patterns by name.
#+name: coll4
#+caption: A useful Dictionary trick: Naming subpatterns for sequencing.
#+begin_src {SuperCollider} -i
d = (
   mel1: [0, 7, 3, 4, 6, 7],
   mel2: [9, 7, 6, 4, 3],
   mel3: [3.9, 4, 6, 3, 2]
);

// preserves the keys
e = d.collect { |array| Pseq(array, 1) };

e.keysValuesDo { |key, value| [key, value].postcs }; ""

q = Pbind(
   \degree, Pdict(e, Pxrand([\mel1, \mel2, \mel3], inf)),
   \dur, Pwhite(1, 3, inf) * 0.15,
   \scale, Scale.aeolian,
   \root, 11, \octave, 3
).play;

q.stop;
#+end_src
*** Unordered collections: Sets
**** Sets may not contain any duplicated items.
     - \clss{Set}: No \egls{equivalent} items.
     - \clss{IdentitySet}: No \egls{identical} items.
**** \clss{Set} and \clss{IdentitySet} are good for:
     - Checking membership: Does the set have this item?\\
       \clsspl{Set} can search quickly.
     - Avoiding duplicates:
       - What are the unique \glspl{pitch class} in a group of notes?
       - What items are in common between two sets?
       - What items exist in only one of the two sets?

*** Unordered collections: Set methods
    \mth{add}, \mth{remove}, \mth{do} etc. work as in other collections.
    - \mth{sect} :: Intersection (common items: items in setA /and/ setB). Shortcut: \cd{setA \& setB}.
    - \mth{union} :: Union: items in setA /or/ setB, or both. Shortcut: \cd{setA | setB}.
    - \mth{difference} :: Items in setA that are /not/ in setB. Shortcut: \cd{setA - setB}.
    - \mth{symmetricDifference} :: Items in only one of the two, but not both. Shortcut: \cd{setA -- setB}.

*** Unordered collections: Set examples
#+name: coll5
#+caption: Examples of useful Set operations.
#+begin_src {SuperCollider} -i
x = [59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68];

// unique pitch classes
y = IdentitySet.new;  // OK b/c Integers
x.do { |item| y.add(item % 12) };
y;  // 5 items only: duplicates ignored
z = IdentitySet[11, 1, 2, 4, 6, 7, 9];  // b minor

// which notes in y belong to a b minor scale?
y & z;

// which notes in y are *not* in b minor?
y - z;

// which notes are in either y or z, not both?
y -- z;
#+end_src

*** Summary: Collections
**** Any collection:
     - Loop: \mth{do}, \mth{collect}.
     - Filter: \mth{select}, \mth{reject}.
**** Store and recall items /in order/ (\clss{Array}).
     - Split (\mth{separate}, \mth{clump}) and join (\mth{++}) items.
     - \mth{sort} in order, and randomize the order (\mth{scramble}).
**** Store and recall items /by name/ (\clss{Dictionary}).
     - Looping: \mth{keysValuesDo}.

*** Collections: Musical memory
**** Composers and improvisers /manipulate/ musical material.
     - Create variations on a basic idea.
     - Cut material support, rearrange, splice, transpose, otherwise alter.
**** Collections let you store musical ideas and change them.
     - One week is not enough to go very far.
     - Keep these classes in mind. You /will/ need them later.

** Composition: Control structures
*** Control structures: Branching and Looping
**** Running code straight through is boring and limiting.
     Two things are very important in computing:
     - Making decisions: Which one of several things to do?\\
       This is \egls{branching}.
     - Doing the same thing many times, with different information.\\
       This is \egls{looping}.

*** Branching
**** \Gls{branching}'s basic question:
     I have two or more branches I can take. Which one?
**** Branching structures in SuperCollider:
     - \mth{if} :: *If* (condition), *then* do this; *else* do that.
     - \mth{case} :: Check several conditions; do the action for the first "true."
     - \mth{switch} :: Look up an action by value.

*** Boolean values
**** Branching depends on \egls{Boolean} expressions.
     - A \egls{Boolean} is either true or false, no middle ground.
     - Boolean expressions are often called "conditions":\\
       \cd{x < 10} is a condition: Either \ci{x} is, or it isn't.
     - Most conditions are based on comparison operators:
       - \ci{==}, \ci{===}: Are two items \egls{equivalent} or \egls{identical}?\\
	 \ci{!=} and \ci{!==}: Not equal, or not identical.
       - \ci{<}, \ci{<=}, \ci{>}, \ci{>=}: Less than or greater than?
       - Also useful: \mth{inclusivelyBetween}\cd{(lo, hi)}.

*** Basic branching: If
**** \mth{if} is the basic decision maker.
     - Remember it this way: *If -- then -- else*.
     - Can you predict what the \cd{10.rand} example will do?
#+name: if1
#+caption: Outline of the ``if'' structure.
#+begin_src {SuperCollider} -i
if(condition) {
   (then... true branch)
} {
   (else... false branch)
};

x = 10.rand;
if(x < 5) {
   "low random number: %\n".postf(x);  // then
} {
   "high random number: %\n".postf(x);  // else
};
#+end_src

*** Note on branch returns				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
You might have noticed that the \cd{10.rand} example displays the
string twice. Why?

The \ci{postf} method formats a string (substituting \ci{x} where the
\ci{\%} appears) and then prints it. This accounts for the first
display.

The second display is because SC always prints the result of the last
expression in the code block that was just executed. The last
expression is the \mth{if}. So, if the string printed again, then the
\mth{if} statement itself must have returned the string as a result
value.

This is a big difference between SuperCollider and languages like C or
Java. In C, \mth{if} is a "statement," and statements have no
value. The statement says what to do, but when the statement finishes,
its only effect is that it did something to something else.

By contrast, in SC, /everything/ is an expression. /Every/ statement
produces a return value. You can choose to ignore the return value,
but the value will be returned anyway. For example, look back at the
\mth{collect} example in Listing [[coll2]].

#+begin_src {SuperCollider} -i
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
#+end_src

\cd{item * 10} is not really an /action/---it doesn't change a
variable or tell an object to do something---but it does produce a new
value. If the incoming item is an odd number, the \mth{if} says to
multiply that item by 10 /and return the result/. This returned result
goes back to \mth{collect}, which puts the new value into the result
array.

This is a very powerful idea, and it may take some time to
understand. Put it in the back of your mind for now, and come back to
it later when you need it.

*** What to do with "if"?
**** Just about anything...
     - Play a note on 75\% of 16th-notes in a bar.\\<all>
       *If* a 75% coin toss is true, keep the event; else make it a rest.
     - Avoid reloading something that's already loaded.\\<all>
       *If* the variable is nil, load it; else do nothing.\\
       (Note: You can just leave out the /else/ branch.)
     - On/off buttons.\\<all>
       *If* the user turned it on, do something; else, do something different.

*** "If" examples
#+name: if2
#+caption: Practical uses of "if."
#+begin_src {SuperCollider} -i
a = Pbind(  // canonical style
   \degree, Pn(Pseries(0, 1, 8), inf),
   \dur, 0.125.asPattern.collect { |dur|
      if(0.75.coin) { dur } { Rest(dur) }
   }
).play;

a.stop;

if(b.isNil) { b = Buffer.alloc(s, 44100*5, 1) };

o = Button(nil, Rect(600, 100, 100, 20))
.states_([["off"], ["on"]])
.action_({ |button|
   if(button.value == 1) {
      "on".postln;
   } {
      "off".postln;
   };
}).front;
#+end_src

*** Note: New stuff 					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** New elements
     - \mth{asPattern}: We need \ci{0.125} to act like a pattern, so
       that \mth{collect}'s function will run once for every
       event. Here, it's an easier-to-read alternative to
       \cd{Pn(0.125, inf)}.\glsadd{Pn}
     - \clss{Button}: Makes a clickable GUI button. We'll cover GUI basics later. For now:
       - \ci{nil} means the button has no parent window. It will make
         its own window automatically.
       - \clss{Rect} gives the position (600 and 100 are at the left
         and top coordinates) and size (100 and 20 are the width and
         height).
       - The button has two states, labeled as shown. Each state has
         its own sub-array, so that you can assign different colors.
       - \mth{front} brings the window to the front, so you can see it.

*** Compound conditions 
**** Often, you need to put several conditions together.
     E.g., if x is odd, and more than 100.
**** Logical operators:
     - \ci{and} :: True, if /both/ are true.
     - \ci{or} :: True, if /either/ is true, or both.
     - \ci{xor} :: True, if one or the other is true, but not both.
**** dummy						    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     The above would be written: \cd{x.odd and: (x > 100)}.
     - You must put \ci{()} around the second condition.

*** Short-circuiting conditions
**** Sometimes you don't have to test all the conditions.
     \cd{x.odd and: (x > 100)}:
     - If \ci{x} is even, the first condition is false.
     - False \ci{and} anything is false: so \ci{x > 100} doesn't matter!
**** Good to get in the habit of writing conditions this way:
     @@latex:\cd{x.odd and: \{ x > 100 \}}@@.
     - Writing the second condition as a function means SC can skip it if possible.
     - This can improve speed by avoiding wasted expressions.

*** Short-circuiting and type safety
**** Some conditions are valid only for some types of objects.
     - Short-circuited conditions make it easy:\\
       @@latex:\cd{if(typecheck and: \{ condition \}) ...}@@
     - SC will try the condition the only if the type check is OK.
     - Often the result of an expression is \ci{nil} (empty result).\\
       Handle it this way:\\
       @@latex:\cd{if(object.notNil and: \{ condition \}) ...}@@

*** Other branching methods
    \mth{case} and \mth{switch} make some kinds of branching easier.\\
    We won't cover them in detail here. Look them up the help system for more.
    - Case: [[http://doc.sccode.org/Classes/Function.html\#-case][Web link]]
    - Switch: [[http://doc.sccode.org/Classes/Object.html\#-switch][Web link]]
    - Control structures in general: [[http://doc.sccode.org/Reference/Control-Structures.html][Web link]]

*** Looping
**** We have seen loops over collections.
     \mth{do}, \mth{keysValuesDo}, \mth{collect}, \mth{select}, \mth{reject}.
**** Other useful loops:
     - \ci{number.do}: Counts 0 to (number--1).
     - \ci{Array.fill}: Counts 0 to (number--1), adds function results to a new array.
     - \cd{(start .. end).do}: Counts \ci{start} to \ci{end}.\\
       Shortcut for \mth{for}: @@latex:\cd{for(start, end) \{ body \}}@@.
     - \cd{(start, second .. end).do}: Counts \ci{start} to \ci{end}, with a skip of \cd{second - start}.\\
       Shortcut for \mth{forSeries}: @@latex:\cd{forSeries(start, second, end) \{ body \}}@@.

* Synchronizing interfaces: Model-View-Controller
** Model-View-Controller object design
*** What is Model-View-Controller?
**** Model-View-Controller (MVC) is a software design for user interfaces.
     - Created in the 1980s as part of SmallTalk.
     - /Still used today!/
**** MVC does two main things to make interfaces easier to manage:
     - Divides the requirements of an interface into logical units.
     - Controls the flow of information between these units, to avoid confusion.

*** Note: Audience					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
This section is a little more advanced. If you are just starting with
SuperCollider, you don't need to worry about this right away. You can
do a lot with the simple GUI techniques discussed in Part III.

I'm including this material because it looks forward to your future
needs. When you start a project, you might not know all the kinds of
interfaces the piece will eventually need. The techniques in this
section will help you build the ability to add or change interfaces
into the code from the beginning. It's a small investment upfront that
can save a lot of time later.

Also, it addresses the practical problem of showing the same
information on the computer screen and a phone or tablet.

*** Parts of MVC
**** MVC is made of:
     - \Gls{model} :: The object that does real work. The model should
                      have no visible interface on its own.
     - \Gls{view} :: Physical display and user interaction. Buttons,
                     sliders and TouchOSC controls may be views.
     - \Gls{controller} :: The "glue" between the model and the view.
**** dummy						    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     - If the model changes, the controller updates the display.
     - If the user touches a view, the controller changes the model's state.

*** What problem does MVC solve?
**** *Problem:* Multiple displays (views) of the same object.
     - The simplest idea is: Every view talks to every other view.
     - When you have more views, this will drive you insane.
**** *Solution:* Strict flow of information.
     - User action: View $\to$ Controller $\to$ Model
     - Change in the model: Model $\to$ Controller $\to$ View
**** That's... really abstract. What on earth does it mean?
     Let's try an example.

*** Building a MVC for a ProxySpace, step 1
**** Recall the GUI examples from Part II: \ci{EZSlider} $\to$ pitch.
     This translates neatly into MVC.
     - *Model:* A \clss{NodeProxy} representing frequency.
     - *View:* The \ci{EZSlider} itself.
     - *Controller:* The \ci{EZSlider}'s action function.
**** Starting with the model:
#+name: mvc1
#+caption: A simple use of MVC to control pitch by a slider, starting here with just the model.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new.push;

// MODEL: A numeric NodeProxy
~freq.addSpec(\value0, \freq);
~freq = 440;

// Create the oscillator, but don't play it yet.
~oscil = { VarSaw.ar(~freq, 0, 0.25, 0.1).dup };
#+end_src

*** MVC step 2: View and Controller
**** \ci{EZSlider} includes both the view and controller.
#+name: mvc2
#+caption: EZSlider as view and controller.
#+begin_src {SuperCollider} -i
w = Window("MVC demonstration", Rect(700, 300, 300, 100));

// VIEW: EZSlider
z = EZSlider(w, Rect(5, 5, 290, 20), "freq", \freq,
   // CONTROLLER: Callback function
   { |sl| ~freq = sl.value }, 440
);

b = Button(w, Rect(5, 30, 290, 30))
.states_([["stopped"], ["playing"]])
.action_({ |btn|
   if(btn.value == 1) { ~oscil.play } { ~oscil.stop };
});

w.front;
#+end_src

*** Action function as controller
**** The action function does exactly what a controller should:
     - The user touches the slider.
     - The slider calls the function (controller).
     - The controller talks back to the model.\\
       Here, "talking back" means changing \ci{\textasciitilde freq}'s value.
**** Any type of controller should work like this.
     In "real" programming, the controller is a dedicated object.\\
     We're taking a little shortcut here.

*** Synchronizing the display
**** *Problem:* The controller works in only one direction.
     - It works fine if you change pitch from the GUI.
     - Try running this:\\
       \cd{\textasciitilde freq = 220;}
     - What happened in the GUI?\pause \\
       /Nothing.../
**** *Solution:* Another controller.
     - This one catches the model's changes, and updates the GUI.

*** Notifications from the model
**** We need to know when the model changed.
     - In traditional MVC, the model /broadcasts/ a notification.
     - \clss{NodeProxy} already does this!
**** Listening for notifications in SuperCollider
     Good choices for listeners:
     - \clss{Updater} :: Acts on every notification.
     - \clss{SimpleController} :: Responds to specific notification keys.
     \clss{SimpleController} allows you to write simpler functions, and it's a bit faster.

*** MAYBE Notes on listeners			   :B_ignoreheading:noexport:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Advanced usage: Writing your own controller object
\clss{Updater} or \clss{SimpleController} handle a lot of needs. When
an interface becomes a lot more complex, however, it may be easier to
create an object that handles both directions of communication in
one. This is actually better software design, but it's overkill for
the relatively simple cases in this workshop.

The mechanics of creating your own classes is beyond the scope of this
workshop. You can start with the help file entitled "Writing Classes"
for some basic information.

Finish this later...

*** What do the notifications look like?
**** The notification's structure depends on its purpose.
     - How do you find out exactly what is in the notification?\pause\\
     - You can use \clss{Updater} to "trace."
     - Give the updater a function that prints the arguments.\\
       The notification arguments are:
       - \ci{changer} :: The object sending the notification.
       - \ci{what} :: A Symbol, describing what happened.
       - \ci{allArgs} :: Any number of additional values.
#+name: mvc3
#+caption: Look at the NodeProxy's notifications, using an Updater.
#+begin_src {SuperCollider} -i
u.remove;
u = Updater(~freq, { |obj, what ... allArgs|
   [obj, what, allArgs].postcs;
});

// When finished tracing:
u.remove;
#+end_src

*** What does the printout mean?
**** You should get something like this:
#+begin_src {}
[ ~freq, 'set', [ [ 'value0', 220.0 ] ] ]
#+end_src
     - \ci{changer}: The NodeProxy. No surprise here.
     - \ci{what}: A Symbol, @@latex:\cd{'set'}@@.\\
       We are setting a control, so again, no surprise.
     - \ci{args}: An array, listing control names and values.\\
       We are interested in the value: \cd{array[1]}.

*** Note on allArgs					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** A little clarification on \ci{allArgs}:
In this usage, \ci{allArgs} needs to represent /several/ arguments
that can be passed in the notification. But \ci{allArgs} is one
variable, and one variable can hold only one object. So, \ci{allArgs}
is an array containing all the arguments after \ci{changer} and
\ci{what}.

This is the meaning of the @@latex:\ci{...}@@ argument syntax: It
assumes the single variable name will represent several discrete
arguments, and packs them into an array. We're using it here for
exploration, because we don't know how many values will come with this
notification.

Inside this array is another array. That's the argument itself:
@@latex:\cd{[ 'value0', 220.0 ]}@@. When we write the real controller,
we'll leave out @@latex:\ci{...}@@ and just write a single argument
name. Then we can treat this as an array directly.

*** Updating the GUI from the notification
**** \clss{SimpleController} can register a function to update the slider.
     - How to set the slider's value? \pause\cd{z.value = newValue;}\pause
     - Where does the new value come from? \pause\cd{setArray[1]}\pause
     - \mth{defer} is important here!
#+name: mvc4
#+caption: Add a SimpleController, which responds to 'set' notifications by updating the slider.
#+begin_src {SuperCollider} -i
u.remove;
u = SimpleController(~freq)
.put(\set, { |changer, what, setArray|
   defer { z.value = setArray[1] };
});

// Try it:
~freq = exprand(220, 880);

// When finished:
u.remove;
#+end_src

*** Summary: MVC and GUI
**** Putting it all together, it's not so complicated:
     - An object for the value (model = numeric \clss{NodeProxy}).
     - An object for the display (view = \ci{EZSlider}).
     - A function that changes the model based on user interaction (controller = action function).
     - A listener that changes the display based on the model (\clss{SimpleController}).

*** Compare to the earlier GUI code
**** Just to differences between this and the earlier GUI code:
     - Storing frequency in its own \clss{NodeProxy}.\\
       The information should be separate from the interface!
     - The \clss{SimpleController} to keep the GUI in sync.
     So, /it really isn't that much to implement/.
**** What's the real benefit?
     MVC makes it /much/ easier to add another interface!

*** Adding a mobile controller
**** Let's also control frequency by TouchOSC.
     Same requirements:
     - Touching the control should change the frequency.
     - If the frequency changes in the computer, we should see that on the phone.
     Same implementation:
     - Instead of \ci{EZSlider}'s action function, we'll use \ci{OSCdef}.
     - Still using \clss{SimpleController}.\\
       Instead of setting the GUI's value, we'll send a message to the phone.

*** MVC mobile controller example
    - Assumes you have already set up OSC communication.
    - \clss{OSCdef} doesn't map the range for you.\\
      So we have to map when receiving, and unmap for sending.
    - \mth{sendMsg} needs a \clss{NetAddr} for the target.\\
      Its arguments list the message's Items.
#+name: mvc5
#+caption: Add mobile control to the example. The GUI and phone should stay in sync.
#+begin_src {SuperCollider} -i
// Receiving OSC
OSCdef(\sl1, { |msg|
   ~freq = \freq.asSpec.map(msg[1]);
}, '/1/fader1', NetAddr("192.168.43.1", nil));

// Sending OSC
n = NetAddr("192.168.43.1", 9000);  // Where to send
o.remove;
o = SimpleController(~freq)
.put(\set, { |changer, what, setArray|
   n.sendMsg('/1/fader1', \freq.asSpec.unmap(setArray[1]));
});
#+end_src

*** Object design schematic
**** Now, the data flow looks like this.
     Key point: The lines of communication are simple and minimal.
#+begin_center
#+attr_latex: :height 1.8in
[[../06-appendix/img/mvc-schematic.pdf]]
#+end_center

*** Exercise: Synchronize the button
**** Exercise for you: MVC for the button control.
     Think through the components:
     - What is the model?\\
       (Hint: What is the button turning on and off?)
     - \clss{OSCdef} to control the model by mobile.\\
       From TouchOSC, @@latex:\cd{'/1/toggle1'}@@ will work.
     - \clss{SimpleController} to update the GUI and phone.
       - Notification keys: \ci{\textbackslash play} and \ci{\textbackslash stop}.
       - \ci{\textbackslash play}: Set the button and toggle to 1.
       - \ci{\textbackslash stop}: Set them to 0.
       - Look back at previous examples to see how to set the interfaces.

*** Cleaning up
**** *IMPORTANT:* Clean up \clsspl{SimpleController} when finished.
     - If you don't, they stay in memory until you quit.[fn:b0eb1b89]
     - Same for \clss{Updater} or anything given to \mth{addDependant}.
**** Two ways to clean them up.
     - *By hand:* Call \mth{remove} to discard an old controller.
     - *Automatically:* If the model gives a notification when it
       dies, the controller can clean itself up!
       - \clsspl{NodeProxy} send a \ci{\textbackslash clear} notification.
       - When you do \cd{p.clear}, the dependents go away by themselves.
#+name: mvc6
#+caption: Using a NodeProxy's ``clear'' notification to remove dependents.
#+begin_src {SuperCollider} -i
u.put(\clear, { u.remove });
o.put(\clear, { o.remove });
#+end_src

*** Note: Cleanup					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
The above works, of course, only if you still have a reference in a
variable to the \clss{SimpleController}. If you reassigned \ci{u} or
\ci{o} to another object, then you'll be removing the other object and
the \clss{SimpleController} will stay in memory.

One way to handle this is to keep a private reference in a
\gls{declare}d variable. Include the \ci{\textbackslash clear}
function when you first create the controller.

#+begin_src {SuperCollider} -i
(
var controller;

controller = SimpleController(~freq)
.put(\clear, { controller.remove })
.put(\set, { ... your action here ...});

u = controller;
)
#+end_src

Now, it doesn't matter what happens to \ci{u}, because
\ci{\textbackslash clear} will act on the variable named
\ci{controller}. This variable is private to that code block---you
can't reassign it from outside---so you can be sure it will always
point to that specific controller.

In emergencies, if you still have the model in a variable, you can
call \mth{releaseDependants} on it to get rid of all the controllers
at once.

*** MVC benefits
**** MVC is more flexible to wire up multiple interfaces.
     - Add and remove interfaces at any time.
     - Controlled data flow can keep many interfaces in sync and avoid confusion.
       - User action: View $\to$ controller $\to$ model.
       - The model broadcasts changes to controllers:\\
	 Model $\to$ controller $\to$ view.
**** It gets easier with practice.
     - Simple uses: This might seem too complicated.
     - If there's any chance you'll need to expand the interface, go with MVC from the beginning.
     - It /will/ save time later.

*** DONE Wrap up						   :noexport:
    - [X] Button control
    - [X] Cleanup
    - [X] Chart of data flow
    - [X] Adding the OSC controller was easy because we set up a good structure first

* Footnotes

[fn:b0eb1b89] Or recompile the class library.

