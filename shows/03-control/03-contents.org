#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Granular synthesis						   :noexport:
** Granular synthesis parameters
*** Granular synthesis: Extremely powerful
**** Many common effects are based on \egls{granular} synthesis.
     - Notably, time stretching and pitch shifting.
     - Also good for long, complex drones.
**** A form of /microsound/.
     - Typically, sounds between 10 and 100 ms duration.
     - Rhodes, Curtis (2001). /Microsound/.

*** What is granular synthesis?
**** \eGls{granular} synthesis composes sounds from clouds of very short \eglspl{grain}.
     - When you have enough grains, you hear only the cloud.
     - As in these graphics: The more grains, the harder to see the individuals.
#+begin_center
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains100.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains200.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains500.png]]
#+end_center

*** Characteristics of grains and clouds
**** Important things about a \gls{grain}:
     - *Duration:* How long it is.
     - *Envelope:* Its shape.\\
       Sine-shaped envelopes work especially well.
     - *Spectral content.* Usually comes from sampled audio in a \clss{Buffer}.
**** Important things about grain clouds:
     - *Overlap:* How many grains simultaneously. (May vary.)
     - *Time distribution:* Are the grains evenly spaced in time?

*** Sine-shaped envelopes
**** Sine envelopes work well because they are complementary.
     - /Complementary/: Add them together, with the right offset, and you get a constant.
     - So, the individual envelopes blend together into a consistent volume.
#+begin_center
#+attr_latex: :height 1.5in
[[../03-control/img/sinusoidal-envelopes.png]]
#+end_center

*** Start simple: Individual grains
**** \Gls{granular} UGens have a number of parameters.
     - If we do too many at once, it's confusing.
**** Parameters needed for single \glspl{grain}:
     - *Trigger:* We'll use \ugen{Impulse}, controlled by frequency.
     - *Duration*.
     - *Position* within the buffer: for now, in seconds.
#        , as a \egls{normalize}\emph{d} range.
#        - 0 = buffer start, 1 = buffer end.
#        - Why? \Glspl{Buffer} may be of different sizes.
#        - If it's normalized, the position input can be the same for any buffer.

*** TGrains UGen
**** Basic granulator: \ugen{TGrains}.
     - You can control trigger frequency, grain duration and buffer position.
     - Raise the trigger frequency until the grains blend together.
#+name: grain1
#+caption: Granular synthesis: first step.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~grains.addSpec(\tfreq, [1, 20, \exp]);
~grains.addSpec(\pos, [0, b.duration]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, pos = 0.5,
   amp = 0.2|
   var trig = Impulse.ar(tfreq);
   GrainBuf.ar(2, trig, graindur, b, 1, pos, 2, pan) * amp;
};
~grains.play;
)

p.gui;  // if it's not already open
#+end_src

*** Automating buffer position
**** Let's move forward through the buffer.
     Constant rate---what do you think will be the result?
**** Replace the \ci{pos} argument with a \ugen{Phasor}.
     - \ugen{Phasor} is a looping line segment, with a rate control.
     - \ci{rate} is in units per sample.\\
       At audio rate, \cd{rate = 1} will increase by 44100 in one second.
     - We want to increase by 1.0 per second.\\
       See \ugen{SampleDur}, which outputs $\frac{1}{samplerate}$.
     - What's the upper boundary?\\
       \Gls{Buffer} duration: \cd{b.duration} or \ugen{BufDur}\cd{.kr(b)}.
**** Exercise for you: Write the \ugen{Phasor}.
# #+name: grain2
# #+caption: Use a Phasor to move through the buffer in real time.
#+begin_src {SuperCollider} -i :exports none
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.2|
   var trig = Impulse.ar(tfreq),
   pos = Phasor.ar(0, SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, pos, graindur, pan, amp)
};
#+end_src

*** Speed of buffer movement
**** What if we move through the buffer at different speeds?
     - Add a new argument, \ci{speed}.
     - Set its range, using \mth{addSpec}, to \cd{[0.25, 4, \textbackslash exp]}.
     - How to incorporate \ci{speed} into the \ugen{Phasor}?\\
       *Hint:* \ci{speed} should /scale/ (multiply) the \ugen{Phasor} rate that is already there.
**** Exercise: Write this yourself.
     What is the result?
# #+name: grain3
# #+caption: Adjust the buffer movement speed by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\speed, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain rate
**** What about the \ci{rate} argument in \ugen{TGrains}?
     - We adjusted the \ugen{Phasor} rate, and got a time effect.
     - What do you think \ugen{TGrains}'s rate will do?
**** Let's find out: Write the change yourself.
     - Add a new \ci{rate} argument.
     - Give it a similar exponential range.
     - Plug it into \ugen{TGrains}.
# #+name: grain4
# #+caption: Adjust the grain playback rate by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\rate, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   rate = 1, speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, rate, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain duration vs. overlap
**** Sometimes better to control how many overlapping \glspl{grain}.
     - That is, adjust the grain duration along with trigger frequency.
     - If you want 4 overlapping grains, and 1 trigger/sec, how long should each grain be?\pause\\
       4 seconds.\pause
     - If you have 2 triggers/sec, how long should the grains be?\pause\\
       2 seconds.\pause
     - What, then, is the formula?\pause\\
       \cd{overlap / trigfreq}\pause
**** Exercise, on your own time:
     Edit the synth to use an \ci{overlap} argument instead of \ci{graindur}.

*** Summary: Granular synthesis parameters
**** \Gls{granular} synthesis gives you independent control over:
     - Time (buffer position's rate of change);
     - Pitch (playback rate of each \gls{grain});
     - Continuity (frequency of triggers, grain duration, overlap).
**** Tone color comes from whatever is in the buffer.

** Usage of granular synthesis
*** Sustaining sounds
**** Sustaining sounds need:
     - Fast grain triggers;
     - Relatively high overlap (at least 5).
**** Important to avoid too much regularity.
#      If the trigger frequency, buffer position and grain rate are all constant, then you hear sonic features repeating exactly.
#+name: grain5
#+caption: Granular synthesis, sustaining sound, with constant triggers, buffer position and grain rate.
#+begin_src {SuperCollider} -i
p.clear;

~grains.addSpec(\tfreq, [1, 40, \exp]);
~grains.addSpec(\overlap, [0.1, 10, \exp]);
~grains.addSpec(\pos, [0, b.duration]);  // 3.43 is nice!
~grains.addSpec(\rate, [0.5, 2, \exp]);
~grains = { |tfreq = 25, overlap = 6, pan = 0, amp = 0.2, pos = 3.43,
   rate = 1|
   var trig = Impulse.ar(tfreq);
   TGrains.ar(2, trig, b, rate, pos, overlap / tfreq, pan, amp)
};
~grains.play;
#+end_src

*** Solution: Randomize
**** It sounds boring because the pattern is too obvious.
     - The ear latches onto the repeating features, not the sustained feel.
     - So, break up the pattern by adding a small random offset.
**** Add random \egls{LFO} modules.
     - \ugen{LFNoise1} is good for random numbers.
     - The LFO module should convert to the right range (as we covered earlier).
     - Then, modulate the input within \ci{\textasciitilde grains}.

*** Randomize buffer position
**** What's a good range?
     - A random range in seconds is OK.
     - You don't need much: 0.1--0.2 seconds is enough.
**** Exercises for you:
     1. Write an \gls{LFO} module with \ugen{LFNoise1}:
	- Fairly high frequency (at least 50).
	- Include an argument for the amount of modulation, ranging 0--maximum seconds.
	- Give that argument an appropriate range spec.
     2. Edit \ci{\textasciitilde grains} to apply the LFO.
     3. Adjust the LFO amount and listen to the different effects.

*** Randomize grain playback rate
**** What's a good range?
     - \ci{rate} is a multiplier---so the range should be \egls{exponential}.
     - Do you remember how to convert to an exponential range?
     - You need only a few cents (cent = 0.01 semitone).
     - The ratio for 1 cent = 1.0005777895066.\\
       \cd{0.01.midiratio}
     - 20 cents = \cd{0.2.midiratio} = 1.0116194403019.
**** Exercises for you.
     Same as for buffer position, except with a different range, and exponential usage.

*** Small vs. large scale modulation
**** You can also combine two kinds of modulation:
     - Small range, fast modulation.
     - Larger range, slower modulation.
**** For instance, moving through a buffer.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.6
     :END:
     - \ugen{Phasor} in a straight line.
     - \ugen{LFNoise1}, low amplitude.
     - It still sounds like moving through the buffer, but with some variation.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.4
     :END:
     #+attr_latex: :height 1in
     [[../03-control/img/randomized-line.png]]

*** Glitchy sounds
**** Glitchy sounds also use random \glspl{LFO}, but wider range.
     - Take grains from any part of the buffer at any time.
     - Much shorter \ci{graindur} (can randomize this too).\\
       When dur < 0.015, the envelope changes the tone color!
     - Also, randomize the time between triggers (e.g., \ugen{Dust}).
     - See also the \ugen{GrainBuf} UGen.\\
       Allows you to choose a different envelope. Percussive envelopes can be really noisy!
**** Exercises: Edit the granular synth to try these techniques.

*** Granulating live input
**** What if you want to do this on a real-time signal?
     - Tricky if you want to play it faster than real time.
       - Grain rate > 1.
       - Buffer movement speed > 1.
     - Much slower is also a problem.
**** Shortcut: \ugen{PitchShift} UGen.
     - Can raise or lower pitch of a live signal up to two octaves.
**** Using \clsspl{Buffer} and \ugen{TGrains}:
     - Beyond the scope of this class.

*** Summary: Synthesis techniques
**** Techniques:
     - Subtractive synthesis ("analog"): \egls{oscillator} $\to$ \egls{filter}.
     - Frequency modulation: \egls{modulator} $\to$ \egls{carrier}.
     - Granular synthesis: Clouds of short, enveloped \eglspl{grain}.
**** Next steps:
     - Build more complex, compositional patterns.
     - Bring external control data into SC, and plug into synthesis and composition parameters.

* Toward complex composition
** Simple ideas
*** You take the lead
    From here, we will do less guided explanation of techniques, and
    focus more on your creativity.
    - Larger modular synths;
    - Pattern sequences with more musicality;
    - Control in performance by external devices.

*** The trick
**** The trick to making music by programming:
**** quote							:B_quotation:
     :PROPERTIES:
     :BEAMER_env: quotation
     :END:
     A simple idea by itself is boring.\\<all>
     Lots of simple ideas working together make music.

*** Workflow
**** A typical way to develop interesting musical element:
     1. Start with a basic idea of this element's role in the piece.
     2. Write a simple synth and/or pattern that seems related.
     3. Listen carefully. What is missing from the simple idea?\\
	Think of /small/ adjustments.
     4. Write a new component:
	- A second or third \gls{oscillator} (or \gls{granular} node);
	- An \gls{LFO} or \gls{envelope} module to control some parameter;
	- A more complex child pattern in \clss{Pbind};
	- Another GUI or external control.
     5. Go back to step 3.

*** Experience
**** That almost makes it sound easy...
     /Experience/ is what's missing from that picture.
     - What techniques work for what kinds of sounds?\\
       E.g., FM synthesis with ratio = 0.5 makes great basslines.
     - *Dos* and *don'ts* of modulation.
     - When to control an input by \clss{Pbind} vs. modulation units?
**** No way to learn, except to /try/ and /make mistakes/.
     Here in the workshop, I can help steer you in the right direction.

*** Try it together, as a group
**** Let's take 20--40 minutes to do this as a group.
     Questions to get you started thinking:
     - What kind of sound or texture do you want?\\
       Pitched or noisy? High, low or middle frequencies?
     - What kind of musical behavior?\\
       Rhythmic or not? Tonal or not?
     - Any sound effect you heard somewhere, that we can try?
**** If none of those spark any ideas---
     - Which synthesis technique would you like to explore more?

*** Working...
#+begin_center
Switch over to SuperCollider and start building...
#+end_center

** Composition: Representing musical information
*** Data representation
**** Composition depends on /representing musical information/.
     - Western notation: Notes and rhythms.\\
       Assumes 12 notes per octave, double or triple divisions of time.
     - Logic or Cubase "piano roll" view: Similar assumptions.\\
       Time is more flexible.
**** Both of these assume a beginning-to-end sequence.
     - In SC, we don't have to follow that rule!
     - We have more choices to store useful information.

*** Representing pitch
**** Recall \clsspl{Event}, and three ways to write pitch.
     - \ci{\textbackslash freq} in Hz.
     - \ci{\textbackslash midinote} in MIDI note numbers.\\
       Converted to Hz according to 12-ET.[fn:1]
     - \ci{\textbackslash degree} in scale degrees.\\
       - Converted to \ci{\textbackslash midinote} based on \ci{\textbackslash scale}, \ci{\textbackslash root} and \ci{\textbackslash octave}.
       - \ci{b} and \ci{s} modifiers: \cd{4s} means degree 4, sharped. \ci{b} is flat.
**** If you're using pitch, decide which one best fits the material.

*** Representing rhythm
**** Usually in \eglspl{beat}.
     - \clsspl{TempoClock} run in beats.
     - \Gls{delta} time = 1 means the next event is one beat later.
     - You can change the tempo.
**** Sometimes useful to write rhythm as \eglspl{time point} within the bar.
     - Often useful for drum rhythms.
     - See also Milton Babbitt's "time-point sets."\\
       [[http://en.wikipedia.org/wiki/Time_point]]
     - \clss{Pdelta} converts a pattern of time points into deltas.

*** Deltas vs. time points 1
**** First we need a sound to play.
     Questions for you:
     - Can you guess what it will sound like, from reading the code?
     - Does it make sound right away? Why or why not?
     - How would you make it sound on demand?
#+name: timept1
#+caption: A quick-and-dirty sound to trigger in rhythm.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

~sound = { |t_trig, freq = 660, amp = 0.1|
   var sig = PinkNoise.ar(amp),
   eg = EnvGen.kr(Env.perc(0.01, 0.2), t_trig);
   sig = BPF.ar(sig, freq, 0.1);
   (sig * eg).dup
};
~sound.play;
#+end_src

*** Deltas vs. time points 2
**** What does it look like to use \glspl{delta} or \glspl{time point}?
     - Note the use of \clss{Pdefn} to switch the duration pattern independently.
     - New feature: \mth{quant}.
       - Sets the \egls{quantization} time.
       - Here, it guarantees that \cd{Pdefn(\textbackslash dur)} and \ci{\textasciitilde player} can change their patterns only on the bar line.
#+name: timept2
#+caption: Play a rhythm on the previous sound, using deltas.
#+begin_src {SuperCollider} -i
Pdefn(\dur).quant = 4;
Pdefn(\dur, Pseq([1, 0.5, 0.5, 1, 1], inf));

~player.quant = 4;
~player = \psSet -> Pbind(
   \freq, 660, \amp, 1,
   \dur, Pdefn(\dur)
);
#+end_src

*** Deltas vs. time points 3
**** Can you predict the change in rhythm?
#+name: timept2
#+caption: Play a rhythm, using time points.
#+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(Pseq([0, 1, 1.5, 2.5, 3], inf), 4));
#+end_src
**** Which is better?
     - I would use \clss{Pdelta} for a rhythm where the position within the bar is more important.

*** \clss{Pdelta} and barlines				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** \clss{Pdelta} and barlines
A side note: You may skip this for now.

One thing to be careful of when using \clss{Pdelta}: If the very first
time point is not exactly on the barline---that is, if the pattern
should begin with the rest---\clss{Pdelta} does not automatically
compensate.

There are two ways to handle this:

- Start the pattern with an offset from the barline. A
  \gls{quantization} time is a multiple of beats /and/ an offset,
  called \ci{phase}. This is easy in "canonical" style, because you
  can pass the \ci{quant} as an argument when playing the pattern:
  #+begin_src {SuperCollider} -i
x = Pbind(
   ...,
   \dur, Pdelta(Pseq([1.5, 4], inf), 4)
).play(quant: [4, 1.5]);
  #+end_src
  It's somewhat more difficult with proxies, because you have to set
  the quantization time using \cd{quant =}, separate from changing or
  playing the proxy.

- Or, add a rest at the beginning of the pattern. In this example, the
  indentation shows you how the pieces fit together. This duration
  pattern will start at the beginning of the bar, but the first event
  won't do anything because the \clss{Rest} marks the event as a rest.
  #+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(
   Pseq([  // a wrapper for the Rest
      Rest(0),
      Pseq([1.5, 3], inf)  // the real rhythm
   ]),
   4
));
  #+end_src
  If you use this approach, make sure to leave dummy values in the
  other child patterns. That's not an issue in the above example
  because the frequency doesn't change.

** Composition: Data structures
*** Data storage: Collections
**** Data storage is key.
     - SC has a number of \egls{collection} classes.
     - The different collection types save information differently.
     - Each one supports different ways of working.
**** Choosing the right collection makes the task easier.

*** Ordered vs. unordered collections
**** We've seen two collection types already:
     - \clss{Array} :: Items are saved /in order/ and accessed by /number/.
     - \clss{Event} :: Order doesn't matter. Items are accessed by /name/.
**** These reflect the main division among collections:
     - \Gls{ordered} :: You can count on getting items out in the same order you put them in. Good for sequences of information.
     - Unordered :: Very fast to get information by name or check whether an item is already in the collection. But, the order is lost.

*** Note on order					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Wouldn't it make sense to have the order, always?
Actually, no. Certain tasks are faster if the computer can decide the
order of information. In particular, looking up an item by name, and
testing "membership"---seeing if the collection contains a given
item---benefit from the computer choosing the order.

Suppose you have an \clss{Array} of arbitrary names. To find out if
the array contains a particular name, you have to scan all the array
items. If you find the given name, you can stop early, but if you
don't find it---the worst case---you have to touch every array
element. If the array has several thousand items, this could be slow.

SC's unordered collections use a technique called /hash lookup/ to
speed up the process. It's beyond the scope of this workshop to
explain how hash lookup works. But, it means that SC needs to scan
only part of the unordered storage, which is more efficient.

So:
- Use ordered collections when you need to know the sequence.
- Use unordered collections when you need to know that something is
  there, but the order doesn't matter.

*** Doing things with collections
**** What can you do with collections?
     And why would you want to do them?
     - /Transforming/ data is as important as collecting it in the first place.
     - This is how computers can /generate/ musical details.

*** Example: Phrase separation
**** For example: Split a list of pitches into phrases.
     - Suppose, to make it easy, that phrases go up.
     - Split at every downward jump larger than, oh, a third.\\
       A third, in scale degrees, is 2. /Why?/ \pause
     - How do you get a number for the interval between \ci{a} and \ci{b}?\\ \pause
       \cd{b - a} \pause
     - What's the condition for a downward jump more than a third?\\ \pause
       \cd{(b - a) < -2}

*** Array magic for separation
**** \clss{Array} already has a method for this: \mth{separate}.
     - Give it a \clss{Function} for the condition.
     - The function gets two items as \glspl{argument}.\\
       The items are next to each other in the array.
     - The function returns \ci{true} if a split should happen between those items.
#+name: coll1
#+caption: A sequence of rising phrases, split by the separate method.
#+begin_src {SuperCollider} -i
x = [0, 2, 4, 6, 7, 1, 2, 3, 4, 5, 2,
   3, 5, 6, 7, 8, 10, 3, 5, 6, 8,
   9, 10, 4, 5, 6, 7, 8, 9
];

y = x.separate { |a, b| b - a < -2 };
#+end_src

*** So what?
**** What is that good for?
     - Before, we could:
       - Play the notes in the original order (\clss{Pseq});
       - Or play them in random order, breaking phrases:\\
	 \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}.
     - Now, we can play the /phrases/ in any order, but keep each phrase intact.
**** The point:
     /Doing something to the array created a new \textbf{musical} possibility./

*** Choosing the phrases at random
     Note \ci{z}: We can make a \clss{Pseq} for each phrase in advance.
#+name: coll2
#+caption: Play the phrases in random order. Pxrand makes sure the same phrase will not play twice in a row.
#+begin_src {SuperCollider} -i
z = y.collect { |array| Pseq(array, 1) };

~player = Pbind(
   \degree, Pxrand(z, inf),
   \dur, 0.15
);
~player.play;

~player.clear;
#+end_src

*** Things you can do with any collection
**** All collections can do these basic things:
     - \mth{size} :: How many items?
     - \mth{add} :: Add a new item (if ordered, to the end).
     - \mth{remove} :: Remove an item.
     - \mth{removeAll} :: Remove all the given items.
     - \mth{includes} :: Membership test (\ci{true} if the collection has the exact \egls{identical} item).
     - \mth{includesEqual} :: Slightly relaxed membership test (OK if the matching item is \egls{equivalent}, not identical).

*** Note on identity					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the difference between \egls{identical} vs. \egls{equivalent}, and why does it matter?
\eGls{identical} refers to the same exact object, while
\egls{equivalent} refers to separate objects that happen to have the
same value, or the same contents.

It might seem strange to speak of objects being "identical." If there
can be only one object with a particular identity, how could you
compare it to something else? Wouldn't the comparison always end up
\ci{false}?

Checking identity is meaningful because you can have several
/references/ to the same object: one object, held in several variables
or several collection items. Here, we put an array into \ci{x}, and
then assign the same array into \ci{y}. The \ci{===} test shows that
they are identical. They are not /separate/ arrays with the same
contents. Both variables refer to one and the same array. Because both
variables point to the same place, a change to \ci{x} will also appear
in \ci{y}---because, as far as the array is concerned, it doesn't
matter whether you call it \ci{x} or \ci{y} or \ci{stupidArray}. Its
contents have changed, and /any/ variable referring to that array will
see the change.

#+begin_src {SuperCollider} -i
x = [0, 1, 2];
y = x;

y === x;  // identical

x.put(1, 10);
y;  // prints: [ 0, 10, 2 ]
#+end_src

This is, in fact, a common mistake when creating arrays of arrays
(that is, rows and columns). In this example, all three "rows" are
identical arrays---so, you can't modify any row's contents without
also changing /every/ row.

#+begin_src {SuperCollider} -i
x = Array.fill(3, [0, 1, 2]);

x[0] === x[1];  // identical
#+end_src

The solution is to use a function with \cd{Array.fill}. /Get in the
habit \textbf{now} of using functions here!/ Forgetting the function
@@latex:\cd{\{ \}}@@ is one of /the/ most common mistakes.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x[0] === x[1];  // NOT identical
x[0] == x[1];  // equivalent
#+end_src

Why not simplify, and just test equivalence for everything? The reason
is that checking identity is faster. Speed is important when looking
up items by name in an \clss{Event}, \clss{IdentityDictionary} or
\clss{ProxySpace}, because /many/ comparisons are needed.

For membership testing:

- If the items are \clsspl{Symbol} or \cd{Integers}, you can use
  \mth{includes}. Also, \clss{IdentitySet} is faster for lookup, and
  these types are valid keys in an \clss{IdentityDictionary}.
- Any other types within a collection---\clss{String}, \cd{Float},
  other collections---should check membership by
  \mth{includesEqual}. Use \clss{Set} or \clss{Dictionary}.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x.includes([0, 1, 2]);  // FALSE b/c not identical
x.includesEqual([0, 1, 2]);  // TRUE
#+end_src

*** Looping operations on collections
     All these take a function with arguments \cd{|item, index|}.
     - \mth{do} :: Do something to each item; don't keep results.
     - \mth{collect} :: Do something to each item; keep the results in a new collection.
     - \mth{select} :: Make a new collection, with the items that satisfy the condition in the function.
     - \mth{reject} :: Like \mth{select}, but keeps the items that fail the condition.
     - \mth{count} :: How many items satisfy a condition?
     - \mth{sum} :: Add up the items; the optional function can calculate new values.

*** Collection looping examples
**** Can you imagine musical uses for these?
     Try them one by one, and try to explain the results.
#+name: coll2
#+caption: Examples of looping operations on collections.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
(
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
)
x.select { |item| item > 4 };
x.reject { |item| item > 4 };
x.maxItem;

x = ["An", "array", "of", "strings"];
x.count { |item| item.size > 3 };
x.sum { |item| item.size };
x.maxItem { |item| item.size };
#+end_src

*** Musical uses						   :noexport:

*** Things you can do with ordered collections
**** \Gls{ordered} collections can address items by number.
     - \mth{at} :: Get the item at a given number. Shortcut: \cd{array[1]} $\to$ \cd{array.at(1)}.
     - \mth{put} :: Put a new item into the numbered slot. Shortcut: \cd{array[1] = 5} $\to$ \cd{array.put(1, 5)}.
     - \mth{removeAt} :: Remove the item at the given index.
     - \mth{insert} :: Insert a new item at the index, pushing the other items to the right.
     - \mth{++} :: Join two arrays into one.
     - \mth{pairsDo} :: Like \mth{do}, but takes the items in groups of two.
     - \mth{doAdjacentPairs} :: See the example.

*** Ordered collection examples
#+name: coll3
#+caption: Examples of useful array operations.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
x[3]
x[3] = 22;
x.removeAt(3); x
x = x.insert(3, 22);
x ++ [55, 48, 60];
x.pairsDo { |a, b| "%: %\n".postf(a, b) };
(
x.doAdjacentPairs { |a, b|
   "% - % = %\n".postf(b, a, b - a)
};
)
#+end_src

*** Unordered collections: Dictionaries
**** \clsspl{Dictionary} store \clsspl{Association}.
     - Association: \cd{key -> value}.
       - The \egls{key} is the identifier, used to access the items.
       - Very often, the key is a name, written as a \clss{Symbol}: \cd{\textbackslash name}.
**** Array-indexing methods work with dictionaries.
     The \mth{at}, \mth{put} and \mth{removeAt} methods take the
     \egls{key} as the argument, instead of a number.

*** Dictionary types
    - \clss{Dictionary} :: Looks up \egls{equivalent} keys. \clsspl{String} and \clsspl{Array} are valid keys.
    - \clss{IdentityDictionary} :: Looks up \egls{identical} keys. \clsspl{Symbol} and \ci{Integers} are valid keys.
    - \clss{Environment} :: The current environment provides storage for \ci{\textasciitilde environmentVars}.
    - \clss{Event} :: An \clss{Environment} that can be \mth{play}ed.
**** You'll probably use \clss{Event} most often.
     Nice shortcut syntax: \cd{(key: value, key1: value1...)}.

*** Dictionary methods
**** Key-value storage calls for some other methods.
     - \mth{keys} :: All the unique keys in this dictionary.
     - \mth{values} :: An array of the values, without keys.
     - \mth{keysValuesDo} :: Like \mth{do}, but the function arguments are \cd{|key, value, counter|}.
**** Minor difference in filtering methods..
     - \mth{collect}, \mth{select}, \mth{reject}.
     - Arguments passed to the function are \cd{|value, key|}.
     - Why the value first?\\
       To be consistent. The value comes first in all the other \mth{collect} variants.

*** Dictionary examples

    Note the use of \clss{Pdict}, to embed patterns by name.
#+name: coll4
#+caption: A useful Dictionary trick: Naming subpatterns for sequencing.
#+begin_src {SuperCollider} -i
d = (
   mel1: [0, 7, 3, 4, 6, 7],
   mel2: [9, 7, 6, 4, 3],
   mel3: [3.9, 4, 6, 3, 2]
);

// preserves the keys
e = d.collect { |array| Pseq(array, 1) };

e.keysValuesDo { |key, value| [key, value].postcs }; ""

q = Pbind(
   \degree, Pdict(e, Pxrand([\mel1, \mel2, \mel3], inf)),
   \dur, Pwhite(1, 3, inf) * 0.15,
   \scale, Scale.aeolian,
   \root, 11, \octave, 3
).play;

q.stop;
#+end_src
*** Unordered collections: Sets
**** Sets may not contain any duplicated items.
     - \clss{Set}: No \egls{equivalent} items.
     - \clss{IdentitySet}: No \egls{identical} items.
**** \clss{Set} and \clss{IdentitySet} are good for:
     - Checking membership: Does the set have this item?\\
       \clsspl{Set} can search quickly.
     - Avoiding duplicates:
       - What are the unique \glspl{pitch class} in a group of notes?
       - What items are in common between two sets?
       - What items exist in only one of the two sets?

*** Unordered collections: Set methods
    \mth{add}, \mth{remove}, \mth{do} etc. work as in other collections.
    - \mth{sect} :: Intersection (common items: items in setA /and/ setB). Shortcut: \cd{setA \& setB}.
    - \mth{union} :: Union: items in setA /or/ setB, or both. Shortcut: \cd{setA | setB}.
    - \mth{difference} :: Items in setA that are /not/ in setB. Shortcut: \cd{setA - setB}.
    - \mth{symmetricDifference} :: Items in only one of the two, but not both. Shortcut: \cd{setA -- setB}.

*** Unordered collections: Set examples
#+name: coll5
#+caption: Examples of useful array operations.
#+begin_src {SuperCollider} -i
x = [59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68];

// unique pitch classes
y = IdentitySet.new;  // OK b/c Integers
x.do { |item| y.add(item % 12) };
y;  // 5 items only: duplicates ignored
z = IdentitySet[11, 1, 2, 4, 6, 7, 9];  // b minor

// which notes in y belong to a b minor scale?
y & z;

// which notes in y are *not* in b minor?
y - z;

// which notes are in either y or z, not both?
y -- z;
#+end_src

** Composition: Control structures

** Composition: Combining patterns

* Considerations for group composition				   :noexport:
** Unity and contrast

* External control						   :noexport:
** Buttons and faders
** Receiving
** Central hub
** Turning faders into buttons: Thresholds
* Footnotes

[fn:1] Twelve-note \gls{equal temperament}.
