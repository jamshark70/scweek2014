#+startup: beamer

* Test
** Test
*** Test
#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

* Granular synthesis
** Granular synthesis parameters
*** Granular synthesis: Extremely powerful
**** Many common effects are based on \egls{granular} synthesis.
     - Notably, time stretching and pitch shifting.
     - Also good for long, complex drones.
**** A form of /microsound/.
     - Typically, sounds between 10 and 100 ms duration.
     - Rhodes, Curtis (2001). /Microsound/.

*** What is granular synthesis?
**** \eGls{granular} synthesis composes sounds from clouds of very short \eglspl{grain}.
     - When you have enough grains, you hear only the cloud.
     - As in these graphics: The more grains, the harder to see the individuals.
#+begin_center
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains100.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains200.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains500.png]]
#+end_center

*** Characteristics of grains and clouds
**** Important things about a \gls{grain}:
     - *Duration:* How long it is.
     - *Envelope:* Its shape.\\
       Sine-shaped envelopes work especially well.
     - *Spectral content.* Usually comes from sampled audio in a \clss{Buffer}.
**** Important things about grain clouds:
     - *Overlap:* How many grains simultaneously. (May vary.)
     - *Time distribution:* Are the grains evenly spaced in time?

*** Sine-shaped envelopes
**** Sine envelopes work well because they are complementary.
     - /Complementary/: Add them together, with the right offset, and you get a constant.
     - So, the individual envelopes blend together into a consistent volume.
#+begin_center
#+attr_latex: :height 1.5in
[[../03-control/img/sinusoidal-envelopes.png]]
#+end_center

*** Start simple: Individual grains
**** \Gls{granular} UGens have a number of parameters.
     - If we do too many at once, it's confusing.
**** Parameters needed for single \glspl{grain}:
     - *Trigger:* We'll use \ugen{Impulse}, controlled by frequency.
     - *Duration*.
     - *Position* within the buffer: for now, in seconds.
#        , as a \egls{normalize}\emph{d} range.
#        - 0 = buffer start, 1 = buffer end.
#        - Why? \Glspl{Buffer} may be of different sizes.
#        - If it's normalized, the position input can be the same for any buffer.

*** TGrains UGen
**** Basic granulator: \ugen{TGrains}.
     - You can control trigger frequency, grain duration and buffer position.
     - Raise the trigger frequency until the grains blend together.
#+name: grain1
#+caption: Granular synthesis: first step.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~grains.addSpec(\tfreq, [1, 20, \exp]);
~grains.addSpec(\pos, [0, b.duration]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, pos = 0.5,
   amp = 0.2|
   var trig = Impulse.ar(tfreq);
   GrainBuf.ar(2, trig, graindur, b, 1, pos, 2, pan) * amp;
};
~grains.play;
)

p.gui;  // if it's not already open
#+end_src

*** Automating buffer position
**** Let's move forward through the buffer.
     Constant rate---what do you think will be the result?
**** Replace the \ci{pos} argument with a \ugen{Phasor}.
     - \ugen{Phasor} is a looping line segment, with a rate control.
     - \ci{rate} is in units per sample.\\
       At audio rate, \cd{rate = 1} will increase by 44100 in one second.
     - We want to increase by 1.0 per second.\\
       See \ugen{SampleDur}, which outputs $\frac{1}{samplerate}$.
     - What's the upper boundary?\\
       \Gls{Buffer} duration: \cd{b.duration} or \ugen{BufDur}\cd{.kr(b)}.
**** Exercise for you: Write the \ugen{Phasor}.
# #+name: grain2
# #+caption: Use a Phasor to move through the buffer in real time.
#+begin_src {SuperCollider} -i :exports none
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.2|
   var trig = Impulse.ar(tfreq),
   pos = Phasor.ar(0, SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, pos, graindur, pan, amp)
};
#+end_src

*** Speed of buffer movement
**** What if we move through the buffer at different speeds?
     - Add a new argument, \ci{speed}.
     - Set its range, using \mth{addSpec}, to \cd{[0.25, 4, \textbackslash exp]}.
     - How to incorporate \ci{speed} into the \ugen{Phasor}?\\
       *Hint:* \ci{speed} should /scale/ (multiply) the \ugen{Phasor} rate that is already there.
**** Exercise: Write this yourself.
     What is the result?
# #+name: grain3
# #+caption: Adjust the buffer movement speed by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\speed, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain rate
**** What about the \ci{rate} argument in \ugen{TGrains}?
     - We adjusted the \ugen{Phasor} rate, and got a time effect.
     - What do you think \ugen{TGrains}'s rate will do?
**** Let's find out: Write the change yourself.
     - Add a new \ci{rate} argument.
     - Give it a similar exponential range.
     - Plug it into \ugen{TGrains}.
# #+name: grain4
# #+caption: Adjust the grain playback rate by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\rate, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   rate = 1, speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, rate, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain duration vs. overlap
**** Sometimes better to control how many overlapping \glspl{grain}.
     - That is, adjust the grain duration along with trigger frequency.
     - If you want 4 overlapping grains, and 1 trigger/sec, how long should each grain be?\pause\\
       4 seconds.\pause
     - If you have 2 triggers/sec, how long should the grains be?\pause\\
       2 seconds.\pause
     - What, then, is the formula?\pause\\
       \cd{overlap / trigfreq}\pause
**** Exercise, on your own time:
     Edit the synth to use an \ci{overlap} argument instead of \ci{graindur}.

*** Summary: Granular synthesis parameters
**** \Gls{granular} synthesis gives you independent control over:
     - Time (buffer position's rate of change);
     - Pitch (playback rate of each \gls{grain});
     - Continuity (frequency of triggers, grain duration, overlap).
**** Tone color comes from whatever is in the buffer.

** Usage of granular synthesis
*** Sustaining sounds
**** Sustaining sounds need:
     - Fast grain triggers;
     - Relatively high overlap (at least 5).
#      If the trigger frequency, buffer position and grain rate are all constant, then you hear sonic features repeating exactly.
#+name: grain5
#+caption: Granular synthesis, sustaining sound, with constant triggers, buffer position and grain rate.
#+begin_src {SuperCollider} -i
p.clear;

~grains.addSpec(\tfreq, [1, 40, \exp]);
~grains.addSpec(\overlap, [0.1, 10, \exp]);
~grains.addSpec(\pos, [0, b.duration]);  // 3.43 is nice!
~grains.addSpec(\rate, [0.5, 2, \exp]);
~grains = { |tfreq = 25, overlap = 6, pan = 0, amp = 0.2, pos = 3.43,
   rate = 1|
   var trig = Impulse.ar(tfreq);
   TGrains.ar(2, trig, b, rate, pos, overlap / tfreq, pan, amp)
};
~grains.play;
#+end_src

*** Solution: Randomize
**** It sounds boring because the pattern is too obvious.
     - The ear latches onto the repeating features, not the sustained feel.
     - So, break up the pattern by adding a small random offset.
**** Add random \egls{LFO} modules.
     - \ugen{LFNoise1} is good for random numbers.
     - The LFO module should convert to the right range (as we covered earlier).
     - Then, modulate the input within \ci{\textasciitilde grains}.

*** Randomize buffer position
**** What's a good range?
     - A random range in seconds is OK.
     - You don't need much: 0.1--0.2 seconds is enough.
**** Exercises for you:
     1. Write an \gls{LFO} module with \ugen{LFNoise1}:
	- Fairly high frequency (at least 50).
	- Include an argument for the amount of modulation, ranging 0--maximum seconds.
	- Give that argument an appropriate range spec.
     2. Edit \ci{\textasciitilde grains} to apply the LFO.
     3. Adjust the LFO amount and listen to the different effects.

*** Randomize grain playback rate
**** What's a good range?
     - \ci{rate} is a multiplier---so the range should be \egls{exponential}.
     - Do you remember how to convert to an exponential range?
     - You need only a few cents (cent = 0.01 semitone).
     - The ratio for 1 cent = 1.0005777895066.\\
       \cd{0.01.midiratio}
     - 20 cents = \cd{0.2.midiratio} = 1.0116194403019.
**** Exercises for you.
     Same as for buffer position, except with a different range, and exponential usage.

*** Small vs. large scale modulation
**** You can also combine two kinds of modulation:
     - Small range, fast modulation.
     - Larger range, slower modulation.
**** For instance, moving through a buffer.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.6
     :END:
     - \ugen{Phasor} in a straight line.
     - \ugen{LFNoise1}, low amplitude.
     - It still sounds like moving through the buffer, but with some variation.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.4
     :END:
     #+begin_center
     #+attr_latex: :height 1in
     [[../03-control/img/randomized-line.png]]
     #+end_center

*** Glitchy sounds
**** Glitchy sounds also use random \glspl{LFO}, but wider range.
     - Take grains from any part of the buffer at any time.
     - Much shorter \ci{graindur} (can randomize this too).\\
       When dur < 0.015, the envelope changes the tone color!
     - Also, randomize the time between triggers (e.g., \ugen{Dust}).
     - See also the \ugen{GrainBuf} UGen.\\
       Allows you to choose a different envelope. Percussive envelopes can be really noisy!
**** Exercises: Edit the granular synth to try these techniques.

*** Granulating live input
**** What if you want to do this on a real-time signal?
     - Tricky if you want to play it faster than real time.
       - Grain rate > 1.
       - Buffer movement speed > 1.
     - Much slower is also a problem.
**** Shortcut: \ugen{PitchShift} UGen.
     - Can raise or lower pitch of a live signal up to two octaves.
**** Using \clsspl{Buffer} and \ugen{TGrains}:
     - Beyond the scope of this class.

*** Summary: Synthesis techniques
**** Techniques:
     - Subtractive synthesis ("analog"): \egls{oscillator} $\to$ \egls{filter}.
     - Frequency modulation: \egls{modulator} $\to$ \egls{carrier}.
     - Granular synthesis: Clouds of short, enveloped \eglspl{grain}.
**** Next steps:
     - Build more complex, compositional patterns.
     - Bring external control data into SC, and plug into synthesis and composition parameters.

* External control
** Basic concepts
*** Custom interfaces
**** So far, we have used the built-in \ci{ProxyMixer}.
    This is a good, general-purpose interface, but not ideal for every performance need.
**** A few fundamentals can get you started making your own interfaces.
     - Display only the controls that you need.
     - Put them in a layout that makes sense visually.
**** The concepts to do this are preparation for mobile interfaces.

*** Main concepts
**** By far, the most important concept is \egls{callback}.
     - User interaction needs to "call back" into your code.
     - GUI, MIDI, OSC, HID interfaces all depend on this idea.
**** Other concepts
     - View :: A general term for a GUI widget.
     - Spec :: A \clss{ControlSpec}, mapping a control onto a range of values.
     - Layout :: An automated way to position views in a window.

*** A simple slider
**** Let's control pitch with a \clss{Slider}.
     - The example makes a simple sound, and puts a slider on screen.
     - The slider is not connected to anything yet.
     - Note that the slider's first argument is \ci{nil}.\\
       This is a shortcut to make a window for the slider automatically.
#+name: gui1
#+caption: A simple sound, and a slider that will control it (but not yet).
#+begin_src {SuperCollider} -i
p = ProxySpace.new.push;

~sound = { |freq = 440, amp = 0.1|
   VarSaw.ar(freq, 0, 0.5, amp).dup
};
~sound.play;

z = Slider(nil, Rect(600, 200, 200, 20)).front;
#+end_src

*** Controlling pitch
**** To connect the slider to the frequency:
     1. A \egls{callback} function:\\
	When the user moves the slider, set the frequency.
     2. Convert the slider's range to frequency.\\
	Sliders always run 0.0--1.0. Use a \clss{ControlSpec} to convert.\\
	\cd{y.map} takes in 0.0--1.0, puts out a value matching the spec's range.
#+name: gui2
#+caption: Plug the slider into the frequency input.
#+begin_src {SuperCollider} -i
y = ControlSpec(110, 880, \exp);

z.action = { |sl|
   ~sound.set(\freq, y.map(sl.value));
};
#+end_src

*** An "EZ"-er way
**** The *EZ* GUI objects do the range mapping for you.
     See their help files: Start with \ci{EZSlider}.\\
     Close the old slider window, then do this.\\<all>
     Also introducing \clss{Window}.\\
     When you make your own window, you can put more things in it.
#+name: gui3
#+caption: EZSlider: Much easier to map an on-screen control to a range of useful values.
#+begin_src {SuperCollider} -i
w = Window("window name", Rect(600, 200, 300, 120));
z = EZSlider(w,
   bounds: Rect(5, 5, 290, 20),
   label: "freq",
   controlSpec: [110, 880, \exp],  // short form OK
   // no need for 'map' in the action!
   action: { |view| ~sound.set(\freq, view.value) },
   initVal: 440
);
w.front;
#+end_src

*** Note on Window bounds				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Why is the window near the bottom?
This is a strange behavior left over from the original OSX
SuperCollider application. The Apple (Cocoa) GUI objects put 0 at the
bottom of the screen. The coordinates for the screen's height is at
the top. Now SuperCollider uses Qt objects for drawing, because they
work on all supported operating systems (not only Mac). The SC Qt
objects keep this "upside down" behavior, so that older code will
still put the windows in the same place.

Inside a window, $y = 0$ is the top of the frame, and $y$ increases as
you go down. This is also true if you make a GUI object without a
window, as in Listing [[gui1]]. But, when you make a \clss{Window}, you
have to remember that the "top" coordinate in the boundary \clss{Rect}
is actually the window's /bottom/, and it's measured from the bottom
of the screen.

Weird, but that's the way it is.

*** Buttons and faders
**** Only two kinds of user-interface objects:[fn:6607d9b8]
     - Faders :: Represent a range of values. Sliders, knobs, 2D canvases are all faders.
     - Buttons :: Represent a momentary trigger.
**** dummy						    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     - Faders are good for values, especially moving continuously up and down the range.
     - Buttons are good for starting and stopping actions.
     - When we get into mobile control, we will see how to make a fader act like a button.

*** SC Button interface
**** SC's \clss{Button} is /multi-state/.
     - It can cycle through different labels and actions.
     - "Playing" and "stopped" are two states.
     - Each state is an array:\\
       \cd{[label, textColor, backgroundColor]}.
#+name: gui4
#+caption: Add a button into the same window. Note the coordinates, and the syntax to set several properties at once.
#+begin_src {SuperCollider} -i
b = Button(w, Rect(5, 30, 290, 30))
.states_([
   ["stopped", Color.black, Color.gray(0.8)],
   ["playing", Color.black, Color.green]
])
.action_({ |view|
   if(view.value == 1) {
      ~sound.play;
   } {
      ~sound.stop;
   };
});
#+end_src

* Not yet							   :noexport:
** Receiving
** Central hub
** Turning faders into buttons: Thresholds

* Toward complex composition
** Simple ideas
*** The trick
**** The trick to making music by programming:
**** quote							    :B_quote:
     :PROPERTIES:
     :BEAMER_env: quote
     :END:
     A simple idea by itself is boring.\\<all>
     Lots of simple ideas working together make music.

*** Workflow
**** A typical way to develop interesting musical element:
     1. Start with a basic idea of this element's role in the piece.
     2. Write a simple synth and/or pattern that seems related.
     3. Listen carefully. What is missing from the simple idea?\\
	Think of /small/ adjustments.
     4. Write a new component:
	- A second or third \gls{oscillator} (or \gls{granular} node);
	- An \gls{LFO} or \gls{envelope} module to control some parameter;
	- A more complex child pattern in \clss{Pbind};
	- Another GUI or external control.
     5. Go back to step 3.

*** Experience
**** That almost makes it sound easy...
     /Experience/ is what's missing from that picture.
     - What techniques work for what kinds of sounds?\\
       E.g., FM synthesis with ratio = 0.5 makes great basslines.
     - *Dos* and *don'ts* of modulation.
     - When to control an input by \clss{Pbind} vs. modulation units?
**** No way to learn, except to /try/ and /make mistakes/.
     Here in the workshop, I can help steer you in the right direction.

*** Try it together, as a group
**** Let's take 20--40 minutes to do this as a group.
     Questions to get you started thinking:
     - What kind of sound or texture do you want?\\
       Pitched or noisy? High, low or middle frequencies?
     - What kind of musical behavior?\\
       Rhythmic or not? Tonal or not?
     - Any sound effect you heard somewhere, that we can try?
**** If none of those spark any ideas---
     - Which synthesis technique would you like to explore more?

*** Working...
#+begin_center
Switch over to SuperCollider and start building...
#+end_center

** Composition: Representing musical information
*** Data representation
**** Composition depends on /representing musical information/.
     - Western notation: Notes and rhythms.\\
       Assumes 12 notes per octave, double or triple divisions of time.
     - Logic or Cubase "piano roll" view: Similar assumptions.\\
       Time is more flexible.
**** Both of these assume a beginning-to-end sequence.
     - In SC, we don't have to follow that rule!
     - We have more choices to store useful information.

*** Representing pitch
**** Recall \clsspl{Event}, and three ways to write pitch.
     - \ci{\textbackslash freq} in Hz.
     - \ci{\textbackslash midinote} in MIDI note numbers.\\
       Converted to Hz according to 12-ET.[fn:03ac80c1]
     - \ci{\textbackslash degree} in scale degrees.\\
       - Converted to \ci{\textbackslash midinote} based on \ci{\textbackslash scale}, \ci{\textbackslash root} and \ci{\textbackslash octave}.
       - \ci{b} and \ci{s} modifiers: \cd{4s} means degree 4, sharped. \ci{b} is flat.
**** If you're using pitch, decide which one best fits the material.

*** Representing rhythm
**** Usually in \eglspl{beat}.
     - \clsspl{TempoClock} run in beats.
     - \Gls{delta} time = 1 means the next event is one beat later.
     - You can change the tempo.
**** Sometimes useful to write rhythm as \eglspl{time point} within the bar.
     - Often useful for drum rhythms.
     - See also Milton Babbitt's "time-point sets."\\
       [[http://en.wikipedia.org/wiki/Time_point]]
     - \clss{Pdelta} converts a pattern of time points into deltas.

*** Deltas vs. time points 1
**** First we need a sound to play.
     Questions for you:
     - Can you guess what it will sound like, from reading the code?
     - Does it make sound right away? Why or why not?
     - How would you make it sound on demand?
#+name: timept1
#+caption: A quick-and-dirty sound to trigger in rhythm.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

~sound = { |t_trig, freq = 660, amp = 0.1|
   var sig = PinkNoise.ar(amp),
   eg = EnvGen.kr(Env.perc(0.01, 0.2), t_trig);
   sig = BPF.ar(sig, freq, 0.1);
   (sig * eg).dup
};
~sound.play;
#+end_src

*** Deltas vs. time points 2
**** What does it look like to use \glspl{delta} or \glspl{time point}?
     - Note the use of \clss{Pdefn} to switch the duration pattern independently.
     - New feature: \mth{quant}.
       - Sets the \egls{quantization} time.
       - Here, it guarantees that \cd{Pdefn(\textbackslash dur)} and \ci{\textasciitilde player} can change their patterns only on the bar line.
#+name: timept2
#+caption: Play a rhythm on the previous sound, using deltas.
#+begin_src {SuperCollider} -i
Pdefn(\dur).quant = 4;
Pdefn(\dur, Pseq([1, 0.5, 0.5, 1, 1], inf));

~player.quant = 4;
~player = \psSet -> Pbind(
   \freq, 660, \amp, 1,
   \dur, Pdefn(\dur)
);
#+end_src

*** Deltas vs. time points 3
**** Can you predict the change in rhythm?
#+name: timept2
#+caption: Play a rhythm, using time points.
#+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(Pseq([0, 1, 1.5, 2.5, 3], inf), 4));
#+end_src
**** Which is better?
     - I would use \clss{Pdelta} for a rhythm where the position within the bar is more important.

*** \clss{Pdelta} and barlines				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** \clss{Pdelta} and barlines
A side note: You may skip this for now.

One thing to be careful of when using \clss{Pdelta}: If the very first
time point is not exactly on the barline---that is, if the pattern
should begin with the rest---\clss{Pdelta} does not automatically
compensate.

There are two ways to handle this:

- Start the pattern with an offset from the barline. A
  \gls{quantization} time is a multiple of beats /and/ an offset,
  called \ci{phase}. This is easy in "canonical" style, because you
  can pass the \ci{quant} as an argument when playing the pattern:
  #+begin_src {SuperCollider} -i
x = Pbind(
   ...,
   \dur, Pdelta(Pseq([1.5, 4], inf), 4)
).play(quant: [4, 1.5]);
  #+end_src
  It's somewhat more difficult with proxies, because you have to set
  the quantization time using \cd{quant =}, separate from changing or
  playing the proxy.

- Or, add a rest at the beginning of the pattern. In this example, the
  indentation shows you how the pieces fit together. This duration
  pattern will start at the beginning of the bar, but the first event
  won't do anything because the \clss{Rest} marks the event as a rest.
  #+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(
   Pseq([  // a wrapper for the Rest
      Rest(0),
      Pseq([1.5, 3], inf)  // the real rhythm
   ]),
   4
));
  #+end_src
  If you use this approach, make sure to leave dummy values in the
  other child patterns. That's not an issue in the above example
  because the frequency doesn't change.

** Composition: Data structures
*** Data storage: Collections
**** Data storage is key.
     - SC has a number of \egls{collection} classes.
     - The different collection types save information differently.
     - Each one supports different ways of working.
**** Choosing the right collection makes the task easier.

*** Ordered vs. unordered collections
**** We've seen two collection types already:
     - \clss{Array} :: Items are saved /in order/ and accessed by /number/.
     - \clss{Event} :: Order doesn't matter. Items are accessed by /name/.
**** These reflect the main division among collections:
     - \Gls{ordered} :: You can count on getting items out in the same order you put them in. Good for sequences of information.
     - Unordered :: Very fast to get information by name or check whether an item is already in the collection. But, the order is lost.

*** Note on order					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Wouldn't it make sense to have the order, always?
Actually, no. Certain tasks are faster if the computer can decide the
order of information. In particular, looking up an item by name, and
testing "membership"---seeing if the collection contains a given
item---benefit from the computer choosing the order.

Suppose you have an \clss{Array} of arbitrary names. To find out if
the array contains a particular name, you have to scan all the array
items. If you find the given name, you can stop early, but if you
don't find it---the worst case---you have to touch every array
element. If the array has several thousand items, this could be slow.

SC's unordered collections use a technique called /hash lookup/ to
speed up the process. It's beyond the scope of this workshop to
explain how hash lookup works. But, it means that SC needs to scan
only part of the unordered storage, which is more efficient.

So:
- Use ordered collections when you need to know the sequence.
- Use unordered collections when you need to know that something is
  there, but the order doesn't matter.

*** Doing things with collections
**** What can you do with collections?
     And why would you want to do them?
     - /Transforming/ data is as important as collecting it in the first place.
     - This is how computers can /generate/ musical details.

*** Example: Phrase separation
**** For example: Split a list of pitches into phrases.
     - Suppose, to make it easy, that phrases go up.
     - Split at every downward jump larger than, oh, a third.\\
       A third, in scale degrees, is 2. /Why?/ \pause
     - How do you get a number for the interval between \ci{a} and \ci{b}?\\ \pause
       \cd{b - a} \pause
     - What's the condition for a downward jump more than a third?\\ \pause
       \cd{(b - a) < -2}

*** Array magic for separation
**** \clss{Array} already has a method for this: \mth{separate}.
     - Give it a \clss{Function} for the condition.
     - The function gets two items as \glspl{argument}.\\
       The items are next to each other in the array.
     - The function returns \ci{true} if a split should happen between those items.
#+name: coll1
#+caption: A sequence of rising phrases, split by the separate method.
#+begin_src {SuperCollider} -i
x = [0, 2, 4, 6, 7, 1, 2, 3, 4, 5, 2,
   3, 5, 6, 7, 8, 10, 3, 5, 6, 8,
   9, 10, 4, 5, 6, 7, 8, 9
];

y = x.separate { |a, b| b - a < -2 };
#+end_src

*** So what?
**** What is that good for?
     - Before, we could:
       - Play the notes in the original order (\clss{Pseq});
       - Or play them in random order, breaking phrases:\\
	 \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}.
     - Now, we can play the /phrases/ in any order, but keep each phrase intact.
**** The point:
     /Doing something to the array created a new \textbf{musical} possibility./

*** Choosing the phrases at random
     Note \ci{z}: We can make a \clss{Pseq} for each phrase in advance.
#+name: coll2
#+caption: Play the phrases in random order. Pxrand makes sure the same phrase will not play twice in a row.
#+begin_src {SuperCollider} -i
z = y.collect { |array| Pseq(array, 1) };

~player = Pbind(
   \degree, Pxrand(z, inf),
   \dur, 0.15
);
~player.play;

~player.clear;
#+end_src

*** Things you can do with any collection
**** All collections can do these basic things:
     - \mth{size} :: How many items?
     - \mth{add} :: Add a new item (if ordered, to the end).
     - \mth{remove} :: Remove an item.
     - \mth{removeAll} :: Remove all the given items.
     - \mth{includes} :: Membership test (\ci{true} if the collection has the exact \egls{identical} item).
     - \mth{includesEqual} :: Slightly relaxed membership test (OK if the matching item is \egls{equivalent}, not identical).

*** Note on identity					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the difference between \egls{identical} vs. \egls{equivalent}, and why does it matter?
\eGls{identical} refers to the same exact object, while
\egls{equivalent} refers to separate objects that happen to have the
same value, or the same contents.

It might seem strange to speak of objects being "identical." If there
can be only one object with a particular identity, how could you
compare it to something else? Wouldn't the comparison always end up
\ci{false}?

Checking identity is meaningful because you can have several
/references/ to the same object: one object, held in several variables
or several collection items. Here, we put an array into \ci{x}, and
then assign the same array into \ci{y}. The \ci{===} test shows that
they are identical. They are not /separate/ arrays with the same
contents. Both variables refer to one and the same array. Because both
variables point to the same place, a change to \ci{x} will also appear
in \ci{y}---because, as far as the array is concerned, it doesn't
matter whether you call it \ci{x} or \ci{y} or \ci{stupidArray}. Its
contents have changed, and /any/ variable referring to that array will
see the change.

#+begin_src {SuperCollider} -i
x = [0, 1, 2];
y = x;

y === x;  // identical

x.put(1, 10);
y;  // prints: [ 0, 10, 2 ]
#+end_src

This is, in fact, a common mistake when creating arrays of arrays
(that is, rows and columns). In this example, all three "rows" are
identical arrays---so, you can't modify any row's contents without
also changing /every/ row.

#+begin_src {SuperCollider} -i
x = Array.fill(3, [0, 1, 2]);

x[0] === x[1];  // identical
#+end_src

The solution is to use a function with \cd{Array.fill}. /Get in the
habit \textbf{now} of using functions here!/ Forgetting the function
@@latex:\cd{\{ \}}@@ is one of /the/ most common mistakes.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x[0] === x[1];  // NOT identical
x[0] == x[1];  // equivalent
#+end_src

Why not simplify, and just test equivalence for everything? The reason
is that checking identity is faster. Speed is important when looking
up items by name in an \clss{Event}, \clss{IdentityDictionary} or
\clss{ProxySpace}, because /many/ comparisons are needed.

For membership testing:

- If the items are \clsspl{Symbol} or \cd{Integers}, you can use
  \mth{includes}. Also, \clss{IdentitySet} is faster for lookup, and
  these types are valid keys in an \clss{IdentityDictionary}.
- Any other types within a collection---\clss{String}, \cd{Float},
  other collections---should check membership by
  \mth{includesEqual}. Use \clss{Set} or \clss{Dictionary}.

#+begin_src {SuperCollider} -i
x = Array.fill(3, { [0, 1, 2] });

x.includes([0, 1, 2]);  // FALSE b/c not identical
x.includesEqual([0, 1, 2]);  // TRUE
#+end_src

*** Looping operations on collections
     All these take a function with arguments \cd{|item, index|}.
     - \mth{do} :: Do something to each item; don't keep results.
     - \mth{collect} :: Do something to each item; keep the results in a new collection.
     - \mth{select} :: Make a new collection, with the items that satisfy the condition in the function.
     - \mth{reject} :: Like \mth{select}, but keeps the items that fail the condition.
     - \mth{count} :: How many items satisfy a condition?
     - \mth{sum} :: Add up the items; the optional function can calculate new values.

*** Collection looping examples
**** Can you imagine musical uses for these?
     Try them one by one, and try to explain the results.
#+name: coll2
#+caption: Examples of looping operations on collections.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
(
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
)
x.select { |item| item > 4 };
x.reject { |item| item > 4 };
x.maxItem;

x = ["An", "array", "of", "strings"];
x.count { |item| item.size > 3 };
x.sum { |item| item.size };
x.maxItem { |item| item.size };
#+end_src

*** Musical uses						   :noexport:

*** Things you can do with ordered collections
**** \Gls{ordered} collections can address items by number.
     - \mth{at} :: Get the item at a given number. Shortcut: \cd{array[1]} $\to$ \cd{array.at(1)}.
     - \mth{put} :: Put a new item into the numbered slot. Shortcut: \cd{array[1] = 5} $\to$ \cd{array.put(1, 5)}.
     - \mth{removeAt} :: Remove the item at the given index.
     - \mth{insert} :: Insert a new item at the index, pushing the other items to the right.
     - \mth{++} :: Join two arrays into one.
     - \mth{pairsDo} :: Like \mth{do}, but takes the items in groups of two.
     - \mth{doAdjacentPairs} :: See the example.
     - \mth{sort} :: Arrange the items in ascending or descending order. *In-place:* modifies the array.

*** Ordered collection examples
#+name: coll3
#+caption: Examples of useful array operations.
#+begin_src {SuperCollider} -i
x = (0..9).scramble;
x[3]
x[3] = 22;
x.removeAt(3); x
x = x.insert(3, 22);
x ++ [55, 48, 60];
x.pairsDo { |a, b| "%: %\n".postf(a, b) };
(
x.doAdjacentPairs { |a, b|
   "% - % = %\n".postf(b, a, b - a)
};
)

x.sort;  // restores 0 .. 9 order

// sort in descending order:
// literally, so that an earlier item is bigger
x.sort { |a, b| a > b };
#+end_src

*** Unordered collections: Dictionaries
**** \clsspl{Dictionary} store \clsspl{Association}.
     - Association: \cd{key -> value}.
       - The \egls{key} is the identifier, used to access the items.
       - Very often, the key is a name, written as a \clss{Symbol}: \cd{\textbackslash name}.
**** Array-indexing methods work with dictionaries.
     The \mth{at}, \mth{put} and \mth{removeAt} methods take the
     \egls{key} as the argument, instead of a number.

*** Dictionary types
    - \clss{Dictionary} :: Looks up \egls{equivalent} keys. \clsspl{String} and \clsspl{Array} are valid keys.
    - \clss{IdentityDictionary} :: Looks up \egls{identical} keys. \clsspl{Symbol} and \ci{Integers} are valid keys.
    - \clss{Environment} :: The current environment provides storage for \ci{\textasciitilde environmentVars}.
    - \clss{Event} :: An \clss{Environment} that can be \mth{play}ed.
**** You'll probably use \clss{Event} most often.
     Nice shortcut syntax: \cd{(key: value, key1: value1...)}.

*** Dictionary methods
**** Key-value storage calls for some other methods.
     - \mth{keys} :: All the unique keys in this dictionary.
     - \mth{values} :: An array of the values, without keys.
     - \mth{keysValuesDo} :: Like \mth{do}, but the function arguments are \cd{|key, value, counter|}.
**** Minor difference in filtering methods.
     - \mth{collect}, \mth{select}, \mth{reject}.
     - Arguments passed to the function are \cd{|value, key|}.
     - Why the value first?\\
       To be consistent. The value comes first in all the other \mth{collect} variants.

*** Dictionary examples

    Note the use of \clss{Pdict}, to embed patterns by name.
#+name: coll4
#+caption: A useful Dictionary trick: Naming subpatterns for sequencing.
#+begin_src {SuperCollider} -i
d = (
   mel1: [0, 7, 3, 4, 6, 7],
   mel2: [9, 7, 6, 4, 3],
   mel3: [3.9, 4, 6, 3, 2]
);

// preserves the keys
e = d.collect { |array| Pseq(array, 1) };

e.keysValuesDo { |key, value| [key, value].postcs }; ""

q = Pbind(
   \degree, Pdict(e, Pxrand([\mel1, \mel2, \mel3], inf)),
   \dur, Pwhite(1, 3, inf) * 0.15,
   \scale, Scale.aeolian,
   \root, 11, \octave, 3
).play;

q.stop;
#+end_src
*** Unordered collections: Sets
**** Sets may not contain any duplicated items.
     - \clss{Set}: No \egls{equivalent} items.
     - \clss{IdentitySet}: No \egls{identical} items.
**** \clss{Set} and \clss{IdentitySet} are good for:
     - Checking membership: Does the set have this item?\\
       \clsspl{Set} can search quickly.
     - Avoiding duplicates:
       - What are the unique \glspl{pitch class} in a group of notes?
       - What items are in common between two sets?
       - What items exist in only one of the two sets?

*** Unordered collections: Set methods
    \mth{add}, \mth{remove}, \mth{do} etc. work as in other collections.
    - \mth{sect} :: Intersection (common items: items in setA /and/ setB). Shortcut: \cd{setA \& setB}.
    - \mth{union} :: Union: items in setA /or/ setB, or both. Shortcut: \cd{setA | setB}.
    - \mth{difference} :: Items in setA that are /not/ in setB. Shortcut: \cd{setA - setB}.
    - \mth{symmetricDifference} :: Items in only one of the two, but not both. Shortcut: \cd{setA -- setB}.

*** Unordered collections: Set examples
#+name: coll5
#+caption: Examples of useful Set operations.
#+begin_src {SuperCollider} -i
x = [59, 61, 66, 68, 69, 61,
   59, 68, 66, 61, 69, 68];

// unique pitch classes
y = IdentitySet.new;  // OK b/c Integers
x.do { |item| y.add(item % 12) };
y;  // 5 items only: duplicates ignored
z = IdentitySet[11, 1, 2, 4, 6, 7, 9];  // b minor

// which notes in y belong to a b minor scale?
y & z;

// which notes in y are *not* in b minor?
y - z;

// which notes are in either y or z, not both?
y -- z;
#+end_src

*** Summary: Collections
**** Any collection:
     - Loop: \mth{do}, \mth{collect}.
     - Filter: \mth{select}, \mth{reject}.
**** Store and recall items /in order/ (\clss{Array}).
     - Split (\mth{separate}, \mth{clump}) and join (\mth{++}) items.
     - \mth{sort} in order, and randomize the order (\mth{scramble}).
**** Store and recall items /by name/ (\clss{Dictionary}).
     - Looping: \mth{keysValuesDo}.

*** Collections: Musical memory
**** Composers and improvisers /manipulate/ musical material.
     - Create variations on a basic idea.
     - Cut material support, rearrange, splice, transpose, otherwise alter.
**** Collections let you store musical ideas and change them.
     - One week is not enough to go very far.
     - Keep these classes in mind. You /will/ need them later.

** Composition: Control structures
*** Control structures: Branching and Looping
**** Running code straight through is boring and limiting.
     Two things are very important in computing:
     - Making decisions: Which one of several things to do?\\
       This is \egls{branching}.
     - Doing the same thing many times, with different information.\\
       This is \egls{looping}.

*** Branching
**** \Gls{branching}'s basic question:
     I have two or more branches I can take. Which one?
**** Branching structures in SuperCollider:
     - \mth{if} :: *If* (condition), *then* do this; *else* do that.
     - \mth{case} :: Check several conditions; do the action for the first "true."
     - \mth{switch} :: Look up an action by value.

*** Boolean values
**** Branching depends on \egls{Boolean} expressions.
     - A \egls{Boolean} is either true or false, no middle ground.
     - Boolean expressions are often called "conditions":\\
       \cd{x < 10} is a condition: Either \ci{x} is, or it isn't.
     - Most conditions are based on comparison operators:
       - \ci{==}, \ci{===}: Are two items \egls{equivalent} or \egls{identical}?\\
	 \ci{!=} and \ci{!==}: Not equal, or not identical.
       - \ci{<}, \ci{<=}, \ci{>}, \ci{>=}: Less than or greater than?
       - Also useful: \mth{inclusivelyBetween}\cd{(lo, hi)}.

*** Basic branching: If
**** \mth{if} is the basic decision maker.
     - Remember it this way: *If -- then -- else*.
     - Can you predict what the \cd{10.rand} example will do?
#+name: if1
#+caption: Outline of the ``if'' structure.
#+begin_src {SuperCollider} -i
if(condition) {
   (then... true branch)
} {
   (else... false branch)
};

x = 10.rand;
if(x < 5) {
   "low random number: %\n".postf(x);  // then
} {
   "high random number: %\n".postf(x);  // else
};
#+end_src

*** Note on branch returns				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
You might have noticed that the \cd{10.rand} example displays the
string twice. Why?

The \ci{postf} method formats a string (substituting \ci{x} where the
\ci{\%} appears) and then prints it. This accounts for the first
display.

The second display is because SC always prints the result of the last
expression in the code block that was just executed. The last
expression is the \mth{if}. So, if the string printed again, then the
\mth{if} statement itself must have returned the string as a result
value.

This is a big difference between SuperCollider and languages like C or
Java. In C, \mth{if} is a "statement," and statements have no
value. The statement says what to do, but when the statement finishes,
its only effect is that it did something to something else.

By contrast, in SC, /everything/ is an expression. /Every/ statement
produces a return value. You can choose to ignore the return value,
but the value will be returned anyway. For example, look back at the
\mth{collect} example in Listing [[coll2]].

#+begin_src {SuperCollider} -i
x.collect { |item|
   if(item.odd) {
      item * 10
   } {
      item
   }
};
#+end_src

\cd{item * 10} is not really an /action/---it doesn't change a
variable or tell an object to do something---but it does produce a new
value. If the incoming item is an odd number, the \mth{if} says to
multiply that item by 10 /and return the result/. This returned result
goes back to \mth{collect}, which puts the new value into the result
array.

This is a very powerful idea, and it may take some time to
understand. Put it in the back of your mind for now, and come back to
it later when you need it.

*** What to do with "if"?
**** Just about anything...
     - Play a note on 75\% of 16th-notes in a bar.\\<all>
       *If* a 75% coin toss is true, keep the event; else make it a rest.
     - Avoid reloading something that's already loaded.\\<all>
       *If* the variable is nil, load it; else do nothing.\\
       (Note: You can just leave out the /else/ branch.)
     - On/off buttons.\\<all>
       *If* the user turned it on, do something; else, do something different.

*** "If" examples
#+name: if2
#+caption: Practical uses of "if."
#+begin_src {SuperCollider} -i
a = Pbind(  // canonical style
   \degree, Pn(Pseries(0, 1, 8), inf),
   \dur, 0.125.asPattern.collect { |dur|
      if(0.75.coin) { dur } { Rest(dur) }
   }
).play;

a.stop;

if(b.isNil) { b = Buffer.alloc(s, 44100*5, 1) };

o = Button(nil, Rect(600, 100, 100, 20))
.states_([["off"], ["on"]])
.action_({ |button|
   if(button.value == 1) {
      "on".postln;
   } {
      "off".postln;
   };
}).front;
#+end_src

*** Note: New stuff 					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** New elements
     - \mth{asPattern}: We need \ci{0.125} to act like a pattern, so
       that \mth{collect}'s function will run once for every
       event. Here, it's an easier-to-read alternative to
       \cd{Pn(0.125, inf)}.\glsadd{Pn}
     - \clss{Button}: Makes a clickable GUI button. We'll cover GUI basics later. For now:
       - \ci{nil} means the button has no parent window. It will make
         its own window automatically.
       - \clss{Rect} gives the position (600 and 100 are at the left
         and top coordinates) and size (100 and 20 are the width and
         height).
       - The button has two states, labeled as shown. Each state has
         its own sub-array, so that you can assign different colors.
       - \mth{front} brings the window to the front, so you can see it.

*** Compound conditions 
**** Often, you need to put several conditions together.
     E.g., if x is odd, and more than 100.
**** Logical operators:
     - \ci{and} :: True, if /both/ are true.
     - \ci{or} :: True, if /either/ is true, or both.
     - \ci{xor} :: True, if one or the other is true, but not both.
**** dummy						    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
     The above would be written: \cd{x.odd and: (x > 100)}.
     - You must put \ci{()} around the second condition.

*** Short-circuiting conditions
**** Sometimes you don't have to test all the conditions.
     \cd{x.odd and: (x > 100)}:
     - If \ci{x} is even, the first condition is false.
     - False \ci{and} anything is false: so \ci{x > 100} doesn't matter!
**** Good to get in the habit of writing conditions this way:
     @@latex:\cd{x.odd and: \{ x > 100 \}}@@.
     - Writing the second condition as a function means SC can skip it if possible.
     - This can improve speed by avoiding wasted expressions.

*** Short-circuiting and type safety
**** Some conditions are valid only for some types of objects.
     - Short-circuited conditions make it easy:\\
       @@latex:\cd{if(typecheck and: \{ condition \}) ...}@@
     - SC will try the condition the only if the type check is OK.
     - Often the result of an expression is \ci{nil} (empty result).\\
       Handle it this way:\\
       @@latex:\cd{if(object.notNil and: \{ condition \}) ...}@@

*** Other branching methods
    \mth{case} and \mth{switch} make some kinds of branching easier.\\
    We won't cover them in detail here. Look them up the help system for more.
    - Case: [[http://doc.sccode.org/Classes/Function.html#-case][Web link]]
    - Switch: [[http://doc.sccode.org/Classes/Object.html#-switch][Web link]]
    - Control structures in general: [[http://doc.sccode.org/Reference/Control-Structures.html][Web link]]

*** Looping
**** We have seen loops over collections.
     \mth{do}, \mth{keysValuesDo}, \mth{collect}, \mth{select}, \mth{reject}.
**** Other useful loops:
     - \ci{number.do}: Counts 0 to (number--1).
     - \ci{Array.fill}: Counts 0 to (number--1), adds function results to a new array.
     - \cd{(start .. end).do}: Counts \ci{start} to \ci{end}.\\
       Shortcut for \mth{for}: @@latex:\cd{for(start, end) \{ body \}}@@.
     - \cd{(start, second .. end).do}: Counts \ci{start} to \ci{end}, with a skip of \cd{second - start}.\\
       Shortcut for \mth{forSeries}: @@latex:\cd{forSeries(start, second, end) \{ body \}}@@.

** Composition: Combining patterns

* Considerations for group composition				   :noexport:
** Unity and contrast
*** You take the lead
    From here, we will do less guided explanation of techniques, and
    focus more on your creativity.
    - Larger modular synths;
    - Pattern sequences with more musicality;
    - Control in performance by external devices.

* Removed							   :noexport:
*** Branching: Case
**** \mth{case} combines several if--then--else structures.
     - \cd{if(condition)}
       - Then \cd{branch}
       - Else \cd{if(condition2)}
	 - Then \cd{branch2}
	 - Else...
#+name: case1
#+caption: A case statement, putting a random number in one of three categories.
#+begin_src {SuperCollider} -i
x = 10.rand;
case { x < 3 } {
   "low random number: %\n".postf(x);
}
{ x < 6 } {
   "mid random number: %\n".postf(x);
}
{ x < 10 } {
   "high random number: %\n".postf(x);
};
#+end_src

*** Branching: Switch
**** \mth{switch} is like "case" in other languages.
     - The fastest way to match a value to an action, /if/ you know in
       advance what the values can be.
     - For example, a GUI \ci{Button} has integer values 0, 1, 2...
     - This would be easy to match using \mth{switch}.
#+name: switch1
#+caption: A switch statement, matching an exact value.
#+begin_src {SuperCollider} -i
switch(3.rand,  // 3.rand == 0, 1 or 2
   0, { "zero" },  // do this if 3.rand === 0
   1, { "one" },
   2, { "two" }
);
#+end_src

*** "If" is the most common
**** You'll use \mth{if} a /lot/.
     Don't worry too much about \mth{case} or \mth{switch} for now.
**** Possible uses are... basically infinite.
*** Removed loop stuff
**** Now we'll take apart what they really do.

*** All looping comes from "while"
**** The basis of all looping is \mth{while}.
     - @@latex: \cd{while \{ condition \} \{ loop body \}}@@.\\
       *IMPORTANT:* The condition must be in braces, /not/ parens!!!
     - When the condition is true, the loop body runs again.
     - When it becomes false, the loop stops.
     - \cd{10.do} is actually a \mth{while} loop like this:
#+name: while1
#+caption: A while loop, showing how "number.do" really works.
#+begin_src {SuperCollider} -i
i = 0;
while { i < 10 } {
   i.postln;  // <-- this is the "do" function
   i = i + 1;
};
#+end_src

*** Loop exit conditions
**** *VERY IMPORTANT:* There must always be an exit condition! :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     - In the last example, if you forget \cd{i = i + 1}, then \ci{i} never changes.
     - It will always be < 10.
     - The loop will never exit---an \egls{infinite loop}.
     - Infinite loops will lock up SuperCollider. You have to force quit.
**** I can't count the number of times I made that mistake...
     Fortunately, \ci{do} and other types of loops handle the exit condition for you.

*** Use of while
**** You won't use \mth{while} very often.
     - \ci{do} etc. handle most loop situations, and they're safer.
     - \mth{while} is useful when you don't know how many times you have to loop.
     - For example, reading from a file:
#+name: while2
#+caption: A while loop, showing how "number.do" really works.
#+begin_src {SuperCollider} -i
(
f = File(thisProcess.platform.startupFiles.last, "r");
while {
   x = f.getLine;
   x.notNil  // keep going until 'nil'
} {
   x.postln;
};
f.close;
)
#+end_src

*** Note: exit condition				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the exit condition?
     There is no infinitely-long file. Eventually it will run out of
     information, and \ci{getLine} will return nil. Then the loop stops.

* Footnotes

[fn:03ac80c1] Twelve-note \gls{equal temperament}.

[fn:6607d9b8] Credit to Jeffrey Stolet for this insight.

