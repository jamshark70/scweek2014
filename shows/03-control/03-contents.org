#+startup: beamer

* Test								   :noexport:
** Test
*** Test
* Granular synthesis
** Granular synthesis parameters
*** Granular synthesis: Extremely powerful
# one less than the first listing number
#+latex: \setcounter{lstlisting}{90}

#+name: makegloss
#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+name: ugengloss
#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

**** Many common effects are based on \egls{granular} synthesis.
     - Notably, time stretching and pitch shifting.
     - Also good for long, complex drones.
**** A form of /microsound/.
     - Typically, sounds between 10 and 100 ms duration.
     - Rhodes, Curtis (2001). /Microsound/.

*** What is granular synthesis?
**** \eGls{granular} synthesis composes sounds from clouds of very short \eglspl{grain}.
     - When you have enough grains, you hear only the cloud.
     - As in these graphics: The more grains, the harder to see the individuals.
#+begin_center
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains100.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains200.png]]
#+attr_latex: :width 0.3\textwidth
[[../03-control/img/grains500.png]]
#+end_center

*** Characteristics of grains and clouds
**** Important things about a \gls{grain}:
     - *Duration:* How long it is.
     - *Envelope:* Its shape.\\
       Sine-shaped envelopes work especially well.
     - *Spectral content.* Usually comes from sampled audio in a \clss{Buffer}.
**** Important things about grain clouds:
     - *Overlap:* How many grains simultaneously. (May vary.)
     - *Time distribution:* Are the grains evenly spaced in time?

*** Sine-shaped envelopes
**** Sine envelopes work well because they are complementary.
     - /Complementary/: Add them together, with the right offset, and you get a constant.
     - So, the individual envelopes blend together into a consistent volume.
#+begin_center
#+attr_latex: :height 1.5in
[[../03-control/img/sinusoidal-envelopes.png]]
#+end_center

*** Start simple: Individual grains
**** \Gls{granular} UGens have a number of parameters.
     - If we try to cover all of them at once, it's confusing.
**** Parameters needed for single \glspl{grain}:
     - *Trigger:* We'll use \ugen{Impulse}, controlled by frequency.
     - *Duration*.
     - *Position* within the buffer: for now, in seconds.
#        , as a \egls{normalize}\emph{d} range.
#        - 0 = buffer start, 1 = buffer end.
#        - Why? \Glspl{Buffer} may be of different sizes.
#        - If it's normalized, the position input can be the same for any buffer.

*** Load a buffer
**** The examples assume that \ci{b} is a \clss{Buffer}.
     - Load the standard example sound, or another of your choice.
#+name: sfgran1
#+caption: Read SuperCollider's classic Apollo 11 example sound into a buffer.
#+begin_src {SuperCollider} -i
b.free;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
#+end_src

*** TGrains UGen
**** Basic granulator: \ugen{TGrains}.
     - You can control trigger frequency, grain duration and buffer position.
     - Raise the trigger frequency until the grains blend together.
#+name: grain1
#+caption: Granular synthesis: first step.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

(
~grains.addSpec(\tfreq, [1, 20, \exp]);
~grains.addSpec(\pos, [0, b.duration]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, pos = 0.5,
   amp = 0.2|
   var trig = Impulse.ar(tfreq);
   TGrains.ar(2, trig, b, 1, pos, graindur, pan, amp);
};
~grains.play;
)

p.gui;  // if it's not already open
#+end_src

*** Automating buffer position
**** Let's move forward through the buffer.
     Constant rate---what do you think will be the result?
**** Replace the \ci{pos} argument with a \ugen{Phasor}.
     - \ugen{Phasor} is a looping line segment, with a rate control.
     - \ci{rate} is in units per sample.\\
       At audio rate, \cd{rate = 1} will increase by 44100 in one second.
     - We want to increase by 1.0 per second.\\
       See \ugen{SampleDur}, which outputs $\frac{1}{samplerate}$.
     - What's the upper boundary?\\
       \Gls{Buffer} duration: \cd{b.duration} or \ugen{BufDur}\cd{.kr(b)}.
**** Exercise for you: Write the \ugen{Phasor}.
# #+name: grain2
# #+caption: Use a Phasor to move through the buffer in real time.
#+begin_src {SuperCollider} -i :exports none
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.2|
   var trig = Impulse.ar(tfreq),
   pos = Phasor.ar(0, SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, pos, graindur, pan, amp)
};
#+end_src

*** Speed of buffer movement
**** What if we move through the buffer at different speeds?
     - Add a new argument, \ci{speed}.
     - Set its range, using \mth{addSpec}, to \cd{[0.25, 4, \textbackslash exp]}.
     - How to incorporate \ci{speed} into the \ugen{Phasor}?\\
       *Hint:* \ci{speed} should /scale/ (multiply) the \ugen{Phasor} rate that is already there.
**** Exercise: Write this yourself.
     What is the result?
# #+name: grain3
# #+caption: Adjust the buffer movement speed by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\speed, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, 1, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain rate
**** What about the \ci{rate} argument in \ugen{TGrains}?
     - We adjusted the \ugen{Phasor} rate, and got a time effect.
     - What do you think \ugen{TGrains}'s rate will do?
**** Let's find out: Write the change yourself.
     - Add a new \ci{rate} argument.
     - Give it a similar exponential range.
     - Plug it into \ugen{TGrains}.
# #+name: grain4
# #+caption: Adjust the grain playback rate by a synth argument.
#+begin_src {SuperCollider} -i :exports none
~grains.addSpec(\rate, [0.25, 4, \exp]);
~grains = { |tfreq = 5, graindur = 0.2, pan = 0, amp = 0.1,
   rate = 1, speed = 1|
   var trig = Impulse.ar(tfreq),
   centerPos = Phasor.ar(0, speed * SampleDur.ir, 0, b.duration);
   TGrains.ar(2, trig, b, rate, centerPos, graindur, pan, amp)
};
#+end_src

*** Grain duration vs. overlap
**** Sometimes better to control how many overlapping \glspl{grain}.
     - That is, adjust the grain duration along with trigger frequency.
     - If you want 4 overlapping grains, and 1 trigger/sec, how long should each grain be?\pause\\
       4 seconds.\pause
     - If you have 2 triggers/sec, how long should the grains be?\pause\\
       2 seconds.\pause
     - What, then, is the formula?\pause\\
       \cd{overlap / trigfreq}\pause
**** Exercise, on your own time:
     Edit the synth to use an \ci{overlap} argument instead of \ci{graindur}.

*** Summary: Granular synthesis parameters
**** \Gls{granular} synthesis gives you independent control over:
     - Time (buffer position's rate of change);
     - Pitch (playback rate of each \gls{grain});
     - Continuity (frequency of triggers, grain duration, overlap).
**** Tone color comes from whatever is in the buffer.

** Usage of granular synthesis
*** Sustaining sounds
**** Sustaining sounds need:
     - Fast grain triggers;
     - Relatively high overlap (at least 5).
#      If the trigger frequency, buffer position and grain rate are all constant, then you hear sonic features repeating exactly.
#+name: grain5
#+caption: Granular synthesis, sustaining sound, with constant triggers, buffer position and grain rate.
#+begin_src {SuperCollider} -i
p.clear;

~grains.addSpec(\tfreq, [1, 40, \exp]);
~grains.addSpec(\overlap, [0.1, 10, \exp]);
~grains.addSpec(\pos, [0, b.duration]);  // 3.43 is nice!
~grains.addSpec(\rate, [0.5, 2, \exp]);
~grains = { |tfreq = 25, overlap = 6, pan = 0, amp = 0.2, pos = 3.43,
   rate = 1|
   var trig = Impulse.ar(tfreq);
   TGrains.ar(2, trig, b, rate, pos, overlap / tfreq, pan, amp)
};
~grains.play;
#+end_src

*** Solution: Randomize
**** It sounds boring because the pattern is too obvious.
     - The ear latches onto the repeating features, not the sustained feel.
     - So, break up the pattern by adding a small random offset.
**** Add random \egls{LFO} modules.
     - \ugen{LFNoise1} is good for random numbers.
     - The LFO module should convert to the right range (as we covered earlier).
     - Then, modulate the input within \ci{\textasciitilde grains}.

*** Randomize buffer position
**** What's a good range?
     - A random range in seconds is OK.
     - You don't need much: 0.1--0.2 seconds is enough.
**** Exercises for you:
     1. Write an \gls{LFO} module with \ugen{LFNoise1}:
	- Fairly high frequency (at least 50).
	- Include an argument for the amount of modulation, ranging 0--maximum seconds.
	- Give that argument an appropriate range spec.
     2. Edit \ci{\textasciitilde grains} to apply the LFO.
     3. Adjust the LFO amount and listen to the different effects.

*** Randomize grain playback rate
**** What's a good range?
     - \ci{rate} is a multiplier---so the range should be \egls{exponential}.
     - Do you remember how to convert to an exponential range?
     - You need only a few cents (cent = 0.01 semitone).
     - The ratio for 1 cent = 1.0005777895066.\\
       \cd{0.01.midiratio}
     - 20 cents = \cd{0.2.midiratio} = 1.0116194403019.
**** Exercises for you.
     Same as for buffer position, except with a different range, and exponential usage.

*** Small vs. large scale modulation
**** You can also combine two kinds of modulation:
     - Small range, fast modulation.
     - Larger range, slower modulation.
**** For instance, moving through a buffer.
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.6
     :END:
     - \ugen{Phasor} in a straight line.
     - \ugen{LFNoise1}, low amplitude.
     - It still sounds like moving through the buffer, but with some variation.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.4
     :END:
     #+begin_center
     #+attr_latex: :height 1in
     [[../03-control/img/randomized-line.png]]
     #+end_center

*** Glitchy sounds
**** Glitchy sounds also use random \glspl{LFO}, but wider range.
     - Take grains from any part of the buffer at any time.
     - Much shorter \ci{graindur} (can randomize this too).\\
       When dur < 0.015, the envelope changes the tone color!
     - Also, randomize the time between triggers (e.g., \ugen{Dust}).
     - See also the \ugen{GrainBuf} UGen.\\
       Allows you to choose a different envelope. Percussive envelopes can be really noisy!
**** Exercises: Edit the granular synth to try these techniques.

*** Granulating live input
**** What if you want to do this on a real-time signal?
     - Tricky if you want to play it faster than real time.
       - Grain rate > 1.
       - Buffer movement speed > 1.
     - Much slower is also a problem.
**** Shortcut: \ugen{PitchShift} UGen.
     - Can raise or lower pitch of a live signal up to two octaves.
**** Using \clsspl{Buffer} and \ugen{TGrains}:
     - Beyond the scope of this class.

*** Summary: Synthesis techniques
**** Techniques:
     - Subtractive synthesis ("analog"): \egls{oscillator} $\to$ \egls{filter}.
     - Frequency modulation: \egls{modulator} $\to$ \egls{carrier}.
     - Granular synthesis: Clouds of short, enveloped \eglspl{grain}.
**** Next steps:
     - Build more complex, compositional patterns.
     - Bring external control data into SC, and plug into synthesis and composition parameters.

* External control
** Basic concepts: GUI
*** Custom interfaces
**** So far, we have used the built-in \ci{ProxyMixer}.
    This is a good, general-purpose interface, but not ideal for every performance need.
**** A few fundamentals can get you started making your own interfaces.
     - Display only the controls that you need.
     - Put them in a layout that makes sense visually.
**** The concepts to do this are preparation for mobile interfaces.

*** Only the basics
**** This is not a GUI design workshop!
     We will cover only the simplest usage:
     - How to put controls on screen.
       - Basic types of controls.
       - A simple way to arrange several controls in one window.
     - How to use GUI control information.
       - Mapping GUI number ranges onto real-world parameters.
       - Communicating the mapped values to NodeProxies.
**** Experiment with GUIs in your own work, after the workshop.
     When you need a bigger GUI, look more deeply into the GUI system.

*** Buttons and faders
**** Only two categories of user-interface objects:[fn:6607d9b8]
     - Faders :: Represent a range of values. Sliders, knobs, 2D canvases are all faders.
     - Buttons :: Represent a momentary trigger.
**** These are /categories/, not specific controls.
     - You can have faders that look and act differently (slider
       vs. knob), but all faders move continuously up and down a
       range.
     - Buttons are good for starting and stopping actions.
     - When we get into mobile control, we will see how to make a fader act like a button.

*** Main coding concepts
**** By far, the most important concept is \egls{callback}.
     - User interaction needs to "call back" into your code.
     - GUI, MIDI, OSC, HID interfaces all depend on this idea.
**** Other concepts
     - View :: A general term for a GUI widget.
     - Spec :: A \clss{ControlSpec}, mapping a control onto a range of values.
#     - Layout :: An automated way to position views in a window.

*** A simple slider
**** Let's control pitch with a \clss{Slider}.
     - The example makes a simple sound, and puts a slider on screen.
     - The slider is not connected to anything yet.
     - Note that the slider's first argument is \ci{nil}.\\
       This is a shortcut for single views.
     - See also \clss{Knob} (look in its help file for details).
#+name: gui1
#+caption: A simple sound, and a slider that will control it (but not yet).
#+begin_src {SuperCollider} -i
p = ProxySpace.new.push;

~sound = { |freq = 440, amp = 0.1|
   VarSaw.ar(freq, 0, 0.5, amp).dup
};
~sound.play;

z = Slider(nil, Rect(600, 200, 200, 20)).front;
#+end_src

*** Controlling pitch
**** To connect the slider to the frequency:
     1. A \egls{callback} function:\\
	When the user moves the slider, set the frequency.
     2. Convert the slider's range to frequency.
	- Get the slider's current state with the \mth{value} method.
	- Sliders always run 0.0--1.0. Use a \clss{ControlSpec} to convert.
	- \cd{y.map} takes in 0.0--1.0, puts out a value matching the spec's range.
#+name: gui2
#+caption: Plug the slider into the frequency input.
#+begin_src {SuperCollider} -i
y = ControlSpec(110, 880, \exp);

z.action = { |sl|
   ~sound.set(\freq, y.map(sl.value));
};
#+end_src

*** "Parent" and "bounds"
**** \ci{parent} and \ci{bounds} let you put several views in one window.
     They are set at view creation time: \cd{Slider(parent, bounds)}.
     - \ci{parent}: Which window contains the new widget.
     - \ci{bounds}: A \clss{Rect} saying where to put the widget in
       the window, and how big to make it.
       - \cd{Rect(left, top, width, height)}.
       - A common height for single-line views is 20.

*** An "EZ"-er way
**** The *EZ* GUI objects do the range mapping for you.
     See their help files: Start with \ci{EZSlider} and \ci{EZKnob}.\\
     Close the old slider window, then do this.

     Also introducing \clss{Window}.\\
     When you make your own window, you can put more things in it.
#+name: gui3
#+caption: EZSlider: Much easier to map an on-screen control to a range of useful values.
#+begin_src {SuperCollider} -i
w = Window("window name", Rect(600, 200, 300, 120));
z = EZSlider(w,
   bounds: Rect(5, 5, 290, 20),
   label: "freq",
   controlSpec: [110, 880, \exp],  // short form OK
   // no need for 'map' in the action!
   action: { |view| ~sound.set(\freq, view.value) },
   initVal: 440
);
w.front;
#+end_src

*** Note on Window bounds				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** Why is the window near the bottom?
This is a strange behavior left over from the original OSX
SuperCollider application. The Apple (Cocoa) GUI objects put 0 at the
bottom of the screen. The coordinates for the screen's height is at
the top. Now SuperCollider uses Qt objects for drawing, because they
work on all supported operating systems (not only Mac). The SC Qt
objects keep this "upside down" behavior, so that older code will
still put the windows in the same place.

Inside a window, $y = 0$ is the top of the frame, and $y$ increases as
you go down. This is also true if you make a GUI object without a
window, as in Listing [[gui1]]. But, when you make a \clss{Window}, you
have to remember that the "top" coordinate in the boundary \clss{Rect}
is actually the window's /bottom/, and it's measured from the bottom
of the screen.

Weird, but that's the way it is.

*** Button example
#+name: gui4
#+caption: Add a button into the same window. Note the Rect coordinates.
#+begin_src {SuperCollider} -i
b = Button(w, Rect(5, 30, 290, 30));
b.states = [
   ["stopped", Color.black, Color.gray(0.8)],
   ["playing", Color.black, Color.green]
];
b.action = { |view|
   if(view.value == 1) {
      ~sound.play;
   } {
      ~sound.stop;
   };
};
#+end_src

*** SC Button interface
**** SC's \clss{Button} is /multi-state/.
     - It can cycle through different labels and actions.
     - In the last example:
       - "Playing" and "stopped" are two states.
       - "Playing" lives at index 0; "stopped," at 1.
       - These are available in the callback function as the button's \mth{value}.
     - Each state is an array:\\
       @@latex:\cd{["label", textColor, backgroundColor]}@@.\\
       You can leave out the colors: @@latex: \cd{["label"]}@@.\\
       You can't leave out the sub-array brackets!

*** Different actions for button states
#+begin_src {SuperCollider} -i
b.action = { |view|
   if(view.value == 1) {
      ~sound.play;
   } {
      ~sound.stop;
   };
};
#+end_src
**** New coding structure: \mth{if}.
     - What do you think it's doing?\pause
     - *If* (condition) *then* \{ action \} *else* \{ other action \}.
     - The most basic /decision-making/ technique.

*** Setting many properties at once
**** This is a common pattern in GUIs:
     1. Create the widget: \cd{b = Button(...)}.
     2. Set the object's variables:
	- \cd{b.states = [...];}
	- @@latex:\cd{b.action = \{ ... \};}@@
**** More convenient: \cd{\textunderscore} for setting
     - \cd{b.states\textunderscore([...])} is the same as \cd{b.states = [...];}.
     - You can chain \cd{\textunderscore} calls:\\
       @@latex:\cd{b.states\textunderscore([...]).action\textunderscore(\{ ... \})}@@.
     - This helps, if you're using long, descriptive variable names.\\
       You don't have to repeat the variable name for every property.

*** Notes on "the same"					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** How are those two "the same"?
We have two separate concepts here. They are somewhat alike, but they
are actually doing different things.

- Assigning a value to a variable: \cd{x = 1}. We have discussed this before.

- Setting a property of an object: \cd{b.value = 1}.

The second is actually not an assignment statement! Remember that the
/only/ way to do anything with an object is to call one of its
methods. Let that sink in for a minute: There is /no way/ to change
the \ci{Button} object's \ci{value} property without calling a
method. The syntax looks like variable assignment, but /the only
possible way it could work is as a method call/.

In fact, \ci{Button} does have a method to change \ci{value}. That method
is named \ci{value\textunderscore}, and it's called like this:
\cd{b.value\textunderscore(1)}. But this is ugly, and a bit harder to
read. So SuperCollider understands \cd{b.value = 1} as if you had
written \cd{b.value\textunderscore(1)}.

If you have to set several properties at one time, the
\ci{\textunderscore} becomes more convenient:

- Easy:
  @@latex:\cd{b.states\textunderscore([...]).action\textunderscore(\{
  ... \});}@@
- A bother, if \ci{b} is, say, \ci{closeWindowButton} instead:\\<all>
  \cd{b.states = [...];}\\<all>
  @@latex:\cd{b.action = \{ ... \};}@@
- Avoids repeating the variable, but with more properties, you'll need
  more open-parens at the beginning. Extremely ugly:\\<all>
  @@latex:\cd{(b.states = [...]).action = \{ ... \}};@@

*** Button example, rewritten with \textunderscore
#+name: gui5
#+caption: A more convenient way to set all the properties of a GUI object in one statement, by chaining .name\textunderscore() method calls.
#+begin_src {SuperCollider} -i
b = Button(w, Rect(5, 30, 290, 30))
.states_([
   ["stopped", Color.black, Color.gray(0.8)],
   ["playing", Color.black, Color.green]
])
.action_({ |view|
   if(view.value == 1) {
      ~sound.play;
   } {
      ~sound.stop;
   };
});
#+end_src

*** Easier positioning: FlowView
**** \clss{FlowView} positions views automatically.
     - Left to right, top to bottom.
     - Two ways to write \ci{bounds}:
       - \cd{Rect(0, 0, width, height)}, or
       - \cd{Point(width, height)}. Shortcut: \cd{width@height}.
**** How to use:
     1. Make the window.
     2. Put a \clss{FlowView} inside it.\\
	*Hint:* Use the window's size, as in the example.
     3. Use the \clss{FlowView} as the parent for other views.
     4. If you need a "line break," call: \cd{f.startRow}.

*** FlowView example
**** Same control window, with automatic positioning.
**** Only slideshow						  :B_onlyenv:
     :PROPERTIES:
     :BEAMER_env: onlyenv
     :BEAMER_act: presentation
     :END:
      This won't fit into the slideshow. See Listing [[gui6]] in Part III's =scd= file.
**** cancel "only"					    :B_ignoreheading:
     :PROPERTIES:
     :BEAMER_env: ignoreheading
     :END:
#+name: gui6
#+caption: Using FlowView to arrange an EZSlider and a Button automatically.
#+begin_src {SuperCollider} -i :var extract='t
(
w = Window("window name", Rect(600, 200, 300, 120));
f = FlowView(w, w.view.bounds);
z = EZSlider(f,
   bounds: Point(290, 20),  // HERE: No left/top, only size
   label: "freq",
   controlSpec: [110, 880, \exp],
   action: { |view| ~sound.set(\freq, view.value) },
   initVal: 440
);

b = Button(f, Point(290, 30))
.states_([
   ["stopped", Color.black, Color.gray(0.8)],
   ["playing", Color.black, Color.green]
])
.action_({ |view|
   if(view.value == 1) {
      ~sound.play;
   } {
      ~sound.stop;
   };
});

w.front;
)
#+end_src

*** Updating a GUI view's display
**** How do you change the displayed value?
     - For almost all GUIs: \cd{theView.value = newValue}.
     - We will not do much with this right now.\\
       See "Synchronizing interfaces" in the Appendix.

*** GUI operations and Tasks
**** Using GUIs in a \clss{Task}, timing becomes an issue.
     - Drawing onscreen may not be fast.
     - Musical timing is more important than anything else!
**** You have two choices:
     - Run the task on \clss{AppClock}.
       - Timing is /close/, but not perfect.
       - Good enough for GUI-only tasks.
       - \cd{theTask.play(AppClock)}.
     - Or, \mth{defer} GUI operations.
       - The \clss{Task}'s timing will be exact.
       - GUI updates /only/ will shift to \clss{AppClock}.

*** Example: GUI and Task
**** We'll turn the sound on and off at random intervals.
     The button will show the on/off state.
     - The \clss{Task} affects the sound. We need musical timing.
     - So, run it on \clss{TempoClock} and \mth{defer} GUI code.
#+name: gui7
#+caption: Changing the display of a GUI button within a Task.
#+begin_src {SuperCollider} -i
Tdef(\onoff, {
   loop {
      ~oscil.play;
      defer { b.value = 1 };
      rrand(0.25, 0.5).wait;
      ~oscil.stop;
      defer { b.value = 0 };
      exprand(0.15, 0.5).wait;
   }
}).play;

Tdef(\onoff).stop;
#+end_src

*** The most common GUI error
**** This error message happens a lot:
**** quote							    :B_quote:
     :PROPERTIES:
     :BEAMER_env: quote
     :END:
=ERROR: Qt: You can not use this Qt functionality in the current thread. Try scheduling on AppClock instead.=\\
=ERROR: Primitive '_QObject_SetProperty' failed.=
**** It means: You need \mth{defer} somewhere.
     To help find it, the error message also tells you:
     - The receiver's type (button, slider, etc.);
     - The "call stack" showing what the code was doing.
     See the "Understanding Errors" help file.

*** Notes on timing					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** But, really, why do we need \mth{defer}?
The most important thing in any real-time processing is /to be sure
everything is going to finish in a reliable amount of time/.

Let's say you have a pattern playing very fast events---say, the delta
time is 10 ms. (This is entirely possible, if you're doing granular
synthesis with control on the language side---that is, one synth per
grain, instead of using \ci{TGrains}.) The total time to process an
event must be less than 10 ms. The total time includes:

- Calculating the event's parameters in \clss{Pbind}.
- The event's automatic calculations.
- Building the OSC message(s) for the server.
- Sending the OSC message(s).
- Rescheduling.

GUI operations draw things onscreen. Turning lines and curves into
pixels (with anti-aliasing) takes more time than simple
calculations. So there is no guarantee that the OS can finish drawing
in time for SC to move onto the next event. If graphics updates can
cause musical events to happen late, it's totally unacceptable.

Without \mth{defer}, the code is saying, "Whatever you're doing, stop
it all to change the screen's display." If the update is deferred,
this says, "Update the display as soon as you're not busy."

**** Frequency of screen updates
Now, use a little common sense. Movies run at about 24
frames/second. If that's good enough for Hollywood, it should be good
enough for graphical displays.

/It's completely pointless to update GUIs 50 or 100 times per second!/

"Synchronizing interfaces" explains a technique to control the update
rate.

*** GUI summary (so far)
**** What we now know about GUIs:
     - How to create \clsspl{Window}, \clsspl{Slider}, \clsspl{Button}.
     - How to use *EZ* GUIs (\ci{EZSlider}, \ci{EZKnob}), for easier range mapping.
     - *Most important point:* How \egls{callback} functions
       (\ci{action}) make the views do real things.
     - How to put several views into one window:
       - Directly, with explicit positions in the boundary \clsspl{Rect}.
       - Using \clss{FlowView} for automatic positioning.
**** This will take you a long way.
     Your GUIs might not be pretty, but they will do things.

*** Layout notes					    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What we didn't cover:
     - *Layouts:* A set of classes that set both the positions and
       sizes of views automatically. The problem with \clss{FlowView}
       is that you have to tell it how big each view should be. If you
       want the left, right, top and bottom sides of several views to
       line up, you have to calculate their sizes carefully. This gets
       really irritating. Layouts are containers that distribute the
       views in different arrangements. You provide "hints" for size
       and alignment, and the layout figures out exactly how big each
       one should be. For example, if you want a row of three buttons
       occupying the entire width of a window, with a \ci{margin} at
       left and right and a \ci{gap} in between the buttons:
       - FlowView: Calculate the buttons' widths:\\<all>
         \cd{(window.bounds.width - (margin * 2) - (gap * 2)) / 3}.
       - Layouts: Put the buttons into a \ci{HLayout}. That's it.
     - *MVC* (Model-View-Controller) design: When GUIs become more
       complicated, you have to control the data flow more
       carefully. This is especially important when synchronizing
       multiple control sources: GUI, MIDI and/or mobile devices with
       OSC. A tried-and-true approach is Model-View-Controller. See
       the Appendix.

** Open Sound Control fundamentals
*** Why mobile control in this workshop?
**** Because: Just about everybody has a smartphone.
     If you have a smartphone, there's probably an app for it that will send OSC.
**** The main elements:
     - Callback functions: /Exactly/ the same idea as in a GUI.
     - \clss{OSCFunc}: Attach a callback function to incoming OSC messages.
     - Filtering messages by:
       - Device or application, identified by a \clss{NetAddr}.
       - Command \eglspl{path}, such as \ci{"/1/fader"}.

*** OSCFunc tracing: Watching OSC come in
**** Important idea: /Inspect/ the input!
     The device will tell you what commands it's sending.
     - Issue the following commands.
     - Wait a few seconds in between.
#+name: osc1
#+caption: How to trace incoming OSC messages.
#+begin_src {SuperCollider} -i
OSCFunc.trace(true);
OSCFunc.trace(false);
#+end_src
**** If the server is booted, you'll see something like:
#+begin_src {} -i
OSC Message Received:
   time: 1392825887.1304
   address: a NetAddr(127.0.0.1, 57110)
   recvPort: 57120
   msg: [ /status.reply, 1, 0, 0, 2, 74, 1.0463403463364,
      1.0534679889679, 44100, 44099.530279753 ]
#+end_src

*** OSC message structure
**** What is this message made of?
#+begin_src {} -i
msg: [ /status.reply, 1, 0, 0, 2, 74, 1.0463403463364,
   1.0534679889679, 44100, 44099.530279753 ]
#+end_src
     - First: /command \gls{path}/---here, @@latex:\cd{/status.reply}@@.
       - Any string is a command.
       - The sending app can organize commands into groups.
       - Groups are separated by \ci{/} in the string.
       - @@latex:\cd{/status.reply}@@ is for the server's status.
     - Any combination of numbers and strings can follow.\\
       Here, the information you see in the server status line.

*** OSCFunc: Receiving OSC
**** Let's look at what OSC brings in.
     Create a very basic \clss{OSCFunc}, which prints its inputs.
     - The callback function gets four arguments.\\
       Usually, you need only \ci{msg}.
       - msg :: An \clss{Array}, one item per message value.
       - time :: The system's time of receipt.
       - addr :: The \clss{NetAddr} *from* which the message came.
       - recvPort :: The SuperCollider port *to* which the message came.
     - You have to give a command path to match.
#+name: osc2
#+caption: The simplest possible OSCFunc.
#+begin_src {SuperCollider} -i
o = OSCFunc({ |msg, time, addr, recvPort|
   [msg, time, addr, recvPort].postln;
}, '/status.reply');  // command path is here

o.free;  // when you're tired of the printing
#+end_src

*** Filtering messages
**** OSC can come from many sources, with many messages.
     Your \clss{OSCFunc} should not try to respond to them all!
**** Filtering options
     - Command path (we just saw this)
     - \clss{NetAddr}, which identifies:
       - The sending machine, by IP address.\\
	 Your local machine is \cd{"127.0.0.1"}.
       - The sending application, by port.\\
	 Each application must send from a different port number.\\
	 Filtering by port means listening to just one app.
     - Other values in the message. (See OSCFunc help.)

** OSC and mobile control
*** Mobile control overview
**** To use your phone or tablet:
     1. Set up TouchOSC or mrmr on the phone.\\
	Keep the "to" and "from" addresses in mind.\\
	/Everybody/ gets confused about this at first.
     2. Trace OSC in SC to learn the command paths.
     3. Create \clsspl{OSCFunc} to translate messages into actions.

*** Set up TouchOSC or mrmr
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.65
     :END:
***** Most important are the network settings
      - Host :: The IP address of the /computer/.\\
	Use the system command line to find out.
	- Linux, OSX: =ifconfig=
	- Windows: =ipconfig=
      - Port (out) :: The receiving port in /SuperCollider/.
      - Port (in) :: The port SC should send /to/.
      - Local IP :: The phone's IP address.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.35
     :END:
     #+begin_center
     #+attr_latex: :height 0.8in
     [[../03-control/img/touchosc-net.png]]
     #+end_center

*** TouchOSC network settings
**** You /must/ set the host and outgoing port!
     - Host
       - In Linux, running =ifconfig= dumps a bunch of output.
       - The =wlan0= section shows the computer's IP:\\<all>
	 =inet addr:192.168.1.103=
       - The TouchOSC host should be whatever is shown here.
     - Port
       - SC's default language port is 57120.\\
	 This will almost always work. If not, ask SC for the real
         port number: \cd{NetAddr.langPort;}.\glsadd{langPort}
**** Incoming port and local IP allow SC to change the phone's display.
     Leave them alone for now.

*** Trace messages
**** Use OSCFunc tracing to learn the command paths.
     1. Tap /Done/.\\
	This means: Done with setup.
     2. Run \cd{OSCFunc.trace(true, true)}.\\
	\ci{true} means: Hide the server status messages.
     3. Touch some of the phone's controls. You should see messages like:
	#+begin_src {}
	[ /1/fader1, 0.38026785850525 ]
	[ /1/toggle1, 1 ]
	[ /1/fader2, 0.33978831768036 ]
	[ /1/toggle2, 1 ]
	[ /1/fader3, 0.38026785850525 ]
	[ /1/toggle3, 1 ]
	[ /1/xy, 0.54863464832306, 0.30632436275482 ]
	#+end_src
	If you're using mrmr, the messages will be different.
     4. Stop tracing: \cd{OSCFunc.trace(false)}.

*** OSCFunc filter for your phone
**** Pick one of the faders, and make an OSCFunc.
     - We'll reuse the variable \ci{o}.
     - *Good habit:* \mth{free} the variable before putting anything
       in it.\\
       (If you forget, \ks{Ctrl-.} can clean up leftovers.)
     - *Important:* Put your phone's local IP address into the
       \clss{NetAddr}. (\ci{nil} is important too!)
#+name: osc3
#+caption: An OSCFunc to respond to your phone.
#+begin_src {SuperCollider} -i
o.free;
o = OSCFunc({ |msg|  // really, only need the message
   msg[1].postln;    // 2nd item is the value
}, '/1/fader1', NetAddr("your phone's IP", nil));
#+end_src
**** Now move the fader.
     You should see only the numbers print.

*** What could go wrong?
**** Check these things if you don't see the numbers:
     - *Is the \clss{NetAddr} correct?*\\
       This is the address where messages come *from*.\\
       Use the phone's /Local IP/ here---\emph{not} the computer's!
     - *Is the phone sending?*\\
       TouchOSC has a small light on screen. Does it light when you touch it?
     - *Is the computer receiving?*\\
       Look in the system monitor for network traffic.\\
       If none, it could be:
       - Wrong /Host IP/ address in TouchOSC;
       - WiFi problem, blocking messages to the computer.

*** TouchOSC message organization
**** Do you notice any patterns in the command paths?\pause
     The commands divide in two parts:
     - =/1= is for the screen number.
     - =/fader1= gives the control type and its number.
     The command path just puts them together:\\<all>
     =/1/fader1=\\<all>
     =/3/toggle2=, etc.

*** TouchOSC message values
**** Note the kinds of values that go along with the paths.
     - What is the fader's range?\pause\\
       Seems to be 0.0--1.0.\pause
     - Values for buttons and toggle switches?\pause\\
       0 = off, 1 = on.
     - =xy= slider has two values. What do they mean?\pause\\
       One is x; the other, y.\pause
**** If you know these ranges, you can map them onto any real range.
     Same as we did with the GUI slider.

*** Connect to sound
**** Very similar to the GUI approach.
     - The callback function sets a synthesis parameter.
     - One difference: There's no *EZ* \clss{OSCFunc}.\\
       So, you have to do the \clss{ControlSpec} mapping yourself.
**** In \clss{ProxySpace}, use a numeric proxy for the parameter.
     "Synchronizing interfaces" in the Appendix explains why.
**** \clss{OSCdef}: Convenient way to store OSC responders.
     Like \clss{Pdef} and \clss{Tdef}. See the next example.

*** OSC $\to$ sound example
    Don't forget: Put in your phone's IP address, and a real command path.
#+name: osc4
#+caption: Controlling frequency by a touchscreen fader. You should change the command path and IP address to match your equipment.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new.push;

~freq = 440;  // numeric proxy
~oscil = {
   VarSaw.ar(~freq, 0, 0.3, 0.1).dup
};
~oscil.play;

OSCdef(\sl1, { |msg|
   ~freq = \freq.asSpec.map(msg[1])
}, '/1/fader1', NetAddr("192.168.43.1", nil));

// When you're finished with mobile control:
OSCdef(\sl1).free;
#+end_src

*** Summary: Mobile control
**** Setup
     - =ipconfig= or =ifconfig= to find the computer's IP address.
     - TouchOSC tells you the phone's IP address.
     - SuperCollider's default port is 57120.
**** Trace incoming OSC to learn:
     - Command paths that TouchOSC or mrmr send out.
     - Value ranges coming from the various control types.

*** Summary: Receiving OSC
**** \clss{OSCFunc} takes action on incoming OSC messages.
     Important class arguments:
     - \ci{func} :: The \gls{callback} function. \ci{func}'s arguments are \cd{msg, time, addr, recvPort}. Usually you only need \ci{msg}.
     - \ci{path} :: The /command \gls{path}/.
     - \ci{srcID} :: The \clss{NetAddr} where the messages come *from*.
#      - \ci{argTemplate} :: Matches message values other than path. See the help file.
     \clss{OSCdef} is global, named storage for \clsspl{OSCFunc} (like \clss{Pdef}).
**** Mapping to audio
     - Understand the OSC controller's value ranges.
     - Use \clsspl{ControlSpec} to convert to the real range.
     - The callback function should set a synth input.\\
       Numeric proxies, as in Listing [[osc4]], solve some problems.

*** For the project: Add more controls!
**** The concepts, and setup, might seem complicated.
     - But, the concepts don't change.
     - Setup is tricky. \clss{OSCFunc} code is simple.\\
       (Note: The setup is not any easier in Max/MSP.)
**** A "playable" mobile interface involves:
     - Processing the incoming data to make physical sense.
     - Creating more controls!\\
       If you can write one \clss{OSCFunc}, it's not any harder to write 10 or 15.

*** Side note: MIDI
**** MIDI input is very much like OSC input!
     If you know how to get OSC, MIDI is easy.
     - \clss{MIDIFunc} and \clss{MIDIdef}: Same design as \clss{OSCFunc}.
     - Parameters are different because MIDI is not OSC.
     - We won't discuss details; see \clss{MIDIFunc}'s help file.

* Not yet							   :noexport:
** Central hub
** Turning faders into buttons: Thresholds

* Toward complex composition
** Simple ideas
*** The trick
**** The trick to making music by programming:
**** quote							    :B_quote:
     :PROPERTIES:
     :BEAMER_env: quote
     :END:
     A simple idea by itself is boring.\\<all>
     Lots of simple ideas, working together, make music.

*** Workflow
**** A typical way to develop interesting musical element:
     1. Start with a basic idea of this element's role in the piece.
     2. Write a simple synth and/or pattern that seems related.
     3. Listen carefully. What is missing from the simple idea?\\
	Think of /small/ adjustments.
     4. Write a new component:
	- A second or third \gls{oscillator} (or \gls{granular} node);
	- An \gls{LFO} or \gls{envelope} module to control some parameter;
	- A more complex child pattern in \clss{Pbind};
	- Another GUI or external control.
     5. Go back to step 3.

*** Experience
**** That almost makes it sound easy...
     /Experience/ is what's missing from that picture.
     - What techniques work for what kinds of sounds?\\
       E.g., FM synthesis with ratio = 0.5 makes great basslines.
     - *Dos* and *don'ts* of modulation.
     - When to control an input by \clss{Pbind} vs. modulation units?
**** No way to learn, except to /try/ and /make mistakes/.
     Here in the workshop, I can help steer you in the right direction.

*** Try it together, as a group
**** Let's take 20--40 minutes to do this as a group.
     Questions to get you started thinking:
     - What kind of sound or texture do you want?\\
       Pitched or noisy? High, low or middle frequencies?
     - What kind of musical behavior?\\
       Rhythmic or not? Tonal or not?
     - Any sound effect you heard somewhere, that we can try?
**** If none of those spark any ideas---
     - Which synthesis technique would you like to explore more?

*** Working...
#+begin_center
Switch over to SuperCollider and start building...
#+end_center

** Composition: Representing musical information
*** Data representation
**** Composition depends on /representing musical information/.
     - Western notation: Notes and rhythms.\\
       Assumes 12 notes per octave, double or triple divisions of time.
     - Logic or Cubase "piano roll" view: Similar assumptions.\\
       Time is more flexible.
**** Both of these assume a beginning-to-end sequence.
     - In SC, we don't have to follow that rule!
     - We have more choices to store useful information.

*** Representing pitch
**** Recall \clsspl{Event}, and three ways to write pitch.
     - \ci{\textbackslash freq} in Hz.
     - \ci{\textbackslash midinote} in MIDI note numbers.\\
       Converted to Hz according to 12-ET.[fn:03ac80c1]
     - \ci{\textbackslash degree} in scale degrees.\\
       - Converted to \ci{\textbackslash midinote} based on \ci{\textbackslash scale}, \ci{\textbackslash root} and \ci{\textbackslash octave}.
       - \ci{b} and \ci{s} modifiers: \cd{4s} means degree 4, sharped. \ci{b} is flat.
**** If you're using pitch, decide which one best fits the material.

*** Scale patterns and tuning systems
**** Diatonic: \clss{Scale} provides many scale patterns.
     - The \ci{\textbackslash scale} event parameter specifies which
       scale degrees map onto which semitones.
       Makes sense only for \ci{\textbackslash degree}.
     - Easy: \cd{\textbackslash scale, Scale.minor} or \cd{.major}.
     - Modes: \ci{ionian}, \ci{dorian}, \ci{phrygian} etc.
     - Use \cd{Scale.directory} to see a full list.
**** Diatonic or chromatic: \clss{Tuning} for tuning systems.
     - Default is \cd{\textbackslash tuning, Tuning.et12}.
     - \ci{pythagorean}, \ci{kirnberger}, \ci{werckmeister} etc.

*** Transposition
**** Transposition depends on the kind of pitch.
     - \ci{\textbackslash freq}: Can /multiply/ by a frequency ratio.
     - \ci{\textbackslash midinote}: Can transpose /chromatically/ (by semitones).\\
       Fractional semitones are OK: 0.5 = up a quarter-tone.
     - \ci{\textbackslash degree}: Can transpose /diatonically/.
**** Event parameters for transposition.
     - \ci{\textbackslash ctranspose} :: Chromatic transposition. OK with \ci{\textbackslash midinote} and \ci{\textbackslash degree}.
     - \ci{\textbackslash mtranspose} :: Diatonic transposition. OK with \ci{\textbackslash degree}.

*** Exercise: Write pitch patterns
**** Write a few patterns, using pitch in different ways.
     - At least one chromatic and one diatonic.
     - Play chords with arrays of pitches.
     - You should start to see how your choice of pitch type influences what you can do.

*** Representing rhythm
**** Usually in \eglspl{beat}.
     - \clsspl{TempoClock} run in beats.
     - \Gls{delta} time = 1 means the next event is one beat later.
     - You can change the tempo.
**** Sometimes useful to write rhythm as \eglspl{time point} within the bar.
     - Often useful for drum rhythms.
     - See also Milton Babbitt's "time-point sets."\\
       [[http://en.wikipedia.org/wiki/Time_point]]
     - \clss{Pdelta} converts a pattern of time points into deltas.

*** Deltas vs. time points 1
**** First we need a sound to play.
     Questions for you:
     - Can you guess what it will sound like, from reading the code?
     - Does it make sound right away? Why or why not?
     - How would you make it sound on demand?
#+name: timept1
#+caption: A quick-and-dirty sound to trigger in rhythm.
#+begin_src {SuperCollider} -i
p.clear;  // or p = ProxySpace.new; p.push;

~sound = { |t_trig, freq = 660, amp = 0.1|
   var sig = PinkNoise.ar(amp),
   eg = EnvGen.kr(Env.perc(0.01, 0.2), t_trig);
   sig = BPF.ar(sig, freq, 0.1);
   (sig * eg).dup
};
~sound.play;
#+end_src

*** Deltas vs. time points 2
**** What does it look like to use \glspl{delta} or \glspl{time point}?
     - Note the use of \clss{Pdefn} to switch the duration pattern independently.
     - New feature: \mth{quant}.
       - Sets the \egls{quantization} time.
       - Here, it guarantees that \cd{Pdefn(\textbackslash dur)} and \ci{\textasciitilde player} can change their patterns only on the bar line.
#+name: timept2
#+caption: Play a rhythm on the previous sound, using deltas.
#+begin_src {SuperCollider} -i
Pdefn(\dur).quant = 4;
Pdefn(\dur, Pseq([1, 0.5, 0.5, 1, 1], inf));

~player.quant = 4;
~player = \psSet -> Pbind(
   \freq, 660, \amp, 1,
   \dur, Pdefn(\dur)
);
#+end_src

*** Deltas vs. time points 3
**** Can you predict the change in rhythm?
#+name: timept3
#+caption: Play a rhythm, using time points.
#+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(Pseq([0, 1, 1.5, 2.5, 3], inf), 4));
#+end_src
**** Which is better?
     - I would use \clss{Pdelta} for a rhythm where the position within the bar is more important.

*** PTimePoints
**** Synchronizing to the bar line is a bit tricky with \clss{Pdelta}.
     The example avoids the problem by:
     - Setting \ci{quant} for both \ci{Pdefn(\textbackslash dur}} and the \clss{Pbind}.
     - Putting a note on the downbeat.
**** What if the downbeat is a rest?
     - For techniques with \clss{Pdelta}, see the printed reference.
     - Or, use \clss{PTimePoints}, which acts on a Pbind.

*** PTimePoints and barlines
**** \clss{TempoClock} controls barlines.
     - Set it using \mth{beatsPerBar}.
     - You should do this only on a barline! See Listing [[timept4]].
     - Future barlines will be relative to the moment when the meter changed.
#+name: timept2a
#+caption: Rewriting the previous example to use PTimePoints.
#+begin_src {SuperCollider} -i
~player.clear;

~player.quant = 4;
~player = \psSet -> PTimePoints(Pbind(
   \freq, 660, \amp, 1,
   \timept, Pseq([0, 1.0, 1.5, 2, 3], inf)
));
#+end_src

*** Meter changes
**** Just for fun, a Babbitt-style time-point series.
     - More fun if the tempo is faster.
     - 12 notes, 12 possible time points: 3/4 time.
     - Note that we /schedule/ the meter change for the next barline.\\
       \cd{-1} is a \ci{quant} value meaning "next barline."
#+name: timept4
#+caption: Set the meter to 3/4 time, and play a sequence where the pitches and time points come from the same series.
#+begin_src {SuperCollider} -i
TempoClock.play({ TempoClock.beatsPerBar = 3 }, -1);
TempoClock.tempo = 2;  // beats/sec; 2 --> 120 bpm

~player = \psSet -> PTimePoints(Pbind(
   // randomly shuffled pitch classes
   \row, Pshuf((0..11), inf),
   \midinote, Pkey(\row) + 84,
   \timept, Pkey(\row) * 0.25,
   \amp, 5
));

TempoClock.default.gui;
#+end_src

*** \clss{Pdelta} and barlines				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** \clss{Pdelta} and barlines
A side note, somewhat advanced. You may skip this for now.

Neither approach (\clss{Pdelta} or \clss{PTimePoints}) is completely
trouble free.

\clss{PTimePoints} is generally easier. However, if
@@latex:\ci{\textbackslash timept}@@ is coming from a \clss{Pdefn},
you might occasionally get unexpected results. This is because
\clss{PTimePoints} has to subtract the current time point number from
the next---so, to generate the event to play right now, it has to read
ahead and get the next event early. If you switch the
\ci{\textbackslash timept} pattern by a proxy, you might think the
first value from the proxy would be placed relative to "now," but it's
actually relative to the next event's time point.

To avoid this, replace \clss{PTimePoints} along with the time point
pattern. /Pattern composition/, covered in the next section, is a nice
way to do this. An example will appear at that time.

With \clss{Pdelta}, you have to handle the barlines yourself, using
one of two techniques:

- Start the pattern with an offset from the barline. A
  \gls{quantization} time is a multiple of beats /and/ an offset,
  called \ci{phase}. This is easy in "canonical" style, because you
  can pass the \ci{quant} as an argument when playing the pattern:
  #+begin_src {SuperCollider} -i
x = Pbind(
   ...,
   \dur, Pdelta(Pseq([1.5, 4], inf), 4)
).play(quant: [4, 1.5]);
  #+end_src
  It's somewhat more difficult with proxies, because you have to set
  the quantization time using \cd{quant =}, separate from changing or
  playing the proxy.

- Or, add a rest at the beginning of the pattern. In this example, the
  indentation shows you how the pieces fit together. This duration
  pattern will start at the beginning of the bar, but the first event
  won't do anything because the \clss{Rest} marks the event as a rest.
  #+begin_src {SuperCollider} -i
Pdefn(\dur, Pdelta(
   Pseq([  // a wrapper for the Rest
      Rest(0),
      Pseq([1.5, 3], inf)  // the real rhythm
   ]),
   4
));
  #+end_src
  If you use this approach, make sure to leave dummy values in the
  other child patterns. That's not an issue in the above example
  because the frequency doesn't change.

** Composition: Phrase structures
*** Simple patterns, working together
#+begin_latex
\begin{block}{Musical structure is a \emph{hierarchy}.\mode<article>{\footnote{
Ethnomusicologists would take issue with the blanket statement that
musical structure \emph{is} hierarchy (which I admit I've
oversimplified). Some of the world's music does not depend heavily on
multiple layers of structure. A fine example is the music of the Aka
pygmies of central Africa. Still, notes combine into repeated rhythmic
and melodic cells in Aka music, so I think it's safe to say that music
isn't free of structure.
    }
  }
}
\begin{itemize}
\item Notes combine into phrases.
\item Phrases combine into full "sentences" (self-contained thought).
\item Sentences build up a section of a piece.
\item A full piece has many sections.
\end{itemize}
\end{block}
#+end_latex
**** Musical problem with simple patterns: No hierarchy.
     - The simple patterns discussed earlier just do one thing.
     - This gets boring, quickly.\pause
**** Solution: Patterns /in combination/.
     - Patterns within patterns.
     - Patterns referring to each other.

*** Note: Musicology				   :B_ignoreheading:noexport:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Ethnomusicologists would take issue with the blanket statement that
musical structure /is/ hierarchy (which I admit I've
oversimplified). Some of the world's music does not depend heavily on
multiple layers of structure. A fine example is the music of the Aka
pygmies of central Africa. Still, notes combine into repeated rhythmic
and melodic cells in Aka music, so I think it's safe to say that music
isn't free of structure.

*** Use "canonical" style here
**** For simplicity, "canonical" patterns are easier.
     - This is about flow of control.\\
       Sound is less important (for now).
     - Use the default \ci{SynthDef}.
     - You can still assign the pattern to a proxy variable, e.g. @@latex:\ci{\textasciitilde player}@@.
     - This makes it easier to replace the pattern.

*** Sequence of sequences
**** Just about anything can go into a sequence.
     - \clss{Pseq} can stream out a list of numbers.
     - It can also stream out a list of /patterns/!
     - Each pattern runs to completion.\\
       Then the next pattern takes over.

*** Exercise: Two rhythmic levels
**** Exercise: 8 short notes, 2 long notes, repeated.
     - Key idea: Break a problem down into smaller parts.
     - Small parts are easier to write.
     - Then put them together into bigger pieces.
**** To write:\pause
     1. Write a pattern to make 8 short, random, durations.\pause
     2. Write a pattern to make 2 long, random, durations.\pause
     3. Put them together in \clss{Pseq}.\\
	How would you make it repeat forever?\pause
     4. Use this for \ci{\textbackslash dur} in a \clss{Pbind}.

*** Pseq and other list patterns
**** \clss{Pseq} handles /flow of control/ between other patterns.
     - In regular programming, one statement follows another.\\
       They run in sequence.
     - \clss{Pseq} does the same for patterns.
     - Using \ci{repeats}, it's also a \egls{looping} mechanism.\\
       Like \mth{do} (which we saw before).
**** Other list patterns can run the subpatterns out of order.
     - Randomly: \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}, \clss{Pshuf}.
     - Other orderings: \clss{Place}, \clss{Pslide}, and more.

*** Sequence of phrases
**** List patterns may also contain \clsspl{Pbind}!
     (This idea totally blew my mind.) You can:
     - Write a \clss{Pbind} that plays exactly one phrase.\\
       /All/ note parameters for that phrase are included.
     - Write more \clsspl{Pbind} for other phrases.
     - Put them together in a list pattern.
**** A clear example is in the help system.
     See "Pattern Guide 04: Words to Phrases."

*** Using phrase patterns by name
**** Easier to read: Give /names/ to the phrase patterns.
     - Write a \clss{Dictionary} of names and patterns.\\
       \clss{Event} syntax is easier: \cd{(name: pattern, ...)}.
     - Then use one of these to stream them out:
       - \clss{Psym} if the dictionary holds event patterns.
       - \clss{Pnsym} if it holds value patterns.
**** Both follow this outline:
     \cd{Psym(patternOfNames, dictionary)}.

*** Exercise
    1. Rewrite the last exercise to use \clss{Pnsym} for rhythm.
    2. Add more rhythm phrases, with names.
**** Points to consider:
     - Writing the dictionary should be fairly easy.
     - What is the \ci{patternOfNames} that would behave exactly like the last exercise?
     - Also try putting the \ci{patternOfNames} into a \clss{Pdefn}.
       - \cd{Pdefn(\textbackslash names, Prand([\textbackslash short8, \textbackslash long2], inf));}
       - \cd{Psym(Pdefn(\textbackslash names), (...))}.
       - Now you can play with the name pattern separately.

*** Summary: Sequences of patterns
**** We now have ways to make /hierarchical/ musical structures.
     - Short, simple phrases.
     - Streamed out, one after the other, in various orders:
       - \eGls{looping} in the same order: \clss{Pseq}.
       - Random order: \clss{Prand}, \clss{Pwrand}, \clss{Pxrand}, \clss{Pshuf}.
     - As it gets more complex, use phrase names for legibility.
       - Store phrases in a \clss{Dictionary}, with names.
       - Decide the phrase order (\ci{patternOfNames}).
       - Play them in that order (\clss{Psym}, \clss{Pnsym}).
**** Remember: "Lots of simple ideas, working together, make music."

** deprecated							   :noexport:
*** Looping and branching in patterns
**** Computers decide what to do based on:
     - \eGls{looping} :: Repeating the same sequence of actions.
     - \eGls{branching} :: *If* this, *then* do that; *else* do the other.\glsadd{if}
**** \clss{Pseq} is a looping structure for patterns.
     If you're looping only one thing, see also \clss{Pn}.
**** Branching for patterns:
     - Random-order list patterns are one form of branching.
     - Also, branch based on a condition: \clss{Pif}.
     - Or choose, per event, from several branches: \clss{Psym1}, \clss{Pnsym1}, \clss{Pswitch1}.

*** MAYBE Pif							   :noexport:
**** \clss{Pif} chooses which branch for every yielded value.
     Its arguments:
     - A pattern yielding \ci{true} or \ci{false}.
     - The pattern to evaluate when the first is true.
     - The pattern to evaluate when the first is false.
**** Example: 80% short notes, 20% long notes.
     - \mth{coin} is a weighted coin toss.
#+name: pif1
# #+caption: A simple example of Pif, to choose short notes 80% of the time.
#+begin_src {SuperCollider} -i
~player = Pbind(
   \freq, Pexprand(200, 800, inf),
   \dur, Pif(Pfunc { 0.8.coin },
      Pwhite(0.05, 0.15, inf),
      Pwhite(0.4, 0.75, inf)
   )
);
#+end_src

*** Pkey: Sharing data in Pbind
**** \clss{Pkey} reads an earlier value inside a \clss{Pbind}.
     - Base one value on another value.
     - We saw this yesterday, briefly, in Listing [[segxf2]].\\
       There, \ci{\textbackslash time} should equal \ci{\textbackslash dur}.\\
       \cd{\textbackslash time, Pkey(\textbackslash dur)} copies the value.
     - You can do math on \clss{Pkey} (just like any pattern).\\
       E.g., filter frequency = 4 times the note's frequency.
       \cd{\textbackslash ffreq, Pkey(\textbackslash freq) * 4}.


*** MAYBE Modularity						   :noexport:
**** This is like modular synthesis, for sequencing.
     Write smaller, self-contained units of code.
     - Each unit is simpler to understand:\\
       Play one phrase, or make one component of a synth.
     - Combine them into bigger structures.
**** /Modularity/ is a crucial programming concept.
     - Big chunks of code break easily.
     - Smaller modules that work together are easier to understand and control.

*** Next slides 						   :noexport:
**** DONE Pdict, Psym (naming patterns)
**** MAYBE Branching (Pif, Pswitch1, Psym1)
**** MAYBE Changeable parameters (initial pattern args vs. streams)
     Also Plazy
**** MAYBE Pkey
**** MAYBE Pchain

*** Summary: Combining patterns

* Considerations for group composition
** Unity and contrast						   :noexport:
*** You take the lead
    From here, we will do less guided explanation of techniques, and
    focus more on your creativity.
    - Larger modular synths;
    - Pattern sequences with more musicality;
    - Control in performance by external devices.

** Group composition: Technical issues
*** Workshop project: A group composition
**** The rest of the workshop: Create a group performance.
     - You'll each write an element of the musical texture.
     - Control it by mobile.
     - Your code will run on my computer.
**** To discuss:
     - Practical: How to combine code on one machine.
     - Creative: What elements do we need?

*** Practical: Combining code
**** Keep your resources in your own sandbox.
     We saw a hint of this before.
     - Each element goes in its own \clss{ProxySpace}.
     - Buffers and other resources in a \clss{Dictionary}.
     - Easiest: Interpreter variables (\ci{a} to \ci{z}) for storage.\\
       Only 25 available (reserve \ci{s} for the default server).
**** Pick a letter.
     - Assign an empty Dictionary for storage.
     - Save the ProxySpace in it.
#+name: combine1
#+caption: Create storage for a compositional element in the interpreter variable "a." Substitute your own letter.
#+begin_src {SuperCollider} -i
a = ();  // empty Event syntax (easier)
a.p = ProxySpace.new;
#+end_src

*** Note: Pseudo-methods				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
Listing [[combine1]] takes advantage of a special feature of
\clsspl{IdentityDictionary} (including \clsspl{Event}): you can access
items in the dictionary /using method call syntax/, as long as the
method name is not already taken. That is, \ci{p} is not a real method
of \clss{Event}, but the event /responds/ as if it were:
@@latex:\cd{a.p = ProxySpace.new}@@ is like
@@latex:\cd{a[\textbackslash p] = ProxySpace.new}@@, and \cd{a.p} is
like \cd{a[\textbackslash p]}.

This is not exactly the same as a method call, but you don't need to
worry about the differences at this stage.

*** Using the ProxySpace
**** While developing, you can \ci{push} the \clss{ProxySpace}.
     - Then use \ci{\textasciitilde environment} variables, as before.
**** GUI and \clss{OSCFunc} actions should go through the storage variable.
     - \cd{a.p[\textbackslash proxyName]}.
     - *Don't* use \cd{\textasciitilde proxyName} here!\\
       This syntax depends on the right \clss{ProxySpace} being current.\\
       We will have many \clsspl{ProxySpace}.\\
       No guarantee that the current one is right.

*** Note: Loading the proxies in performance		    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
When loading everyone's code, we'll need to \ci{push} each
\clss{ProxySpace} temporarily, one by one. \ci{push} and \ci{pop} work
for this, but it's even easier to \ci{use} the
\clss{ProxySpace}. \ci{use} takes a function, and runs it "inside" the
given \clss{Environment}. It also reverts to the original
\ci{currentEnvironment} when it's finished, /even if/ the code stopped
with an error. This makes it safer as well.

But again, for experimenting with synthesis, you should still
\ci{push} the \clss{ProxySpace}, so that you can live in it for a
longer time.

*** Example: A buffer player
**** To illustrate, we'll start with a buffer granulator.
     - The buffer should be stored in \ci{a}.\\
       We've seen this before.
     A new idea: *Automatic cleanup.*
     - Write a function that will remove whatever you just created.
     - Use \mth{addFunc} to keep a \clss{FunctionList} of cleanups.
     - At the end, you can just call \ci{a.cleanup}.
#+name: combine2
#+caption: Loading a buffer into a storage dictionary, and adding an automatic cleanup function.
#+begin_src {SuperCollider} -i
a = ();  // empty Event syntax (easier)
a.p = ProxySpace.new;

a.buf = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
a[\cleanup] = a[\cleanup].addFunc { a.buf.free };
#+end_src

*** Synthesis for "a"
**** Creating the synthesis should be familiar.
     - \mth{push} the \clss{ProxySpace}. (Note: This is now \cd{a.p}, not \cd{p}.)
     - Create proxies as before. Refer to the buffer by \cd{a.buf}.
#+name: combine3
#+caption: Using a ProxySpace with entities from "a" storage.
#+begin_src {SuperCollider} -i
a.p.push;
~grains.addSpec(\overlap, [0.1, 10, \exp]);
~grains.addSpec(\grainDur, [0.05, 1, \exp]);
~grains.addSpec(\speed, [0.5, 2, \exp]);
~grains = { |overlap = 5, grainDur = 0.1, speed = 0.75|
   var trig = Impulse.kr(overlap / grainDur),
   center = Phasor.kr(
      rate: speed * ControlDur.ir,
      start: grainDur,
      end: a.buf.duration - grainDur
   );
   TGrains.ar(2, trig, a.buf, 1, center, grainDur);
};
~grains.play;

a.p.gui;
#+end_src

*** Custom GUI
**** Custom GUI actions should go through \ci{a}.
     - *Don't* just use \ci{\textasciitilde} syntax!
     - The action function can't guarantee where \ci{\textasciitilde} will look.
     The same is true of \clss{OSCFunc} actions.
#+name: combine3b
#+caption: Custom GUI action, using "a.p" to access NodeProxies.
#+begin_src {SuperCollider} -i
a.speedctl = EZSlider(nil, Rect(700, 200, 300, 20),
   "speed", [0.5, 2, \exp],
   // Action is here. Note syntax: a.p[\grains].
   { |view| a.p[\grains].set(\speed, view.value) },
   0.75, initAction: true
);
#+end_src

*** Add another compositional element
**** Do the same thing, with a different letter variable.
     Now we have two environments at once.
     - \ci{a} has its own \clss{ProxySpace} and resources.
     - \ci{b} has a separate \clss{ProxySpace} and resources.
**** The separation is important for bigger projects.
     - Things that you do in \ci{b} should not break \ci{a}!
     - This is much easier if \ci{a} and \ci{b} /can't talk to each other/.
#+name: combine4
#+caption: Storage for another compositional element.
#+begin_src {SuperCollider} -i
b = ();
b.p = ProxySpace.new;
#+end_src

*** Buzzword: "Scalable"
    "Scalable" means: Handling 20 is as easy as handling two.
**** We can just keep going like this...
     \pause ... and build a pretty intricate piece.

** Group composition: Creative issues
*** Unity and contrast
**** Music finds a balance between two opposites.
     - Unity :: The elements that hold the music together.
     - Contrast :: Variety, change, renewed interest.
**** These ideas will guide our composition process.
     Decisions to make:
     - What musical elements do we need?
     - Who is responsible for each element?

*** Melody
**** Melodic /unity/.
     - Hearing the same melody at different times.\\
       Slight variations work just as well.
     - Using melodic /cells/ to build different melodies.
**** Melodic /contrast/.
     - Introducing new melodies or new variations.
     - Dividing the piece into /sections/ based on different themes.
     - Without conventional notes:
       - /Pitch register/ can distinguish themes and sections.
       - @@latex:Gy\"orgy Ligeti@@, /Melodien/.
       - Trevor Wishart, /Vox 5/.

*** Harmony
**** Harmonic factors:
     - Harmony: Yes or no?
     - How many notes at once?\\
       Many notes $\to$ more complex chords.
     - Modal or chromatic.\\
       Modes: Usually diatonic or pentatonic scales.
     - Consonant or dissonant.
     - Tuning systems.\\
       - Not limited to 12-tone \gls{equal temperament}.
       - The whole piece shouldn't use too many tuning systems.
**** Harmonic contrast:
     - Modulating from one key area to another.
     - Density (number of notes) is powerful.

*** Rhythm
**** Rhythmic factors:
     - Strong pulse or weak/no pulse.\\
       Strong pulse: Durations are integer multiples of a base value.
     - Fast or slow.
     - Consistent or inconsistent density.\\
       I.e., small or big differences between long and short durations?
**** Unity and contrast
     /Unity/:
     - Establish a rhythmic "identity" for an element.
     - Several elements coordinated by the same pulse (tempo).
     /Contrast/:
     - Elements with different identities.
     - Changing one or more rhythmic factors.

*** Texture
**** Textural factors:
     - Type of texture, especially:
       - /Homophonic/: Lead part, with accompaniment.
       - /Polyphonic/: Several interdependent parts.
       - /Heterophonic/: One "melody," played by several parts with different "decoration."
     - Density: How much "white space"?\\
       White space: Silence, or empty frequency bands.
**** Texture is especially powerful for contrast.

*** Timbre (tone color)
**** Timbre is /very hard/ to talk about.
     - Pierre Schaeffer, /Treatise on Musical Objects/ (1966).
     - Denis Smalley's research on /spectromorphology/.
**** For this project, keep it simple.
     Timbral factors:
     - /Pitched/ or /noisy/.
     - /Narrow/ or /wide/ range of frequencies.
     - /Steady/ or /changing/.\\
       \eGlspl{envelope}, \eglspl{LFO} or /mobile control/ applied to filter frequency, FM modulation index etc.

*** Brainstorming
**** Take a few minutes to think about sounds, textures, patterns you'd like to explore.
     Here are those musical features again:
#+attr_latex: :align |l|p{0.75\textwidth}|
| *Feature* | *Factors*                                                                       |
|-----------+---------------------------------------------------------------------------------|
| Melody    | Themes, melodic cells, pitch register                                           |
| Harmony   | Number of notes, consonance vs. dissonance, modal vs. chromatic, tuning systems |
| Rhythm    | Strength of pulse, speed, density                                               |
| Texture   | Type of texture, density                                                        |
| Timbre    | Pitch or noise, narrow- or wide-band, steady or changing                        |

*** Returning to unity and contrast
**** Your different ideas will provide contrast!
     - Where, among these ideas, can we create unity?
     - Especially /common materials/.
**** For the rest of today...
     - Make some decisions about materials.
     - Start coding!\\
       When you run into trouble, /ask me/.

* Removed							   :noexport:
*** Branching: Case
**** \mth{case} combines several if--then--else structures.
     - \cd{if(condition)}
       - Then \cd{branch}
       - Else \cd{if(condition2)}
	 - Then \cd{branch2}
	 - Else...
#+name: case1
# #+caption: A case statement, putting a random number in one of three categories.
#+begin_src {SuperCollider} -i
x = 10.rand;
case { x < 3 } {
   "low random number: %\n".postf(x);
}
{ x < 6 } {
   "mid random number: %\n".postf(x);
}
{ x < 10 } {
   "high random number: %\n".postf(x);
};
#+end_src

*** Branching: Switch
**** \mth{switch} is like "case" in other languages.
     - The fastest way to match a value to an action, /if/ you know in
       advance what the values can be.
     - For example, a GUI \ci{Button} has integer values 0, 1, 2...
     - This would be easy to match using \mth{switch}.
#+name: switch1
# #+caption: A switch statement, matching an exact value.
#+begin_src {SuperCollider} -i
switch(3.rand,  // 3.rand == 0, 1 or 2
   0, { "zero" },  // do this if 3.rand === 0
   1, { "one" },
   2, { "two" }
);
#+end_src

*** "If" is the most common
**** You'll use \mth{if} a /lot/.
     Don't worry too much about \mth{case} or \mth{switch} for now.
**** Possible uses are... basically infinite.
*** Removed loop stuff
**** Now we'll take apart what they really do.

*** All looping comes from "while"
**** The basis of all looping is \mth{while}.
     - @@latex: \cd{while \{ condition \} \{ loop body \}}@@.\\
       *IMPORTANT:* The condition must be in braces, /not/ parens!!!
     - When the condition is true, the loop body runs again.
     - When it becomes false, the loop stops.
     - \cd{10.do} is actually a \mth{while} loop like this:
#+name: while1
# #+caption: A while loop, showing how "number.do" really works.
#+begin_src {SuperCollider} -i
i = 0;
while { i < 10 } {
   i.postln;  // <-- this is the "do" function
   i = i + 1;
};
#+end_src

*** Loop exit conditions
**** *VERY IMPORTANT:* There must always be an exit condition! :B_alertblock:
     :PROPERTIES:
     :BEAMER_env: alertblock
     :END:
     - In the last example, if you forget \cd{i = i + 1}, then \ci{i} never changes.
     - It will always be < 10.
     - The loop will never exit---an \egls{infinite loop}.
     - Infinite loops will lock up SuperCollider. You have to force quit.
**** I can't count the number of times I made that mistake...
     Fortunately, \ci{do} and other types of loops handle the exit condition for you.

*** Use of while
**** You won't use \mth{while} very often.
     - \ci{do} etc. handle most loop situations, and they're safer.
     - \mth{while} is useful when you don't know how many times you have to loop.
     - For example, reading from a file:
#+name: while2
# #+caption: A while loop, showing how "number.do" really works.
#+begin_src {SuperCollider} -i
(
f = File(thisProcess.platform.startupFiles.last, "r");
while {
   x = f.getLine;
   x.notNil  // keep going until 'nil'
} {
   x.postln;
};
f.close;
)
#+end_src

*** Note: exit condition				    :B_ignoreheading:
    :PROPERTIES:
    :BEAMER_env: ignoreheading
    :END:
**** What's the exit condition?
     There is no infinitely-long file. Eventually it will run out of
     information, and \ci{getLine} will return nil. Then the loop stops.

*** Misc OSC
    - In TouchOSC, @@latex:\ci{"/1/fader1"}@@ means screen 1, first fader.

* Footnotes

[fn:03ac80c1] Twelve-note \gls{equal temperament}.

[fn:6607d9b8] Credit to Jeffrey Stolet for this insight.

